[
  
  {
    "title": "[Node.js] Express API 서버 구축 - 앱 구조화 및 라우팅",
    "url": "/posts/Node.js-04/",
    "categories": "Node.js",
    "tags": "Node.js, Javascript",
    "date": "2022-02-09 00:00:00 +0900",
    





    "snippet": "사전준비"
  },
  
  {
    "title": "[Node.js] Express API 서버 구축 - 설치 및 실행",
    "url": "/posts/Node.js-03/",
    "categories": "Node.js",
    "tags": "Node.js, Javascript",
    "date": "2022-02-09 00:00:00 +0900",
    





    "snippet": "사전준비  Node.js 설치  VSCode설치하기작업 디렉토리 생성$ mkdir myapp$ cd myappnpm package.json 생성npm init 명령어를 실행하면 애플리케이션의 이름 및 버전과 같은 몇 가지 정보를 구성하게 되는데 대부분 기본값으로 넘긴다.$ npm initentry point는 app.js 혹은 자유롭게 작성해도된다.(package.json에서 자유롭게 수정가능)entry point: (index.js)Express 설치Express를 임시로 설치하고 package.json에 종속 항목 목록에 추가하지 않으려면, --save 옵션을 생략한다.$ npm install express --save  –save 옵션을 통해 설치된 Node 모듈은 package.json 파일 내의 dependencies 목록에 추가된다. 이후 app 디렉토리에서 npm install을 실행하면 종속 항목 목록 내의 모듈이 자동으로 설치된다.express 실행app.js 파일을 생성 후 아래의 코드를 작성한다.const express = require(&#39;express&#39;)const app = express()const port = 3000app.get(&#39;/&#39;, (req, res) =&amp;gt; {  res.send(&#39;Hello World!&#39;)})app.listen(port, () =&amp;gt; {  console.log(`Example app listening on port ${port}`)})아래의 명령어로 app을 실행$ node app.jshttp://localhost:3000/로 접속하면 Hello world!이 출력될 것이다. 여기까지 했으면 준비완료!"
  },
  
  {
    "title": "[Javascript]] this는 어떻게 동작할까?",
    "url": "/posts/javascript-05/",
    "categories": "Javascript",
    "tags": "Javascript, ES6",
    "date": "2022-02-07 00:00:00 +0900",
    





    "snippet": "시작으로Javascript에서 함수의 this 키워드는 다른 언어들과 다르게 동작한다. 이는 Java와 같은 익숙한 언어의 개념과 달라 개발자들에게 혼동을 준다.대부분의 경우 this의 값은 함수를 호출한 방법에 의해 결정된다. 실행중에는 할당으로 설정할 수 없고 함수를 호출할 때 마다 다를 수 있다.Java에서의 this는 인스턴스 자신을 가르키는 참조변수이다. this가 객체 자신에 대한 참조 값을 가지고 있다는 뜻이다. 주로 매개변수와 객체 자신이 가지고 있는 멤버변수명이 같은 경우 이를 구분하기 위해 사용된다.하지만, Javascript의 경우 Java와 같이 this에 바인딩되는 객체는 한가지가 아니라 해당 함수 호출 방식에 따라 this에 바인딩되는 객체가 달라진다.함수의 4가지 호출 방식  함수 호출  메서드 호출  생성자 함수 호출  Call, Apply, Bind 호출함수 호출기본적으로 this는 전역객체(Global object)에 바인딩된다. 전역함수는 물론이고 내부함수의 경우에도 this는 외부함수가 아닌 전역객체에 바인딩된다.여기서 전역객체(Global object)란 모든 객체의 유일한 최상위 객체를 말한다. 일반적으로 Browser-side에서는 window, Server-side(Node.js)에서는 global 객체를 의미한다.전역객체는 전역 스코프(Global Scope)를 갖는 전역변수(Global variable)를 프로퍼티로 소유한다. 글로벌 영역에 선언한 함수는 전역객체의 프로퍼티로 접근할 수 있는 전역 변수의 메소드이다.var x = &#39;global&#39;;console.log(x); // globalconsole.log(window.x); // globalconsole.log(this.x); // globalfunction global_fn() {  console.log(&#39;global function&#39;);}window.global_fn(); // global functionthis.global_fn(); // global function// browser consolethis===window // true// node terminalthis===global // true브라우저 콘솔과 Node.js 터미널에 this를 입력해보면 아래와 같은 객체가 출력된다.메서드 호출함수가 객체의 프로퍼티 값이면 메소드로서 호출된다. 이때 메소드 내부의 this는 해당 메소드를 소유한 객체, 즉 해당 메소드를 호출한 객체에 바인딩된다.이를, 암시적 바인딩이라 한다.var object = {    value : 100,    obj_fn : function(){        console.log(this.value);    }}var object2 = {    value : 200};object.obj_fn(); // 100object2.obj_fn(); // 200생성자 함수 호출생성자 함수란 객체를 생성하는 역할을 한다. 함수를 new 키워드와 함께 생성자로 호출하면 생성자 함수로 동작한다. 생성자 함수가 아닌 일반 함수에 new 키워드를 붙여 호출하면 생성자 함수처럼 동작할 수 있다. 일반적으로 생성자 함수명은 첫문자를 대문자로 기술하여 혼란을 방지하려 노력한다.주의해야할 사항으로는  new 키워드와 함께 생성자 함수를 호출하지 않으면 생성자 함수로 동작하지 않는다.function Create_fn(name){    this.name = name;}var men = new Create_fn(&#39;Men&#39;);console.log(men); // Create_fn {name: &#39;Men&#39;}// new 키워드와 함께 생성자 함수를 호출하지 않으면 생성자 함수로 동작하지 않는다.var female = Create_fn(&#39;Female&#39;);console.log(female ); // undefined그럼 new 키워드는 클래스의 인스턴스화인가? 결론부터 말해면 No!new 키워드 바인딩 동작순서를 쪼개서 실험해보면 아래와 같다.  새 객체를 생성한다.  생성된 객체의 Prototype 체인이 호출 함수의 프로토타입과 연결된다.  생성된 객체를 context 객체로 사용(명시적)하여 함수가 실행된다.  이 함수가 객체를 반환하지 않는 한 생성된 객체가 반환된다.function Person(name) {  this.name = name;  this.age = 20;}var per = new Person(&#39;seongsik&#39;);console.log(per.name); // seongsikconsole.log(per.age); // 20// 위와 똑같은 과정을 쪼개보자.// 1. 새 객체를 생성한다.var obj = {};// 2. 생성된 객체의 Prototype 체인이 호출 함수의 프로토타입과 연결된다.Object.setPrototypeOf(obj, Person.prototype);this.obj // Person {} // 3. 생성된 객체를 context 객체로 사용(명시적)하여 함수가 실행된다.Person.call(obj,&#39;seongsik222&#39;);// 4. 이 함수가 객체를 반환하지 않는 한 생성된 객체가 반환된다.var per2 = obj;console.log(per2 .name); // 2console.log(per2 .age); // 20console.log(obj) // Person {name: &#39;seongsik222&#39;, age: 20}이렇듯 위의 과정이 발생한다는 것! 그리고, new 키워드는 그저 함수를 실행 시켜주는 것이다. 아래의 결과를 보면 순차적으로 함수내부를 실행시켜주는 것을 확인할 수 있다.그리고 우리가 알고 있던 클래스와 다르게 return에 객체를 반환된다.즉, Javascript의 new 키워드는 클래스의 인스턴스화가 아닌 단순히 함수를 실행시켜주는 것이다.function Person(name) {  this.name = name;  this.age = 20;  console.log(&#39;function 실행!!&#39;);  return {address : &#39;주소&#39;};}var per = new Person(&#39;seongsik&#39;); // function 실행!!console.log(per); // {address : &#39;주소&#39;}Call, Apply, Bind 호출함수 객체는 Call, Apply, Bind 메소드를 가지고 있는데, 첫 번째 인자로 넘겨주는 것이 this context 객체가 된다. 이를 명시적 바인딩이라 한다.this의 값을 한 문맥에서 다른 문맥으로 넘기려면  call()이나 apply()를 사용해야 한다.// call 또는 apply의 첫 번째 인자로 객체가 전달될 수 있으며 this가 그 객체에 묶임var obj = {a: &#39;Custom&#39;};// 변수를 선언하고 변수에 프로퍼티로 전역 window를 할당var a = &#39;Global&#39;;function whatsThis() {  return this.a;  // 함수 호출 방식에 따라 값이 달라짐}whatsThis();          // this는 &#39;Global&#39;. 함수 내에서 설정되지 않았으므로 global/window 객체로 초기값을 설정한다.whatsThis.call(obj);  // this는 &#39;Custom&#39;. 함수 내에서 obj로 설정한다.whatsThis.apply(obj); // this는 &#39;Custom&#39;. 함수 내에서 obj로 설정한다.function add(c, d) {  return this.a + this.b + c + d;}var o = {a: 1, b: 3};// 첫 번째 인자는 &#39;this&#39;로 사용할 객체이고,// 이어지는 인자들은 함수 호출에서 인수로 전달된다.add.call(o, 5, 7); // 16// 첫 번째 인자는 &#39;this&#39;로 사용할 객체이고,// 두 번째 인자는 함수 호출에서 인수로 사용될 멤버들이 위치한 배열이다.add.apply(o, [10, 20]); // 34ES5에 추가된 Function.prototype.bind를 사용하는 방법도 가능하다. Function.prototype.bind는 함수에 인자로 전달한 this가 바인딩된 새로운 함수를 리턴한다.즉, Function.prototype.bind는 Function.prototype.apply, Function.prototype.call 메소드와 같이 함수를 실행하지 않기 때문에 명시적으로 함수를 호출할 필요가 있다.function f() {  return this.a;}var g = f.bind({a: &#39;azerty&#39;});console.log(g()); // azertyvar h = g.bind({a: &#39;yoo&#39;}); // bind는 한 번만 동작함!console.log(h()); // azertyvar o = {a: 37, f: f, g: g, h: h};console.log(o.a, o.f(), o.g(), o.h()); // 37, 37, azerty, azerty"
  },
  
  {
    "title": "[Git] Software 버전 관리 규칙, 어떻게 번호를 할당하는거야?",
    "url": "/posts/git-06/",
    "categories": "Git",
    "tags": "Git, Github",
    "date": "2022-02-07 00:00:00 +0900",
    





    "snippet": "시작으로버전관리를 하기 위해 Git, Github, Gitea, Svn 등 툴을 사용하는 방법에 대해서만 관심이 있었는데 정작 버전관리를 하기 위한 규칙에 대해서는 관심이 없었다.소프트웨어 할당하는 버전은 기본적으로 유의적 버전 2.0.0-ko2을 따른다고 한다. 나도 이 글을 보면서 지식을 남기기 위해 포스팅을 시작한다.흔히 애플리케이션 버전정보를 보면 아래와 같이 x.x.x 3자리의 정수로 되어있다.이런 형태의 버전 할당은 Semantic versioning의 규칙을 따른 방식이라고 한다.Versioning소프트웨어 개발 생태계는 수많은 사람들이 서로의 기술과 성과를 이어받아 오며 믿을 수 없는 수준의 협력 체제를 구축해오고 있다. 의존성은 이러한 협력체제에서 나오게 된 요소로, 다른 사람들이 만들어온 기능을 다시 만들 필요 없이 손쉽게 가져와서 재활용하는 방식으로 빠르게 소프트웨어를 만들 수 있게 되었다.하지만 이렇게 여러 사람에게 이용되는 패키지가 새롭게 업데이트될 때, 생각보다 다양한 문제에 직면하게 된다. 기능의 사용법을 바꾸어버리거나 동작 방식의 변경 같은 변화들은 그에 의존하는 다른 소프트웨어를 의도대로 동작하지 못하게 하므로, 새로운 변화와 기존의 것을 구분할 필요가 생겼다. 버전이라는 개념은 이러한 패키지의 변화를 구분하기 위해 사용하기 시작하였다.Semantic versioningSemantic Versioning은 Github의 공동창업자인 Tom Preston-Werner가 Versioning의 문제를 해결하기 위해 기존의 현안을 모아 만든 제안이다.번호 할당은 Major.Minor.Patch 으로 할당한다고 한다. 밑에서 자세히 알아보자.유의적 버전 명세공개 API 선언  유의적 버전을 쓰는 소프트웨어는 반드시 공개 API를 선언한다. 이 API는 코드 자체로 선언하거나 문서로 엄격히 명시해야 한다. 어떤 방식으로든, 정확하고 이해하기 쉬워야 한다.버전 번호 형식  보통 버전 번호는 반드시 X.Y.Z의 형태로 한다. X, Y, Z는 각각 자연수(음이 아닌 정수)이고, 절대로 0이 앞에 붙어서는 안 된다.  X는 주(主, Major)버전 번호이고, Y는 부(部, Minor)버전 번호이며, Z는 수(修, Patch)버전 번호이다.  각각은 반드시 증가하는 수여야 한다. 예: 1.9.0 -&amp;gt; 1.10.0 -&amp;gt; 1.11.0.금지 사항  특정 버전으로 패키지를 배포하고 나면, 그 버전의 내용은 절대 변경하지 말아야 한다.  변경분이 있다면 반드시 새로운 버전으로 배포하도록 한다.초기개발 버전  주버전 0(0.y.z)은 초기 개발을 위해서 쓴다. 아무 때나 마음대로 바꿀 수 있다.  이 공개 API는 안정판으로 보지 않는 게 좋다.최초 배포 버전  1.0.0 버전은 공개 API를 정의한다.  이후의 버전 번호는 이때 배포한 공개 API에서 어떻게 바뀌는지에 따라 올린다.수(Patch)버전 증가 조건                              수(Patch)버전 Z (x.y.Z          x &amp;gt; 0)는 반드시 그 전 버전 API와 호환되는 버그 수정의 경우에만 올린다.                      버그 수정은 잘못된 내부 기능을 고치는 것이라 정의한다.부(Minor)버전 증가 조건                              공개 API에 기존과 호환되는 새로운 기능을 추가할 때는 반드시 부(Minor)버전 Y(x.Y.z          x &amp;gt; 0)를 올린다.                      공개 API의 일부를 앞으로 제거할 것(deprecate)으로 표시한 경우에도 반드시 올리도록 한다.  내부 비공개 코드에 새로운 기능이 대폭 추가되거나 개선사항이 있을 때도 올릴 수 있다.  부(Minor)버전을 올릴 때 수(Patch)버전을 올릴 때만큼의 변화를 포함할 수도 있다.  부(Minor)버전이 올라가면 수(Patch)버전은 반드시 0에서 다시 시작한다.주(Major)버전 증가 조건                              공개 API에 기존과 호환되지 않는 변화가 있을 때는 반드시 주(Major)버전 X(X.y.z          X &amp;gt; 0)를 올린다.                      부(Minor)버전이나 수(Patch)버전급 변화를 포함할 수 있다.  주(Major)버전 번호를 올릴 때는 반드시 부(Minor)버전과 수(Patch)버전을 0으로 초기화 한다.버전 우선순위  우선순위는 버전의 순서를 정렬할 때 서로를 어떻게 비교할지를 나타낸다.  우선순위는 반드시 주, 부, 수 버전, 그리고 정식배포 전 버전의 식별자를 나누어 계산하도록 한다 (빌드 메타데이터는 우선순위에 영향을 주지 않는다).  우선순위는 다음의 순서로 차례로 비교하면서, 차이가 나는 부분이 나타나면 결정된다          주, 부, 수는 숫자로 비교한다. 예: 1.0.0 &amp;lt; 2.0.0 &amp;lt; 2.1.0 &amp;lt; 2.1.1.      주, 부, 수버전이 같을 경우, 정식배포 전 버전이 표기된 경우의 우선순위가 더 낮다. 예: 1.0.0-alphaa1 &amp;lt; 1.0.0.      주, 부, 수버전이 같은 두 배포 전 버전 간의 우선순위는 식별자 숫자가 클수록 높다. 예: a1 &amp;lt; a2.      요약(Major.Minor.Patch)  기존 버전과 호환되지 않게 API가 바뀌면 “주(Major) 버전”을 올리고,  기존 버전과 호환되면서 새로운 기능을 추가할 때는 “부(Minor) 버전”을 올리고,  기존 버전과 호환되면서 버그를 수정한 것이라면 “수(Patch) 버전”을 올린다. 주.부.수 형식에 정식배포 전 버전이나 빌드 메타데이터를 위한 라벨을 덧붙이는 방법도 있다.  각 번호의 수는 항상 증가해야 한다.  버전 번호는 Major, Minor, Patch 의 형태로 배포하고, Major, Minor, Patch 는 각각 자연수이고 절대 앞에 0이 붙어서는 안된다.  특정 버전으로 패키지를 배포하고 나면, 그 버전의 내용은 절대 변경하지 말아야한다. 변경분이 있다면 반드시 새로운 버전으로 배포하도록 한다.  Major 버전이 변경될 때, Minor, Patch 는 0으로 초기화 된다.  Minor 버전이 변경될 때, Patch 는 0으로 초기화 된다.이를 좀더 쉽게 정리해보자면주(Major) : 기존이랑 다름, 싹 바뀜 =&amp;gt; 싹다 바꼈으니 주(Major) +1 해주고 나머지는 0부터 시작~ (ex 1.5.2 -&amp;gt; 2.0.0)부(Minor) : 기존이랑 같지만 거기서 새로운기능을 추가하거나 삭제할 떄 =&amp;gt; 후 새로운 기능 버그도 없고 완성했으니 부(Minor)+1 해주고 수(Patch)는 0으로 시작 (ex 1.5.2 -&amp;gt; 1.6.0)수(Patch) : 그 전버전 버그 수정만했을 때(다른거 안됨 무조건 기능 고치는 것) =&amp;gt; 기능이렇게 생각하고 버전 관리 규칙을 적용해서 할당하면 될 것 같다."
  },
  
  {
    "title": "[Nuxt.js] 공식문서로 빠르게 배우기 3탄 - Github에 정적 사이트 빌드 및 배포하기",
    "url": "/posts/nuxtJs-03/",
    "categories": "Nuxt.js",
    "tags": "Nuxt.js, Vue.js, Webpack, Babel, Node.js, Javascript",
    "date": "2022-02-01 00:00:00 +0900",
    





    "snippet": "시작하기포트폴리오 사이트용으로 오픈소스 및 템플릿을 사용하려다 맘에 드는게 없어 직접 Nuxt.js + vuetify로 포트폴리오 정적 사이트를 만들었다.정적 사이트를 빌드 및 배포하는 방법을 빠르게 공유하고자 한다.Nuxt 공식문서를 들어가면 아주 자세히 설명되어 있으니 하나씩 따라해도 금방 이해가 될 것이다.nuxt.config.js 설정일단, 3가지만 설정하면 된다.  target : 배포 대상을 명시하는 프로퍼티이다. 정적 사이트는 static을 추가해야하며 기본값은 server이다.  router : base를 추가하지 않고 폴더를 배포한 경우 배포된 사이트를 방문하면 자산 누락으로 사이트가 작동하지 않을 수 있다. 이는 웹사이트가 루트가 아니라는 가정으로 넣어줘야한다. 나의 github repository가 &#39;nuxt-test&#39;이면 &#39;nuxt-test&#39;를 넣으면 된다.  env : baseUrl는 기본으로 사용될 Url을 기입한다. 즉 개발은 http://localhost:port에서 했어도 배포시 github repository의 이름이 경로에 추가되기 때문에 src경로들의 추적이 안될 수 있다.추가적으로, 하나의 특정 리포지토리에 대한 GitHub 페이지를 생성하고 사용자 지정 도메인이 없는 경우 페이지의 URL은 다음 형식이 된다.http://&amp;lt;username&amp;gt;.github.io/&amp;lt;repository-name&amp;gt;.export default {  target: &#39;static&#39;, // 정적 웹사이트임을 명시 default is &#39;server&#39;  router: {    base: &#39;/&amp;lt;repository-name&amp;gt;/&#39; // github repository name  },  env: {    baseUrl: process.env.BASE_URL || &#39;http://domain/&amp;lt;repository-name&amp;gt;/&#39;  },}나의 repository 이름은 nuxt-test로 생성할 것이므로 아래와 같이 작성한다.export default {  target: &#39;static&#39;, // 정적 웹사이트임을 명시 default is &#39;server&#39;  router: {    base: &#39;/nuxt-test/&#39; // github repository name  },  env: {    baseUrl: process.env.BASE_URL || &#39;http://domain/nuxt-test/&#39;  },}소스코드 빌드 및 배포준비Nuxt.js로 프로젝트를 생성하여 개발을 완료했다면, 이를 정적호스팅에 사용 될 소스코드로 build 해줘야 한다.Nuxt.js는 static용 build를 기능을 제공한다. 이 기능은 모든 경로의 .vue파일을 HTML 파일로 생성하고 정적으로 dist/ 디렉토리에 내보내준다.dist/에 생성된 코드들을 깃허브 페이지같은 정적호스팅에 배포하면 끝이다.package.json의 scripts의 generate 명령어가 정적페이지로 build 해주는 명령어이다.&quot;scripts&quot;: {    &quot;dev&quot;: &quot;nuxt&quot;,    &quot;build&quot;: &quot;nuxt build&quot;,    &quot;start&quot;: &quot;nuxt start&quot;,    &quot;generate&quot;: &quot;nuxt generate&quot;,    &quot;deploy&quot;: &quot;push-dir --dir=dist --branch=gh-pages --cleanup&quot;  },정적 웹 배포 파일 생성$ npm run generate빌드 완료시 dist/ 폴더가 생성되고 하위에 배포 할 정적파일들이 생성된다.github 배포 패키지push-dir은 디렉토리의 내용을 원격 브랜치로 푸시해주는 패키지이다.  디렉토리를 커밋할 필요가없다.  dist/로 빌드된 디렉토리를 gh-pages 브랜치로 push해준다.여기서 가장 중요한건 gh-pages의 이름으로 로컬브랜치를 생성해야 된다는 점이다.그리고 나서 master(main)로 브랜치를 이동하고 명령어를 실행해야한다.npm install push-dir --save-dev설치가 완료되면 package.json에 deploy script를 추가한다.&quot;scripts&quot;: {  &quot;dev&quot;: &quot;nuxt&quot;,  &quot;generate&quot;: &quot;nuxt generate&quot;,  &quot;start&quot;: &quot;nuxt start&quot;,  &quot;deploy&quot;: &quot;push-dir --dir=dist --branch=gh-pages --cleanup&quot;}여기까지 완료했다면 배포준비는 끝났다. 실습을 통해 배포해보자배포 진행하기github repository 생성하기github repository 이름을 nuxt-test으로 생성한다.로컬 저장소 및 gh-pages 브랜치 생성로컬 저장소를 생성한다. 그리고 master 브랜치에 최초로 커밋을 해야 gh-pages 브랜치를 생성할 수 있다.add .로 프로젝트 전체를 추가 및 커밋해준다.$ git init$ git add .$ git commit -m &quot;first commit&quot;gh-pages 브랜치를 생성한다. master 브랜치를 바라보고 있어야 명령어가 수행되므로 gh-pages을 바라보고 있다면 master 브랜치로 checkout한다.$ git branch gh-pages$ git branch -v  gh-pages 9945a81 first commit* master   9945a81 first commit원격 리모트 연결$ git remote add origin https://github.com/s-seongsik/nuxt-test.git$ git remote -vorigin  https://github.com/s-seongsik/nuxt-test.git (fetch)origin  https://github.com/s-seongsik/nuxt-test.git (push)배포(deploy)하기npm run deploy배포가 완료되면 github 원격 저장소에 gh-pages 브랜치가 생성되고 그 안에 빌드한 dist 하위 파일들이 배포된다.github 저장소에서 Settings - Pages 메뉴를 들어가면 github pages에 배포되어 접속이 가능한 것을 확인할 수 있다.여기서 중요한건, Source가 바라보는 브랜치는 gh-pages여야 한다는 점이다. 그래야 도메인으로 올라간다.접속하기GitHub Pages에서 제공하는 호스팅에 접속하면 아래와 같이 잘 배포된 것을 확인할 수 있다."
  },
  
  {
    "title": "[Vue.js] Vue의 핵심 기능인 컴포넌트는 무엇이고 어떻게 사용할까?",
    "url": "/posts/vueJs-05-copy/",
    "categories": "Vue.js",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2022-01-28 00:00:00 +0900",
    





    "snippet": "컴포넌트가 무엇인가?컴포넌트는 Vue의 핵심 기능 중 하나이다.컴포넌트를 어떻게 구성하고 생성하냐에 따라 어플리케이션의 개발속도와 코드 가독성, 그리고 효율성(ex. 재사용성)이 차이가 난다.Vue에서 컴포넌트는 기본 HTML 엘리먼트를 확장하여 재사용 가능한 코드를 모듈화 혹은 캡슐화한 것을 의미한다. 상위 수준에서 컴포넌트는 Vue의 컴파일러에 의해 동작이 추가된 사용자 지정 엘리먼트이다. 경우에 따라 특별한 is 속성으로 확장 된 원시 HTML 엘리먼트로 나타날 수도 있다.Vue 컴포넌트는 Vue 인스턴스이기도 하다. 그러므로 모든 옵션 객체를 사용할 수 있다. (루트에만 사용하는 옵션은 제외) 그리고 같은 라이프사이클 훅을 사용할 수 있다.정리해서, 컴포넌트는 어플리케이션을 만들기 위한 작고 독립적인 블록이며 재사용이 가능하다. 이것들을 잘 조합해서 효율적인 개발을 할 수 있다.컴포넌트 사용방법컴포넌트를 등록하는 방법은 전역등록(Global Registration)과 지역등록(Local Registration)이 있다.Vue-cli 4버전으로 프로젝트를 생성 후 예제를 진행하였다. 해당 내용을 모른다면 [Vue.js] Vue CLI로 프로젝트 생성하기를 참고하기 바란다.프로젝트는 Vue 2버전으로 진행했다. 프로젝트를 생성하면 아래와 같은 구조를 갖게된다.전역등록전역등록이란 전역변수처럼 전역에서 컴포넌트를 사용하기 위한 것이다.components 디렉토리에 GlobalComponents.vue 파일을 생성한다.  &amp;lt;template&amp;gt;    &amp;lt;div&amp;gt; {{ text }}&amp;lt;/div&amp;gt;  &amp;lt;/template&amp;gt;  &amp;lt;script&amp;gt;  export default {      name:&quot;GlobalComponents&quot;,      data: () =&amp;gt; {          return {              text : &quot;전역등록된 컴포넌트 입니다.&quot;          }      }  }  &amp;lt;/script&amp;gt;  &amp;lt;style&amp;gt;  &amp;lt;/style&amp;gt;이제 main.js에 GlobalComponents.vue를 import하여 vue에 등록만 해주면 된다. 왜 main.js에서 등록을 하는지는 webpack에 대해 알아야 된다. 간단하게 말하면 webpack은 js, html, css를 하나로 모아서 빌드할 수 있게 도와주는 도구이다.그렇기 때문에 모든 리소스는 main.js에서 한번에 모아서 빌드하게 된다. (여기서 main.js는 webpack에서 entry 포인트이다.)따라서, 모든 컴포넌트들을 main.js에 import시킨 다음 Vue 인스턴스에 한번에 바인딩 시켜 렌더링하는 것이다.추가로 App.vue는 최상위 컴포넌트라고 보면된다.import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;Vue.config.productionTip = falseimport GlobalComponents from &#39;./components/GlobalComponents.vue&#39;; // GlobalComponents.vue를 importVue.component(GlobalComponents.name, GlobalComponents) // 전역등록new Vue({  render: h =&amp;gt; h(App),}).$mount(&#39;#app&#39;)전역 컴포넌트를 등록하는 방법:  Vue.component(&#39;tagName&#39;, {    // 옵션  })이제 GlobalComponents.vue를 전역에서 사용이 가능하다. 최상위 컴포넌트인 App.vue에서 사용해보자. 컴포넌트를 등록하면 태그 형식으로 사용할 수 있다.Vue에서는 컴포넌트 태그명을 파스칼로 작성하는 것을 권장한다. 그리고 태그를 사용할 때는 소문자로 작성하고 파스칼 구분을 -를 넣어 작성하면 된다.파스칼 : HelloWorld -&amp;gt; 태그 작성 : &amp;lt;hello-world&amp;gt;&amp;lt;/hello-world&amp;gt;태그명 그대로 작성해도 상관없다.&amp;lt;template&amp;gt;  &amp;lt;div id=&quot;app&quot;&amp;gt;    &amp;lt;test&amp;gt;&amp;lt;/test&amp;gt;    &amp;lt;global-components&amp;gt;&amp;lt;/global-components&amp;gt;    &amp;lt;!--  or &amp;lt;GlobalComponents&amp;gt;&amp;lt;/GlobalComponents&amp;gt; --&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;export default {  name: &#39;app&#39;}&amp;lt;/script&amp;gt;이제 npm run serve로 서버를 실행시켜 localhost:8080/를 확인해보면성공적으로 전역등록이 완료된 것을 확인할 수 있다.지역등록Vue 어플리케이션을 개발할 때는 지역등록보다는 전역등록을 사용하는게 보편적이다. 그 이유는 Webpack같은 빌드 시스템을 사용하면 전역등록된 사용하지 않는 모든 컴포넌트가 build에 포함되기 때문이다.components 디렉토리에 LocalComponents.vue 파일을 생성한다.&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name:&quot;LocalComponents&quot;,    data: () =&amp;gt; {        return {            text : &quot;지역등록된 컴포넌트 입니다.&quot;        }    }}&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;전역등록은 Vue 인스턴스에 직접 추가하여 사용했지만, 지역등록은 사용될 곳에 import하여 사용한다.&amp;lt;template&amp;gt;  &amp;lt;div id=&quot;app&quot;&amp;gt;    &amp;lt;local-component&amp;gt;&amp;lt;/local-component&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;  import LocalComponent from &#39;./components/local-component&#39;  export default {    name: &#39;app&#39;,    components:{      LocalComponents  }  }&amp;lt;/script&amp;gt;data는 반드시 함수컴포넌트에서 사용하는 data는 반드시 함수여야 한다.아래의 그림을보면, data는 반드시 함수여야 한다고 경고합니다.이런 규칙이 왜 존재하는지 그 이유에 대해 이해하는 것이 중요하다. LocalComponents.vue와 App.vue를 아래와 같이 작성해서 실행시킨다.&amp;lt;template&amp;gt;  &amp;lt;button v-on:click=&quot;count += 1&quot;&amp;gt;{{ count }}&amp;lt;/button&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;var data = {count : 0};export default {    name:&quot;LocalComponents&quot;,    data: function () {    return data  }}&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;&amp;lt;template&amp;gt;  &amp;lt;div id=&quot;app&quot;&amp;gt;    &amp;lt;local-component&amp;gt;&amp;lt;/local-component&amp;gt;    &amp;lt;local-component&amp;gt;&amp;lt;/local-component&amp;gt;    &amp;lt;local-component&amp;gt;&amp;lt;/local-component&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;  import LocalComponent from &#39;./components/local-component&#39;  export default {    name: &#39;app&#39;,    components:{      LocalComponents  }  }&amp;lt;/script&amp;gt;3개의 컴포넌트가 모두 같은 data 객체를 공유하기 때문에 하나의 count를 증가시키면 모두 증가하게 된다.아래와 같이 수정하면 새로운 데이터 객체를 반환하여 독립적으로 사용할 수 있다.data: function () {  return {    count: 0  }}  컴포넌트 작성 방법Vue.js에서 말하는 컴포넌트는 부모-자식 관계에서 가장 일반적으로 함께 사용하기 위한 것이라고 되어있다.말 그대로 tree형식으로 사용할 수 있다는 말이다. 이들은 서로 데이터를 주고 받기 위해 props, events($emit)를 사용한다.Vue.js에서 부모-자식 관계는 아래와 같다.  부모가 자식에게 데이터를 전달할 때 =&amp;gt; props  자식이 부모에게 데이터를 전달할 때 =&amp;gt; events($emit)여기서 LocalComponent.vue은 자식컴포넌트고 App.vue가 부모 컴포넌트이다&amp;lt;template&amp;gt;  &amp;lt;div id=&quot;app&quot;&amp;gt;    &amp;lt;local-components :message=&quot;parent_msg&quot; @child-event=&quot;check&quot;&amp;gt;&amp;lt;/local-components&amp;gt;    &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;  import LocalComponent from &#39;./components/local-component&#39;  export default {    name: &#39;app&#39;,    components:{      LocalComponents    },    data () {      return {        parent_msg: &#39;부모컴포넌트에서 보낸 데이터.&#39;,        chile_msg: &#39;&#39;      }    },    methods: {      check(text) {        this.chile_msg = text;      },    }  }&amp;lt;/script&amp;gt;&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt;    {{ message  }}     &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    &amp;lt;input type=&quot;buttom&quot; @click=&quot;siksik&quot; placeholder=&quot;자식컴포넌트 데이트 받기&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;  export default {    name: &#39;LocalComponents&#39;,    props: [&#39;message&#39;],    methods : {    siksik : function () {      let text = &#39;자식컴포넌트에서 전달한 데이터&#39;;      this.$emit(&quot;child-event&quot;, text);    },  }  }&amp;lt;/script&amp;gt;부모 =&amp;gt; 자식  [App.vue] : 자식 컴포넌트로 보낼 message 데이터 객체를 자식 컴포넌트 속성에 추가한다.  [LocalComponent.vue] : 부모 컴포넌트에서 받을 message 데이터 객체를 props에 정의한다.  [LocalComponent.vue] : 전달받은 message 객체를 이중 중괄호에 바인딩한다.자식 =&amp;gt; 부모  [LocalComponent.vue] : 부모에게 전달할 이벤트 $emit을 작성한다. this.$emit(&quot;child-event&quot;, text);  [LocalComponent.vue] : 버튼 클릭시 child-event라는 메서드 이름으로 text 값을 전달한다.  [App.vue] : &amp;lt;local-components :message=”parent_msg” @child-event=”check”&amp;gt;&amp;lt;/local-components&amp;gt; 에서 자식이 보낸 child-event 이벤트 속성을 추가하고 전달받을 이벤트 check를 명시한다.  [App.vue] : check 이벤트는 자식에게 전달받은 데이터를 chile_msg에 바인딩하여 화면에 보여준다."
  },
  
  {
    "title": "[Git] 개발자들은 Git으로 어떻게 협업할까? 워크플로우 배워보자",
    "url": "/posts/git-05/",
    "categories": "Git",
    "tags": "Git, Github",
    "date": "2022-01-26 00:00:00 +0900",
    





    "snippet": "시작으로먼저, Comparing Workflows의 글에서 자세히 공부할 수 있었다.협업 뿐만아니라 Git에 대해 자세히 정리되어 있으니 참고하길 바란다.글에서 정리한 대표적인 Git 워크플로우는 4가지이다.  Centralized Workflow  Feature Branch Workflow  Gitflow Workflow  Forking Workflow이제 시작해보자~Centralized Workflow중앙 집중식 워크플로우로 SVN과 똑같이 중앙이 되는 메인 저장소를 중심으로 모든 변경 사항에 대해 main 분기에 커밋된다.즉, Subversion을 사용하는 것과 똑같은 방식으로 프로젝트를 개발할 수 있다는 말이다.하지만, SVN에 비해 몇가지 장점이 있다.첫째, 모든 개발자는 로컬 저장소에서 일할 수 있다.로컬 저장소는 완전하게 격리된 공간으로 다른 구성원 및 중앙 저장소에 구애받지 않고 일할 수 있다.둘째, Git의 강력한 분기 및 병합 모델에 대한 엑세스를 제공한다.쉽게 말해, Git 브랜치와 병합 기능으로 안전하게 코드를 변경하고 다른 브랜치에 병합할 수 있다.작동원리  Centralized Workflow는 중앙 저장소를 중심으로 시작한다.  모든 개발자는 중앙 저장소를 복제하여 자기 로컬 저장소에 가져온다.  SVN과 달리 모든 변경 사항의 커밋은 로컬에 저장되며 중앙 저장소와 완전하게 격리되어있다.  개발자는 언제든 편한 중단점에서 중앙 저장소와 동기화할 수 있다.  모든 개발자는 master 브랜치를 사용하고, 모든 변경사항은 이 브랜치에 커밋한다.  중앙 저장소에 변경 사항을 반영하려면 개발자는 로컬 master 브랜치에서 중앙 저장소로 push한다.충돌관리  항상 중앙 저장소의 커밋이력을 기준으로 한다.  개발자의 변경 내용인 로컬 커밋이 중앙 저장소에 push 할 때, 둘의 커밋이력이 다르다면 변경 사항 push를 거부한다.  따라서, 개발자는 먼저 중앙 저장소의 변경 내용을 fetch로 가져와서, 그 위에 변경 사항을 rebase해야 한다. 즉, 다른 사람들이 이미 변경한 작업에 내 변경 사항을 추가할래 이다.  rebase 도중에 중앙 저장소의 변경 내용과 로컬 변경 내용이 충돌난다면, Git은 rebase 를 일시 중지하고 수동으로 해결하라고 한다.  수동으로 해결할 때, git status와 git add로 충돌내용을 확인하고 수정하여 해결한다.예시철수와 영희 2명의 개발자가 Centralized Workflow로 어떻게 협업하는지 직접 해보자."
  },
  
  {
    "title": "[Nuxt.js] 공식문서로 빠르게 배우기 2탄 - 디렉토리 구조 및 구성파일 설정",
    "url": "/posts/nuxtJs-02/",
    "categories": "Nuxt.js",
    "tags": "Nuxt.js, Vue.js, Webpack, Babel, Node.js, Javascript",
    "date": "2022-01-19 00:00:00 +0900",
    





    "snippet": "시작하기Nuxt.js는 Vue.js기반 프레임워크이기 때문에 컴포넌트 구성 및 사용방법은 비슷할 것이라고 생각한다.아래의 목차대로 빠르게 익혀보자.  Nuxt.js의 프로젝트 구조  라우터 방식의 차이  Layout 디렉토리Nuxt.js 프로젝트 구조npm으로 생성한 프로젝트 구조를 살펴보면 아래와 같다.Assets 디렉토리SASS, CSS, IMAGES, Javascript와 같은 컴파일되지 않는 에셋들을 포함하는 디렉토리이다.components 디렉토리Vue.js 컴포넌트를 포함하는 디렉토리이다. Nuxt.js는 이러한 컴포넌트에 데이터 메소드를 크게 신경쓰지 않는다.Layouts 디렉토리디렉토리는 애플리케이션의 레이아웃을 포함하는 디렉토리. 사이드바를 포함하거나 모아빌 및 데스크탑에 대한 고유한 레이아웃(이 디렉토리는 추가 구성 없이는 이름을 바꿀 수 없다.)Pages 디렉토리views와 router가 포합된 디렉토리이다. Nuxt.js는 모든 .vue 파일을 읽고 애플리케이션의 라우터를 생성한다.Static 디렉토리정적 파일들을 포함하는 디렉토리이다. 이 디렉토리 파일들은 /에 연결한다.Store 디렉토리Vuex store 파일을 포함하는 디렉토리이다. Vuex Store는 기본적으로 Nuxt와 함께 제공되지만 기본적으로 비활성 되어있다. index.js을 디렉토리에 만들면 저장소가 자동으로 활성화한다.nuxt.config.jsNuxt.js의 사용자 정의 설정을 포함하는 파일, 모듈을 추가하거나 기본 설정을 무시하려면 변경 사항을 여기에 적용해야 한다.package.json애플리케이션에 대한 모든 종속성과 스크립트를 포함하는 파일이다.vue cli(+3)로 생성한 프로젝트 구조랑 다른점이라면  src 디렉토리 밑에 있던 디렉토리들이 전부 루트레벨로 올라왔다는 점이다.  router, views 디렉토리가 없어지고 pages 디렉토리가 이 두 가지 기능을 대체하게 되었다. Nuxt.js는 빌드시 자동으로 pages의 폴더 구조대로 라우터를 생성한다.  layouts 디렉토리가 추가되었다. 이것은 애플리케이션의 레이아웃을 포함하는 디렉토리이다.다만, component, store, assets은 Vue.js프로젝트의 기능은 똑같이 유지된 것으로 확인된다.Nuxt 구성파일 설정Nuxt.js의 기본 구성 파일은 nuxt.config.js 파일로 사용한다. 구성파일에 사용되는 옵션에 대해 알아보자.build이 옵션을 사용하면 빌드를 포함하여 loaders, filenames, webpack, transpilation에 대한 다양한 설정을 구성할 수 있다.The build property위의 공식문서에서 자세한 가이드를 참고하자.css이 옵션을 사용하면 모든 페이지에서 전역으로 사용할 CSS / 모듈 / 라이브러리 파일을 설정할 수 있다.export default {  css: [    // Load a Node.js module directly (here it&#39;s a Sass file)    &#39;bulma&#39;,    // CSS file in the project    &#39;@/assets/css/main.css&#39;,    // SCSS file in the project    &#39;@/assets/css/main.scss&#39;  ]}Nuxt 구성 파일의 css배열에 나열된  CSS/SCSS/Postcss/Less/Stylus/… 파일의 파일 확장자를 생략할 수 있다.export default {  css: [&#39;~/assets/css/main&#39;, &#39;~/assets/css/animations&#39;]}dev이 옵션을 사용하면 Nuxt.js의 development 또는  production 모드를 정의할 수 있다.  유형:Boolean  기본:true이 속성은 nuxt 명령으로 덮어쓴다.  dev는 nuxt에 의해 true값이 강제로 적용된다.  dev는 nuxt build, nuxt start, nuxt generate 명령어로 강제로 false가 된다.module.exports = {  dev: (process.env.NODE_ENV !== &#39;production&#39;)}const { Nuxt, Builder } = require(&#39;nuxt&#39;)const app = require(&#39;express&#39;)()const port = process.env.PORT || 3000// We instantiate Nuxt with the optionsconst config = require(&#39;./nuxt.config.js&#39;)const nuxt = new Nuxt(config)app.use(nuxt.render)// Build only in dev modeif (config.dev) {  new Builder(nuxt).build()}// Listen the serverapp.listen(port, &#39;0.0.0.0&#39;).then(() =&amp;gt; {  console.log(`Server is listening on port: ${port}`)}){  &quot;scripts&quot;: {    &quot;dev&quot;: &quot;node server.js&quot;,    &quot;build&quot;: &quot;nuxt build&quot;,    &quot;start&quot;: &quot;NODE_ENV=production node server.js&quot;  }}위의 예제를 사용하기 위해서는 npm install --save-dev cross-env 명령어가 필요할 것이다. 만약 윈도우에서 개발하지 않는다면 cross-env를 start 스크립트에서 제외하고 NODE_ENV에 설정할 수 있다.env이 옵션을 사용하면 클라이언트 및 서버에서 사용 가능한 환경 변수를 정의 할 수 있다.module.exports = {  env: {    baseUrl: process.env.BASE_URL || &#39;http://localhost:3000&#39;  }}BASE_URL가 정의되어 있다면, baseUrl 프로피티를 만들 수 있으며 baseUrl은 http://localhost:3000과 같다.자신의 baseUrl로 접근할 2가지 방법이 있다.  process.env.baseUrl  context.baseUrl예제의 public token을 제공하기 위해 env 프로퍼티를 사용한다.예제를 사용하기 위해 axios를 사용합니다.import axios from &#39;axios&#39;export default axios.create({  baseURL: process.env.baseUrl})generate이 옵션을 사용하면 애플리케이션에서 Nuxt.js가 HTML 파일로 변환할 모든 동적인 경로에 대한 각각의 파라미터 값을 정의할 수 있다.export default {  generate: {    ...  }}옵션 사용방법은 공식문서를 참고.head이 옵션을 사용하면 애플리케이션의 모든 기본 메타를 정의 할 수 있다.export default {  head: {    titleTemplate: &#39;%s - 서성식&#39;,    title: &#39;타이틀&#39;,    htmlAttrs: {      lang: &#39;ko&#39;    },    meta: [      { charset: &#39;utf-8&#39; },      { name: &#39;viewport&#39;, content: &#39;width=device-width, initial-scale=1&#39; },      { hid: &#39;description&#39;, name: &#39;description&#39;, content: &#39;&#39; },      { name: &#39;format-detection&#39;, content: &#39;telephone=no&#39; }    ],    link: [      { rel: &#39;icon&#39;, type: &#39;image/x-icon&#39;, href: &#39;/favicon.ico&#39; }    ]  }}head에 적용할 수 있는 옵션 목록은 Vue-meta 문서를 참고.loading이 옵션을 사용하면 Nuxt.js를 사용하여 기본적으로 불러올 loading 컴포넌트를 사용자 정의 할 수 있다.진행률 표시줄 비활성화 :export default {  loading: false}진행률 표시줄 사용자 지정 :export default {  loading: {    color: &#39;blue&#39;,    height: &#39;5px&#39;  }}커스텀 로딩 컴포넌트 사용 :            Method      Required      Description                  start()      Required      경로가 변경될 때 호출되며 구성 요소를 표시하는 곳이다.              finish()      Required      라우트가 로드될 대(및 데이터를 가져올 때) 호출되며, 여기에서 구성 요소를 숨긴다.              fail(error)      Optional      경로를 로드할 수 없을 때 호출된다(예: 데이터 가져오기 실패).              increase(num)      Optional      경로 구성 요소를 로드하는 동안 호출 num되며 Integer &amp;lt; 100      &amp;lt;template lang=&quot;html&quot;&amp;gt;  &amp;lt;div class=&quot;loading-page&quot; v-if=&quot;loading&quot;&amp;gt;    &amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;  export default {    data: () =&amp;gt; ({      loading: false    }),    methods: {      start() {        this.loading = true      },      finish() {        this.loading = false      }    }  }&amp;lt;/script&amp;gt;&amp;lt;style scoped&amp;gt;  .loading-page {    position: fixed;    top: 0;    left: 0;    width: 100%;    height: 100%;    background: rgba(255, 255, 255, 0.8);    text-align: center;    padding-top: 200px;    font-size: 30px;    font-family: sans-serif;  }&amp;lt;/style&amp;gt;export default {  loading: &#39;~/components/loading.vue&#39;}modules모듈은 핵심 기능을 확장하고 끝없는 통합을 추가할 수 있는 Nuxt 확장이다.export default {  modules: [    // Using package name    &#39;@nuxtjs/axios&#39;,    // Relative to your project srcDir    &#39;~/modules/awesome.js&#39;,    // Providing options    [&#39;@nuxtjs/google-analytics&#39;, { ua: &#39;X1234567&#39; }],    // Inline definition    function () {}  ]}  모듈은 순차적으로 실행되므로 순서가 중요하다.  모듈에 의해 주입된 모든 플러그인 은 플러그인 목록 의 시작 부분 에 추가된다.  다른 모듈에 의존하는 경우 모듈의 순서를 반대로 작성한다.modulesDirmoduleDir 속성은 경로 해석을 위한 모듈 디렉토리를 설정하는 데 사용된다.즉, Nuxt 애플리케이션의 모듈 디렉토리를 정의하는데 사용export default {  modulesDir: [&#39;../../node_modules&#39;]}plugins이 옵션을 사용하면 루트 vue.js 어플리케이션을 인스턴스화 하기 전에 실행할 Javascript 플러그인을 정의 할 수 있다.plugins 속성을 사용하면 Vue.js 플러그인을 기본 애플리케이션에 쉽게 추가할 수 있다.export default {  plugins: [    { src: &#39;~/plugins/both-sides.js&#39; },    { src: &#39;~/plugins/client-only.js&#39;, mode: &#39;client&#39; },    { src: &#39;~/plugins/server-only.js&#39;, mode: &#39;server&#39; }  ]}export default {  plugins: [&#39;@/plugins/ant-design-vue&#39;]}import Vue from &#39;vue&#39;import Antd from &#39;ant-design-vue&#39;import &#39;ant-design-vue/dist/antd.css&#39; // Per Ant Design&#39;s docsVue.use(Antd)routerrouter 옵션을 사용하면 Vue 라우터의 기본 Nuxt 구성을 덮어쓸 수 있다.즉, Nuxt 라우터를 사용자 지정할 수 있다.공식 문서 참고server이 옵션을 사용하면 Nuxt 애플리케이션의 서버 인스턴스에 대한 연결 변수를 구성할 수 있다.기본 사용 :export default {  server: {    port: 8000, // default: 3000    host: &#39;0.0.0.0&#39;, // default: localhost,    timing: false  }}HTTPS 구성 사용 :import path from &#39;path&#39;import fs from &#39;fs&#39;export default {  server: {    https: {      key: fs.readFileSync(path.resolve(__dirname, &#39;server.key&#39;)),      cert: fs.readFileSync(path.resolve(__dirname, &#39;server.crt&#39;))    }  }}소켓 구성사용 :export default {  server: {    socket: &#39;/tmp/nuxt.socket&#39;  }}타이밍 :옵션을 활성화하면 server.timing서버 측 렌더링 동안 경과된 시간을 측정하는 미들웨어가 추가되고 헤더에 &#39;Server-Timing&#39;으로 추가된다.export default {  server: {    timing: {      total: true    }  }}srcDir이 옵션을 사용하면 nuxt.js 어플리케이션의 src 디렉토리를 정의 할 수 있다.export default {  srcDir: &#39;src/&#39;}src디렉토리에 Nuxt 애플리케이션이 있는 프로젝트 구조 예시**-| app/---| node_modules/---| nuxt.config.js---| package.json---| client/------| assets/------| components/------| layouts/------| middleware/------| pages/------| plugins/------| static/------| store/**dir이 옵션을 사용하면 Nuxt 디렉토리의 사용자 정의 이름을 정의할 수 있다.export default {  dir: {    assets: &#39;custom-assets&#39;,    app: &#39;custom-app&#39;,    layouts: &#39;custom-layouts&#39;,    middleware: &#39;custom-middleware&#39;,    pages: &#39;custom-pages&#39;,    static: &#39;custom-static&#39;,    store: &#39;custom-store&#39;  }}Transition이 옵션을 사용하면 페이지 전환의 기본 속성을 정의할 수 있다.pageTransition 속성 :페이지 전환의 기본 속성을 설정하는 데 사용한다.export default {  pageTransition: &#39;page&#39;  // or  pageTransition: {    name: &#39;page&#39;,    mode: &#39;out-in&#39;,    beforeEnter (el) {      console.log(&#39;Before enter...&#39;);    }  }}layoutTransition 속성 :레이아웃 전환의 기본 속성을 설정하는 데 사용됩니다. name 옵션에 제공된 값은 layouts 폴더의 layout에 제공된 이름과 함께 작동하도록 구성됩니다.export default {  layoutTransition: &#39;layout&#39;  // or  layoutTransition: {    name: &#39;layout&#39;,    mode: &#39;out-in&#39;  }}"
  },
  
  {
    "title": "[Nuxt.js] 공식문서로 빠르게 배우기 1탄 - 시작하기",
    "url": "/posts/nuxtJs-01/",
    "categories": "Nuxt.js",
    "tags": "Nuxt.js, Vue.js, Webpack, Babel, Node.js, Javascript",
    "date": "2022-01-19 00:00:00 +0900",
    





    "snippet": "시작하기Vue.js로 프로젝트를 진행하면서 SSR 웹 페이지를 만들 수 있도록 도와주는 Nuxt.js를 배워보고 싶다는 생각이 들었다. 설명과 이론을 최대한 배제하고 실무용으로 설치부터 배포까지 빠르게 익히기 위한 포스팅이다. 깃허브 정적 호스팅 서비스에 배포 할 Resume 정적 웹사이트를 만들어 보면서 빠르게 익혀보도록 하자.Nuxt.js 사용하기 위한 전제 조건  node.js 최신 LTS 버전을 설치하는 것을 권장한다.  텍스트 편집기, Vetur 확장 기능이 있는 VSCode 또는 WebStorm 편집기를 사용하는 것을 권장한다.  터미널은 VSCode의 통합 터미널, WebStorm 터미널 사용을 권장한다.  npm(v6.1+)을 설치했는지 확인참고로 npm기반으로 프로젝트를 진행한다.설치 방법수동설치도 있지만, 명령어를 통해 설치하는 것을 권장한다.create-nuxt-app 명령어로 설치npm init nuxt-app@latest &amp;lt;my-project&amp;gt;몇 가지 대화형으로 질문을 묻는다. create-nuxt-app 설명서를 참고한다.정적 호스팅(깃허브)에 정적 웹 페이지를 만들 것이기 때문에 아래와 같이 선택한다.1. Package manager  Npm2. Programming language  JavaScript3. UI framework(UI 프레임워크)  Vuetify4. Nuxt.js modules  Axios - Promise based HTTP client5. Linting tools  ESLint6. Testing framework  None7. Rendering mode(렌더링 모드)  Universal (SSR / Static)8. Deployment target(배포 대상)  Static (Static/JAMStack hosting)9. Development tools(개발도구)  jsconfig.json10. What is your GitHub username(깃허브 아이디)  s-seongsik11. Version control System(버전관리)  Git프로젝트 시작하기package.json에 다음과 같은 명령어가 있어야 한다.&quot;scripts&quot;: {    &quot;dev&quot;: &quot;nuxt&quot;,    &quot;build&quot;: &quot;nuxt build&quot;,    &quot;start&quot;: &quot;nuxt start&quot;,    &quot;generate&quot;: &quot;nuxt generate&quot;}대상: server  nuxt dev - 개발 서버를 시작  nuxt build - 프로덕션용 웹팩으로 애플리케이션을 빌드하고 최적화  nuxt start - 프로덕션 서버를 시작한다. (실행 후 nuxt build) Heroku, Digital Ocean 등과 같은 Node.js 호스팅에 사용대상: static  nuxt dev - 개발 서버를 시작  nuxt generate - 애플리케이션을 빌드하고(필요한 경우) 모든 경로를 HTML 파일로 생성하고 정적으로 dist/ 디렉토리로 내보낸다. (정적 호스팅에 사용)  nuxt start - dist/ 정적 호스팅 방식과 같은 디렉토리를 제공하여 배포 전 테스트에 적합npm run dev아래와 같은 화면이 뜨면 정상적으로 프로젝트가 생성된 것이다."
  },
  
  {
    "title": "[Web] 서버 인증방식 Cookie, Session, Token",
    "url": "/posts/web-Autorization/",
    "categories": "Web",
    "tags": "Web, Cookie, Session, Token",
    "date": "2022-01-19 00:00:00 +0900",
    





    "snippet": "이번에node.js기반 Vue.js로 웹 프론트엔드 개발을 맡게 되었는데 로그인 기능을 구현하면서 혼동되는 세션, 쿠키, 토큰의 개념을 정확하게 짚고 넘어가고 싶었다.서버 인증이 필요한 이유현재 앱/웹 서비스에서 가장 많이 쓰이는 통신 방식은 HTTP이다. 클라이언트는 서버에게 GET, POST, PUT, DELETE 방식 중 하나로 요청을 보내게되고 요청 받은 자원에 대해 응답을 하게 된다. 그런데 여기서 문제는 통신에 대한 기록이 남지 않는다는 것이다. 즉, 서버는 사용자가 누군지 모른다.그 이유는 HTTP는 무상태 프로토콜(Stateless Protocol)이기 때문이다.무상태 프로토콜을 간단하게 말하면 통신 파트너에 대한 세션 정보나 상태 보관을 요구(저장)하지 않는다는 것이다.인증이 필요없는 웹/앱이라면 상관없지만 사용자 정보에 따라 컨텐츠를 제공하거나 달라져야하는 경우에는 서버는 사용자가 누군지 알아야한다.따라서, 사용자 정보를 알릴 수 있는 방법이 세션, 쿠키, 토큰 이다.쿠키(Cookie)란  클라이언트 로컬에 key-value 형태로 저장되어있는 파일이다.  클라이언트 상태 정보를 브라우저에 저장하여 참조한다.  이름, 값, 유효 시간, 경로 등을 포함하고 있다.구성요소 :  쿠키의 이름  쿠키의 값  쿠키의 유효시간  쿠키를 전송할 도메인 이름  쿠키를 전송할 경로  보안 연결 여부  HttpOnly 여부특징 :  쿠키 시간을 지정할 수 있다  브라우저가 종료되어도 유지된다  최대 저장할 수 있는 쿠키는 300개, 도메인당 20개, 쿠키 하나당 4096bytes(4Kb) 이  요청 시 자동으로 헤더에 넣어서 보냄  응답 헤더에 Set-Cookie 속성을 사용하면 쿠키를 생성할 수 있다동작방식이미지 출처 : https://interconnection.tistory.com/74  클라이언트가 서버에 요청을 보낸다.  상태를 유지하고 싶은 정보를 쿠키로 생성한다. (Set-Cookie)  전달받은 쿠키는 브라우저 로컬에 저장/관리하고 있다가, 다음 요청 때 쿠키를 헤더에 넣어서 보낸다.  서버는 쿠키 정보를 받아 이전 상태 정보를 확인하여 응답한다.쿠키 사용 예시  아이디/비밀번호 저장  쇼핑몰 장바구니세션(Session)이란  일정 시간 동안 같은 브라우저로 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.  웹 브라우저를 통해 서버에 접속한 이후부터 종료하는 시점까지 유지되는 상태이다.  세션도 쿠키를 사용하여 key-value을 주고 받으며 통신한다.동작방식이미지 출처: https://doooyeon.github.io/2018/09/10/cookie-and-session.html  클라이언트가 서버에 요청  서버는 요청한 클라이언트에게 유일한 세션ID를 부여한다.  서버는 응답 헤더(Set-Cookie)에 세션ID를 넣어서 전송한다.  클라이언트는 이후 웹 브라우저를 종료하기 전까지 다음 요청부터는 부여된 세션ID를 요청헤더에 넣어서 전송한다.  서버는 세션ID를 확인하고, 해당 세션에 대한 정보를 확인하여 응답한다.세션 사용 예시  로그인쿠키(Cookie) vs 세션(Session)저장위치 :  쿠키 : 클라이언트(브라우저)  세션 : 서버보안 :  쿠키 : 클라이언트에 저장되므로 보안에 취약  세션 : 쿠키를 이용해 Session ID만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다.라이프사이클  쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.  세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.속도  쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다.  세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.세션(Session)의 한계참고 블로그 : [Web]쿠키, 세션 그리고 토큰참고 블로그 : [인증/인가]Session(세션)과 Token(토큰)(JWT)의 차이점한계 1: 안정성세션은 서버에서 저장/관리하기 때문에 상대적으로 온전한 상태를 유지하기 유리하다.하지만 공격에 대한 취약점이 존재하기 때문에 유효기간, HttpOnly, Secure 옵션 등을 주어 쿠키에 저장한다.토큰은 반대로 웹 브라우저(로컬스토리지, 쿠키 등)에 저장되기 때문에 공격에 노출될 가능성이 더 크다.이를 대비해 토큰은 민감한 정보를 담지 않는다. 그리고 유효기간도 짧게 설정하여 공격에 대한 노출시간을 최소화한다.하지만 짧은 유효기간으로 토큰이 무효화되면 사용자는 계속해서 토큰을 요청해야하는 번거로움이 있기 때문에 애초에 로그인(인증)시 refresh token이라는 것을 추가적으로 발급한다.refresh token은 좀 더 긴 유효기간을 가졌으며 최대한 안전한 곳에 저장된다.기존 토큰이 만료되거나 변질되면 refresh token을 통해 재발급한다.한계 2: 저장소 부하세션은 서버에 저장하기 때문에 클라이언트가 많으면 많을수록 많은 세션정보를 서버에서 감당해야 한다.세션 전용 서버를 만들어 DB에 저장해도 DB를 부하시키는 건 똑같다.한계 3 : 확장성한계 2의 문제를 해결하기 위해 서버를 여러 대를 뒀다고 가정해보자.서버가 스케일아웃되서 여러 개가 생기면 각 서버마다 세션 정보를 저장하게 된다.이렇게 되면 세션정보가 없는 다른 서버에 접속할 때마다 계속 로그인해줘야 한다.한계 4 : 웹/앱 간 상이한 세션 처리 로직모바일이 나오기 전에는 클라이언트는 웹이 유일했다. 하지만 모바일이 생기면서 앱이 생겼고 이를 처리하는 경우도 생각해야한다.웹과 앱의 쿠키 처리 방법이 다르고, 만약에 다른 클라이언트가 생긴다면 이에 맞는 처리 로직을 또 생각해야한다.Token의 등장세션의 한게를 해결하기 위해 등장한게 Token 방식이다.토큰은 서버에 상태를 저장하지 않으며 토큰 자체로 정보를 담고있기 때문에 별도의 인증서버를 둘 필요가 없다. 따라서 요청 받을 서버 자체에서 인증 프로세스를 수행할 수 있다.또한 토큰은 Json 포맷으로 통신하기 때문에 어떤 클라이언트(웹/앱)에서 통신을 보내도 Json 포맷만 맞춰서 이용하면 토큰을 사용할 수 있다.토큰은 세션과 달리 유효시간을 짧게 설정하여 공격에 노출되는 시간을 최소화 한다고 설명했다. 그리고 민감한 정보는 담지 않기 때문에 세션보다 비교적 안전하다유효시간이 끝나면 새로운 Access Token을 발급받는 방식을 사용한다.[Access Token] VS [Refresh Token]Access Token(JWT)는 제 3자에게 탈취당할 경우 보안에 취약하다는 단점이 있다. 이를 해결하기 위해 Access Token의 유효기간을 짧게 설정하는데 사용자는 만료될 때마다 로그인을 해서 Token을 재발급 해야하는 번거로움이 있다.그래서 등장한게 Refresh Token이다.Refresh Token은 Access Token와 같은 JWT이지만 처음 로그인을 완료 했을 때 Access Token과 동시에 발급된다.Refresh Token은 긴 유효기간을 가지면서 Access Token가 만료 됐을 대 재발급해주는 열쇠 역할을 한다.예를 들어, Access Token은 유효기간이 30분, Refresh Token은 유효기간이 2주라고 가정하고, 사용자는 로그인을 하고 Access Token과 Refresh Token을 받는다.클라이언트는 Refresh Token을 안전한 곳(Local Storage?) 에 저장하고, API 요청은 Access Token을 가지고 할 수 있다.30분이 지나 토큰이 만료되면 Refresh Token을 서버에 보냄으로써 새로운 Access Token을 발급받을 수 있게 되고, 발급받은 Access Token으로 다시 API요청을 할 수 있게 된다. 출처 : Token 인증 방식이란?"
  },
  
  {
    "title": "[Vue.js] Vue의 핵심 기능인 컴포넌트는 무엇이고 어떻게 사용할까?",
    "url": "/posts/vueJs-05/",
    "categories": "Vue.js",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2022-01-18 00:00:00 +0900",
    





    "snippet": "컴포넌트가 무엇인가?컴포넌트는 Vue의 핵심 기능 중 하나이다.컴포넌트를 어떻게 구성하고 생성하냐에 따라 어플리케이션의 개발속도와 코드 가독성, 그리고 효율성(ex. 재사용성)이 차이가 난다.Vue에서 컴포넌트는 기본 HTML 엘리먼트를 확장하여 재사용 가능한 코드를 모듈화 혹은 캡슐화한 것을 의미한다. 상위 수준에서 컴포넌트는 Vue의 컴파일러에 의해 동작이 추가된 사용자 지정 엘리먼트이다. 경우에 따라 특별한 is 속성으로 확장 된 원시 HTML 엘리먼트로 나타날 수도 있다.Vue 컴포넌트는 Vue 인스턴스이기도 하다. 그러므로 모든 옵션 객체를 사용할 수 있다. (루트에만 사용하는 옵션은 제외) 그리고 같은 라이프사이클 훅을 사용할 수 있다.정리해서, 컴포넌트는 어플리케이션을 만들기 위한 작고 독립적인 블록이며 재사용이 가능하다. 이것들을 잘 조합해서 효율적인 개발을 할 수 있다.컴포넌트 사용방법컴포넌트를 등록하는 방법은 전역등록(Global Registration)과 지역등록(Local Registration)이 있다.Vue-cli 4버전으로 프로젝트를 생성 후 예제를 진행하였다. 해당 내용을 모른다면 [Vue.js] Vue CLI로 프로젝트 생성하기를 참고하기 바란다.프로젝트는 Vue 2버전으로 진행했다. 프로젝트를 생성하면 아래와 같은 구조를 갖게된다.전역등록전역등록이란 전역변수처럼 전역에서 컴포넌트를 사용하기 위한 것이다.components 디렉토리에 GlobalComponents.vue 파일을 생성한다.  &amp;lt;template&amp;gt;    &amp;lt;div&amp;gt; {{ text }}&amp;lt;/div&amp;gt;  &amp;lt;/template&amp;gt;  &amp;lt;script&amp;gt;  export default {      name:&quot;GlobalComponents&quot;,      data: () =&amp;gt; {          return {              text : &quot;전역등록된 컴포넌트 입니다.&quot;          }      }  }  &amp;lt;/script&amp;gt;  &amp;lt;style&amp;gt;  &amp;lt;/style&amp;gt;이제 main.js에 GlobalComponents.vue를 import하여 vue에 등록만 해주면 된다. 왜 main.js에서 등록을 하는지는 webpack에 대해 알아야 된다. 간단하게 말하면 webpack은 js, html, css를 하나로 모아서 빌드할 수 있게 도와주는 도구이다.그렇기 때문에 모든 리소스는 main.js에서 한번에 모아서 빌드하게 된다. (여기서 main.js는 webpack에서 entry 포인트이다.)따라서, 모든 컴포넌트들을 main.js에 import시킨 다음 Vue 인스턴스에 한번에 바인딩 시켜 렌더링하는 것이다.추가로 App.vue는 최상위 컴포넌트라고 보면된다.import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;Vue.config.productionTip = falseimport GlobalComponents from &#39;./components/GlobalComponents.vue&#39;; // GlobalComponents.vue를 importVue.component(GlobalComponents.name, GlobalComponents) // 전역등록new Vue({  render: h =&amp;gt; h(App),}).$mount(&#39;#app&#39;)전역 컴포넌트를 등록하는 방법:  Vue.component(&#39;tagName&#39;, {    // 옵션  })이제 GlobalComponents.vue를 전역에서 사용이 가능하다. 최상위 컴포넌트인 App.vue에서 사용해보자. 컴포넌트를 등록하면 태그 형식으로 사용할 수 있다.Vue에서는 컴포넌트 태그명을 파스칼로 작성하는 것을 권장한다. 그리고 태그를 사용할 때는 소문자로 작성하고 파스칼 구분을 -를 넣어 작성하면 된다.파스칼 : HelloWorld -&amp;gt; 태그 작성 : &amp;lt;hello-world&amp;gt;&amp;lt;/hello-world&amp;gt;태그명 그대로 작성해도 상관없다.&amp;lt;template&amp;gt;  &amp;lt;div id=&quot;app&quot;&amp;gt;    &amp;lt;test&amp;gt;&amp;lt;/test&amp;gt;    &amp;lt;global-components&amp;gt;&amp;lt;/global-components&amp;gt;    &amp;lt;!--  or &amp;lt;GlobalComponents&amp;gt;&amp;lt;/GlobalComponents&amp;gt; --&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;export default {  name: &#39;app&#39;}&amp;lt;/script&amp;gt;이제 npm run serve로 서버를 실행시켜 localhost:8080/를 확인해보면성공적으로 전역등록이 완료된 것을 확인할 수 있다.지역등록Vue 어플리케이션을 개발할 때는 지역등록보다는 전역등록을 사용하는게 보편적이다. 그 이유는 Webpack같은 빌드 시스템을 사용하면 전역등록된 사용하지 않는 모든 컴포넌트가 build에 포함되기 때문이다.components 디렉토리에 LocalComponents.vue 파일을 생성한다.&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name:&quot;LocalComponents&quot;,    data: () =&amp;gt; {        return {            text : &quot;지역등록된 컴포넌트 입니다.&quot;        }    }}&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;전역등록은 Vue 인스턴스에 직접 추가하여 사용했지만, 지역등록은 사용될 곳에 import하여 사용한다.&amp;lt;template&amp;gt;  &amp;lt;div id=&quot;app&quot;&amp;gt;    &amp;lt;local-component&amp;gt;&amp;lt;/local-component&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;  import LocalComponent from &#39;./components/local-component&#39;  export default {    name: &#39;app&#39;,    components:{      LocalComponents  }  }&amp;lt;/script&amp;gt;data는 반드시 함수컴포넌트에서 사용하는 data는 반드시 함수여야 한다.아래의 그림을보면, data는 반드시 함수여야 한다고 경고합니다.이런 규칙이 왜 존재하는지 그 이유에 대해 이해하는 것이 중요하다. LocalComponents.vue와 App.vue를 아래와 같이 작성해서 실행시킨다.&amp;lt;template&amp;gt;  &amp;lt;button v-on:click=&quot;count += 1&quot;&amp;gt;{{ count }}&amp;lt;/button&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;var data = {count : 0};export default {    name:&quot;LocalComponents&quot;,    data: function () {    return data  }}&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;&amp;lt;template&amp;gt;  &amp;lt;div id=&quot;app&quot;&amp;gt;    &amp;lt;local-component&amp;gt;&amp;lt;/local-component&amp;gt;    &amp;lt;local-component&amp;gt;&amp;lt;/local-component&amp;gt;    &amp;lt;local-component&amp;gt;&amp;lt;/local-component&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;  import LocalComponent from &#39;./components/local-component&#39;  export default {    name: &#39;app&#39;,    components:{      LocalComponents  }  }&amp;lt;/script&amp;gt;3개의 컴포넌트가 모두 같은 data 객체를 공유하기 때문에 하나의 count를 증가시키면 모두 증가하게 된다.아래와 같이 수정하면 새로운 데이터 객체를 반환하여 독립적으로 사용할 수 있다.data: function () {  return {    count: 0  }}  컴포넌트 작성 방법Vue.js에서 말하는 컴포넌트는 부모-자식 관계에서 가장 일반적으로 함께 사용하기 위한 것이라고 되어있다.말 그대로 tree형식으로 사용할 수 있다는 말이다. 이들은 서로 데이터를 주고 받기 위해 props, events($emit)를 사용한다.Vue.js에서 부모-자식 관계는 아래와 같다.  부모가 자식에게 데이터를 전달할 때 =&amp;gt; props  자식이 부모에게 데이터를 전달할 때 =&amp;gt; events($emit)여기서 LocalComponent.vue은 자식컴포넌트고 App.vue가 부모 컴포넌트이다&amp;lt;template&amp;gt;  &amp;lt;div id=&quot;app&quot;&amp;gt;    &amp;lt;local-components :message=&quot;parent_msg&quot; @child-event=&quot;check&quot;&amp;gt;&amp;lt;/local-components&amp;gt;    &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;  import LocalComponent from &#39;./components/local-component&#39;  export default {    name: &#39;app&#39;,    components:{      LocalComponents    },    data () {      return {        parent_msg: &#39;부모컴포넌트에서 보낸 데이터.&#39;,        chile_msg: &#39;&#39;      }    },    methods: {      check(text) {        this.chile_msg = text;      },    }  }&amp;lt;/script&amp;gt;&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt;    {{ message  }}     &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    &amp;lt;input type=&quot;buttom&quot; @click=&quot;siksik&quot; placeholder=&quot;자식컴포넌트 데이트 받기&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;  export default {    name: &#39;LocalComponents&#39;,    props: [&#39;message&#39;],    methods : {    siksik : function () {      let text = &#39;자식컴포넌트에서 전달한 데이터&#39;;      this.$emit(&quot;child-event&quot;, text);    },  }  }&amp;lt;/script&amp;gt;부모 =&amp;gt; 자식  [App.vue] : 자식 컴포넌트로 보낼 message 데이터 객체를 자식 컴포넌트 속성에 추가한다.  [LocalComponent.vue] : 부모 컴포넌트에서 받을 message 데이터 객체를 props에 정의한다.  [LocalComponent.vue] : 전달받은 message 객체를 이중 중괄호에 바인딩한다.자식 =&amp;gt; 부모  [LocalComponent.vue] : 부모에게 전달할 이벤트 $emit을 작성한다. this.$emit(&quot;child-event&quot;, text);  [LocalComponent.vue] : 버튼 클릭시 child-event라는 메서드 이름으로 text 값을 전달한다.  [App.vue] : &amp;lt;local-components :message=”parent_msg” @child-event=”check”&amp;gt;&amp;lt;/local-components&amp;gt; 에서 자식이 보낸 child-event 이벤트 속성을 추가하고 전달받을 이벤트 check를 명시한다.  [App.vue] : check 이벤트는 자식에게 전달받은 데이터를 chile_msg에 바인딩하여 화면에 보여준다."
  },
  
  {
    "title": "[Vue.js] Vue.js 문법 총정리",
    "url": "/posts/vueJs-04/",
    "categories": "Vue.js",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2022-01-14 00:00:00 +0900",
    





    "snippet": "Vue 인스턴스Vue 인스턴스에서 보면 알듯이 모든 Vue 앱은 Vue 인스턴스를 만드는 것부터 시작한다.인스턴스 안에 options 객체를 전달해야하는데 전체 옵션 목록을 참고하자.var vm = new Vue({    el: &quot;#app&quot;,    data: {        text: &#39;hello world&#39;    },    //...옵션들})데이터 바인딩이중 중괄호이중 중괄호를 사용한 텍스트 보간이다. data 객체의 msg속성 값으로 대체된다. msg의 속성 값이 변경될 때 마다 갱신된다.보간법은 속성값을 텍스트로 출력한다.&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt;      &amp;lt;p&amp;gt;&amp;gt; 메시지: {{ msg }} &amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: () =&amp;gt; {        return {            msg: &quot;이것은 보간법!, 선언적 렌더링입니다.&quot;        }    }}&amp;lt;/script&amp;gt;v-text 디렉티브디렉티브는 v- 접두사가 있는 특수 속성이다. 디렉티브 속성 값은 단일 javascript 표현식이 된다. (v-for는 예외)디렉티브의 역할은 표현식의 값이 변경될 때 사이드이펙트를 반응적으로 DOM에 적용한다는 것이다.v-text 속성은 데이터 객체의 속성값을 텍스트로 출력한다.&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt;      &amp;lt;p v-text=&quot;msg&quot;&amp;gt; &amp;lt;/p&amp;gt;      &amp;lt;p v-text=&quot;html_msg&quot;&amp;gt; &amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: () =&amp;gt; {        return {            msg: &quot;이것은 디렉티브!, v-text 속성을 이용했습니다.&quot;,            html_msg: &quot;&amp;lt;div&amp;gt;이것은 디렉티브!, v-text 속성을 이용했습니다.&amp;lt;/div&amp;gt;&quot;        }    }}&amp;lt;/script&amp;gt;v-html 디렉티브v-text가 텍스트로 출력한다면, v-html는 속성 값을 HTML로 표현된다. 즉, 실제 HTML을 출력하고 싶다면 v-html 디렉티브를 사용해야 한다.&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt;      &amp;lt;p v-text=&quot;msg&quot;&amp;gt; &amp;lt;/p&amp;gt;      &amp;lt;p v-html=&quot;html_msg&quot;&amp;gt; &amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: () =&amp;gt; {        return {            msg: &quot;&amp;lt;div&amp;gt;이것은 디렉티브!, v-text 속성을 이용했습니다.&amp;lt;/div&amp;gt;&quot;,            html_msg: &quot;&amp;lt;div&amp;gt;이것은 디렉티브!, v-text 속성을 이용했습니다.&amp;lt;/div&amp;gt;&quot;        }    }}&amp;lt;/script&amp;gt;v-bind 디렉티브위 속성들과 달리 HTML 태그의 속성을 바인딩하기 위해 사용한다.class, id, href 속성을 예로 작성.&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt;      &amp;lt;a v-bind:href=&quot;Url&quot;&amp;gt;href 속성입니다.&amp;lt;/a&amp;gt;      &amp;lt;p v-bind:class=&quot;Class&quot;&amp;gt;class 속성입니다.&amp;lt;/p&amp;gt;      &amp;lt;p v-bind:id=&quot;Id&quot;&amp;gt;id 속성입니다.&amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: () =&amp;gt; {        return {            Url: &quot;https://www.google.com/&quot;,            Class: &quot;test-class&quot;,            Id: &quot;test-id&quot;,        }    }}&amp;lt;/script&amp;gt;개발자 도구로 확인해보면 class, id, href 속성들이 바인딩 된 것을 확인.v-model 디렉티브  v-model 속성은 입력 Form 요소를 개발할 때 사용하는 속성이다.  v-model 속성은 v-bind와 v-on의 기능의 조합으로 동작한다.  v-model 속성은 입력요소와 구성 요소에 양방향 바인딩을 만든다.  v-model 속성은 &amp;lt;input&amp;gt;, &amp;lt;select&amp;gt;, &amp;lt;textarea&amp;gt;, components에 제한되어 사용한다.&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt;      &amp;lt;input v-model=&quot;model1&quot;&amp;gt;      &amp;lt;p&amp;gt;model1 : {{model1}}&amp;lt;/p&amp;gt;      &amp;lt;textarea v-model=&quot;model2&quot;&amp;gt;&amp;lt;/textarea&amp;gt;      &amp;lt;p&amp;gt;model2 : {{model2}}&amp;lt;/p&amp;gt;      &amp;lt;select v-model=&quot;model3&quot;&amp;gt;        &amp;lt;option&amp;gt;test1&amp;lt;/option&amp;gt;        &amp;lt;option&amp;gt;test2&amp;lt;/option&amp;gt;      &amp;lt;/select&amp;gt;      &amp;lt;p&amp;gt;model3 : {{model3}}&amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: () =&amp;gt; {        return {            model1: &quot;&quot;,            model2: &quot;&quot;,            model3: &quot;&quot;,        }    }}&amp;lt;/script&amp;gt;사용자가 입력한 Form의 데이터가 v-model의 속성 값으로 연결된다. 따라서, HTML 요소와 뷰 인스턴스의 데이터 속성이 양방향으로 바인딩 될 수 있는 것!이벤트 핸들링v-on 디렉티브v-on 속성은 요소에 이벤트 리스너를 연결할 때 사용한다.&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt;      &amp;lt;button v-on:click=&quot;countUp&quot;&amp;gt;count 1증가&amp;lt;/button&amp;gt;      &amp;lt;p&amp;gt;{{ count }}&amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: () =&amp;gt; {        return {            count:0        }    },    methods: {        countUp(){            this.count++;        }    }}&amp;lt;/script&amp;gt;v-on 약어 참고!&amp;lt;!-- 전체 문법 --&amp;gt;&amp;lt;a v-on:click=&quot;doSomething&quot;&amp;gt; ... &amp;lt;/a&amp;gt;&amp;lt;!-- 약어 --&amp;gt;&amp;lt;a @click=&quot;doSomething&quot;&amp;gt; ... &amp;lt;/a&amp;gt;&amp;lt;!-- shorthand with dynamic argument (2.6.0+) --&amp;gt;&amp;lt;a @[event]=&quot;doSomething&quot;&amp;gt; ... &amp;lt;/a&amp;gt;실제로 4회 누른 결과이다.조건 렌더링v-if 디렉티브v-if 속성은 조건에 따라 블록을 렌더링하기 위해 사용한다.블록은 속성의 표현식이 true값을 반환할 때만 렌더링한다.vue1 속성 값이 ture 이므로 렌더링되어 화면에 표시었고, vue2 속성 값은 false이므로 렌더링되지 않는다.&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt;      &amp;lt;p v-if=&quot;vue1&quot;&amp;gt;vue1가 {{ vue1 }}입니다.&amp;lt;/p&amp;gt;      &amp;lt;p v-if=&quot;vue2&quot;&amp;gt;vue2가 {{ vue2 }}입니다.&amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: ()=&amp;gt;{        return {            vue1: true,            vue2: false        }    }}&amp;lt;/script&amp;gt;v-else 디렉티브v-else 속성은 v-if에 대한 else 블록을 나타낼 수 있다.&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt;      &amp;lt;p v-if=&quot;vue1&quot;&amp;gt;vue1가 {{ vue1 }}입니다.&amp;lt;/p&amp;gt;      &amp;lt;p v-if=&quot;vue2&quot;&amp;gt;vue2가 {{ vue2 }}입니다.&amp;lt;/p&amp;gt;      &amp;lt;p v-else&amp;gt;vue2가 {{ vue2 }}입니다.&amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: ()=&amp;gt;{        return {            vue1: true,            vue2: false        }    }}&amp;lt;/script&amp;gt;v-else-if 디렉티브v-else-if 속성은 v-if에 대한 else if 블록역할을 한다. 즉, 다른 조건문을 추가한다.&amp;lt;template&amp;gt;  &amp;lt;div&amp;gt;      &amp;lt;p v-if=&quot;type === &#39;A&#39;&quot;&amp;gt;type : {{ type }}&amp;lt;/p&amp;gt;      &amp;lt;p v-else-if=&quot;type === &#39;B&#39;&quot;&amp;gt;type : {{ type }}&amp;lt;/p&amp;gt;      &amp;lt;p v-else&amp;gt;type : {{ type }}&amp;lt;/p&amp;gt;  &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: ()=&amp;gt;{        return {            type: &#39;B&#39;,        }    }}&amp;lt;/script&amp;gt;재사용 가능한 key 속성Vue는 효율적으로 엘리먼트를 렌더링하기 위해 처음부터 렌더링을 하지않고 재사용한다. 하지만 이는 독립적인 엘리먼트를 사용할 때는 유용하지않다.밑의 예제를 보면 loginType을 변경해도 사용자가 입력한 값은 초기화되지 않는다. 그 이유는 두 조건 모두 같은 요소를 사용하기 때문에 &amp;lt;input&amp;gt;은 대체되지않고 placeholder만 변경된다.&amp;lt;template&amp;gt;    &amp;lt;div&amp;gt;        &amp;lt;div v-if=&quot;loginType === &#39;username&#39;&quot;&amp;gt;            &amp;lt;label&amp;gt;사용자 이름&amp;lt;/label&amp;gt;            &amp;lt;input placeholder=&quot;사용자 이름을 입력하세요&quot;&amp;gt;        &amp;lt;/div&amp;gt;        &amp;lt;div v-else&amp;gt;            &amp;lt;label&amp;gt;이메일&amp;lt;/label&amp;gt;            &amp;lt;input placeholder=&quot;이메일 주소를 입력하세요&quot;&amp;gt;                    &amp;lt;/div&amp;gt;        &amp;lt;button v-on:click=&quot;change&quot;&amp;gt;유형 변경 버튼&amp;lt;/button&amp;gt;    &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: ()=&amp;gt;{        return {            loginType: &quot;username&quot;,        }    },    methods:{        change(){            if(this.loginType===&quot;username&quot;){                this.loginType = &quot;email&quot;;            }else{                this.loginType = &quot;username&quot;;            }        }    }}&amp;lt;/script&amp;gt;따라서, 독립적인 엘리먼트로 사용하기 위해서 key 속성을 사용해야 한다. key 속성은 임의로 유일한 값을 넣어주면된다.&amp;lt;template&amp;gt;    &amp;lt;div&amp;gt;        &amp;lt;div v-if=&quot;loginType === &#39;username&#39;&quot;&amp;gt;            &amp;lt;label&amp;gt;사용자 이름&amp;lt;/label&amp;gt;            &amp;lt;input placeholder=&quot;사용자 이름을 입력하세요&quot; key=&quot;user&quot;&amp;gt;        &amp;lt;/div&amp;gt;        &amp;lt;div v-else&amp;gt;            &amp;lt;label&amp;gt;이메일&amp;lt;/label&amp;gt;            &amp;lt;input placeholder=&quot;이메일 주소를 입력하세요&quot; key=&quot;email&quot;&amp;gt;                    &amp;lt;/div&amp;gt;        &amp;lt;button v-on:click=&quot;change&quot;&amp;gt;유형 변경 버튼&amp;lt;/button&amp;gt;    &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: ()=&amp;gt;{        return {            loginType: &quot;username&quot;,        }    },    methods:{        change(){            if(this.loginType===&quot;username&quot;){                this.loginType = &quot;email&quot;;            }else{                this.loginType = &quot;username&quot;;            }        }    }}&amp;lt;/script&amp;gt;유형 버튼 클릭시 입력한 input값이 초기화된다.반복 렌더링v-for 디렉티브  v-for는 배열을 기반으로 리스트를 렌더링할 때 사용한다.  v-for는 item in items 형태의 문법을 사용한다.  여기서 items는 원본 데이터 배열이고 item은 반복되는 배열 엘리먼트의 별칭이다.  Vue에서 개별 DOM 노드들을 추적하고 기존 엘리먼트를 재사용, 재정렬하기 위해서 v-for의 각 항목들에 고유한 key 속성을 제공해야 한다.  key에 대한 이상적인 값은 각 항목을 식별할 수 있는 고유한 ID이다.  v-bind를 사용하여 동적 값에 바인딩 해야한다.  반복되는 DOM 내용이 단순한 경우나 의도적인 성능 향상을 위해 기본 동작에 의존하지 않는 경우를 제외하면, 가능하면 언제나 v-for에 key를 추가하는 것이 좋다.&amp;lt;template&amp;gt;    &amp;lt;ul&amp;gt;        &amp;lt;li v-for=&quot;(value, index) in items&quot; v-bind:key=&quot;index&quot;&amp;gt;            {{ value }}        &amp;lt;/li&amp;gt;        &amp;lt;br&amp;gt;                &amp;lt;li v-for=&quot;(value, key) in object&quot; v-bind:key=&quot;key&quot;&amp;gt;            {{key}} : {{ value }}        &amp;lt;/li&amp;gt;    &amp;lt;/ul&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;export default {    name: &quot;test&quot;,    data: ()=&amp;gt;{        return {            items : [&quot;바보&quot;, &quot;멍청이&quot;, &quot;똥개&quot;],            object : {&quot;name&quot;:&quot;서성식&quot;,&quot;age&quot; : &quot;30&quot;, &quot;sex&quot; : &quot;male&quot;},                    }    },}&amp;lt;/script&amp;gt;"
  },
  
  {
    "title": "[Vue.js] Vuex의 이해와 컨셉",
    "url": "/posts/vueJs-03/",
    "categories": "Vue.js",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2022-01-14 00:00:00 +0900",
    





    "snippet": "Vuex란 무엇인가?Vuex는 Vue.js 애플리케이션에 대한 상태 관리 패턴 + 라이브러리 이다. 애플리케이션의 모든 컴포넌트에 대한 중앙 집중식 저장소 역할을 하며 예측 가능한 방식으로 상태를 변경할 수 있다. React의 Flux 패턴에 영감을 받았다고 함.Flux 패턴Flux 공식문서  Flux는 Facebook에서 사용하는 아키텍쳐이다. 즉 React에서 사용한다고 보면된다.  단반향 데이터 흐름을 활용해 뷰 컴포넌트를 구성하는 React를 보완하는 역할.  Dispatcher, Stores, Views(React 컴포넌트)의 세 가지 핵심 부분으로 구성되어 있다.  MVC 패턴의 복잡한 데이터 Flow 문제를 해결하는 개발 패턴 - Undirectional data flowFlux 구조와 데이터 흐름Flux의 데이터는 단방향으로 흐른다. 이게 왜 MVC 패턴의 복잡한 데이터 Flow 문제를 해결할 수 있을까?[Flux 데이터 흐름]아래 MVC패턴의 데이터 흐름을 보면 양방향으로 흐른다. View와 Model이 양방향 통신을 하기 때문에 하나의 View의 모듈을 변경하게 되면 이에 연관된 View들도 갱신되고 또 이에 연관된 모델들을 다시 갱신하기 때문에 서로에 종속되어 추척 관리하기가 어렵다. 그렇기 때문에 어플리케이션이 복잡할수록 업데이트 루프도 복잡해진다. [MVC 데이터 흐름]본론으로 다시 돌아와, Flux의 데이터 흐름이 단방향이기 때문에 예측이 굉장히 심플하다. Vue.js에서보면 상위에서 하위로 props가 내려가고, 하위에서 상위로 event가 올라가는 것을 예측할 수 있다.Vuex의 필요성공통의 상태를 여러 컴포넌트가 공유하는 경우에는 어플리케이션을 더 복잡하게 만든다.그 이유는 2가지이다.  여러 뷰는 같은 상태를 의존해야한다.          Vue.js를 해보신 분들은 아시겠지만, 컴포넌트의 개수가 많아지면 많아질수록 중첩된 컴포넌트 간에 데이터 전달이 복잡해진다. 부모 컴포넌트에서 자식 컴포넌트로 계속해서 props를 선언해야 하므로 데이터 전달이 복잡해 지는 것이다.        서로 다른 뷰의 작업은 동일한 상태를 반영해야 할 수 있다.          직접 부모/자식 인스턴스를 참조하거나 이벤트를 통해 상태값을 계속해서 변경 및 동기화로 해결해야하는데 이러한 패턴은 부서지기 쉽고 유지보수가 어려워진다.      이를 해결하기 위해서는 컴포넌트에서 공유된 상태(state)를 추출하고 이를 전역 싱글톤으로 관리해야 된다. 이는 모든 컴포넌트는 트리에 상관없이 상태를 접근할 수 있고 동작을 트리거 할 수 있게 된다.바로!!! Vuex가 모든 컴포넌트가 공유할 수 있는 전역 싱글톤 방식으로 데이터를 관리해준다.Vuex는 단일 객체에 변수를 선언하고 모든 컴포넌트에서 사용할 수 있다.Vuex의 기본기능 3가지  state : 앱을 작동하는 원본 소스, 즉 데이터  view : 상태의 선언적 매핑입니다. 즉 화면에 표시되는 HTML  action : 뷰에서 사용자의 입력에 따라 반응적으로 상태를 변경하는 방법(methods)Vuex의 핵심 컨셉  state: 컴포넌트 간에 공유하는 데이터  getters: state의 변수들을 get하는데 사용  mutations: state의 변수들을 조작한다(변경)  actions: mutations와 유사하지만, actions는 비동기 작업이 포함된다. 또한 actions으로 mutations에 대한 commit을 한다."
  },
  
  {
    "title": "[Vue.js] Vue CLI로 프로젝트 생성하기",
    "url": "/posts/vueJs-02/",
    "categories": "Vue.js",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2022-01-10 00:00:00 +0900",
    





    "snippet": "Vue-CLIVue-CLI는 신속하게 Vue.js 개발환경을 설정할 수 있도록 도와주는 도구이다.기본적으로 초기 프로젝트 세팅을 생성해주기 때문에 프로젝트 구조, Lint, webpack, babel과 같은 도구들의 설정 고민을 덜 수 있다.CLI란  명령 줄 인터페이스(CLI, Command line interface) 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식을 뜻한다.  즉, 작업 명령은 사용자가 컴퓨터 키보드 등을 통해 문자열의 형태로 입력하며, 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다.설치Node 버전 요구 사항  Vue CLI 4.x에는 Node.js 버전 8.9 이상이 필요. (v10+ 권장)이전 버전에 대한 경고  패키지 이름이 vue-cli에서 @vue/cli으로 변경.  만약 이전 버전(vue-cli)을 사용하고 있다면, 이전 버전을 먼저 제거(uninstall)하고 새 버전(@vue/cli)을 설치.  npm install -g @vue/cli  # OR  yarn global add @vue/clivue --version 명령어를 입력했을 때 vue의 version이 나온다면 정상적으로 설치  vue --version  @vue/cli 4.5.15프로젝트 생성  // vue create [프로젝트명]  vue create sample-vue대화형으로 프로젝트 구성을 선택할 수 있다. Manually select features 선택한다. select형식으로 프로젝트를 구성할 수 있다.3) Check the features needed for your project:[x] Choose Vue version[x] Babel[x] TypeScript[ ] Progressive Web App (PWA) Support[x] Router [x] Vuex[x] CSS Pre-processors[x] Linter / Formatter[ ] Unit Testing[ ] E2E Testing4) Choose a version of Vue.js that you want to start the project with[x] 2.x[ ] 3.x (Preview)사용할 Vue.js 버전 선택5) Use class-style component syntax? (y/N)N6) Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? (Y/n)N (TypeScript에 Babel을 같이 사용 여부)7) Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n)Y8) Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default):[x] Sass/SCSS (with dart-sass)[ ] Sass/SCSS (with node-sass)[ ] Less[ ] Stylus9) Pick a linter / formatter config: (Use arrow keys)[ ] ESLint with error prevention only[ ] ESLint + Airbnb config[ ] ESLint + Standard config[x] ESLint + Prettier[ ] TSLint (deprecated)(ESLint와 포맷터를 어떻게 구성할 것인지 물어보는 것)10) Pick additional lint features:[x] Lint on save            // 저장 시 lint 검사[x] Lint and fix on commit  // commit 시 lint 검사11) Where do you prefer placing config for Babel, ESLint, etc.?[x] In dedicated config files[ ] In package.jsonBabel, ESLint, etc. 들을 따로 config 파일을 생성해서 관리할 것인가? 아니면 package.json에 같이 관리할 것인가?관리측면에서 개별적으로 관리하는 것이 좋아보인다.12) Save this as a preset for future projects? (y/N)N생성된 프로젝트로 들어가서 npm run serve로 dev 서버를 실행한다.  // cd [프로젝트명]  E:\\study&amp;gt;cd sample-vue  E:\\study\\sample-vue&amp;gt;npm run serveserve라는 명령어는 Vue-CLI에서 제공하는 명령어가 아니라 package.json 스크립트에 명령어를 설정하여 npm run [명령어]로 구동하는 것입니다.  &quot;scripts&quot;: {    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,    &quot;build&quot;: &quot;vue-cli-service build&quot;,    &quot;lint&quot;: &quot;vue-cli-service lint&quot;  }npx를 사용하여 직접 서버를 구동시킬 수도 있다.  npx vue-cli-service serve서버구동이 완료되고 http://localhost:8080/로 접속하여 아래와 같은 화면이 나온다면 성공이다.프로젝트 구조vue-CLI로 프로젝트를 생성하게 되면 아래와 같은 구조를 갖게 된다. (CLI 버전 3이상)프로젝트  ├─ node_modules/  ├─ public  ├─ src/  ├─ package.json  └─ src    ├─ asstes/    ├─ components/    ├─ router/    ├─ store/    ├─ views/    ├─ App.vue    └─ main.js  ├─ .browserslistrc  ├─ .eslintrc.js  ├─ .gitignore  ├─ babel.config.js  ├─ package-lock.json  ├─ package.json  └─ README.md  node_modules: npm 라이브러리들이 있는 폴더(package.json에 종속되어있는 라이브러리)  public: 빌드시 웹팩 처리를 받지 않고 퍼블리싱되는 정적 자산을 포함하는 폴더이다(static assets)  src: 애플리케이션 디렉토리  src/assets: css, images 등의 정적 assets을 저장하는 폴더  src/components: 컴포넌트를 담는 폴더  src/router: Vue Router 관련 폴더  src/store: Vuex 관련 폴더  src/views: 라우터 페이지 관련 폴더  src/APP.vue: 프로젝트 최상위 컴포넌트 파일  src/main.js: 프로젝트 entry .js 파일  .eslintrc.js: ESLint 설정 파일  babel.config.js: babel 설정 파일  package.json: 프로젝트 패키지관리 파일  package-lock.json: 프로젝트 의존성 트리에 대한 정보를 담은 파일Vue CLI 도구를 사용하여 프로젝트를 생성 및 기본적인 구조에 대해서 알아봤다. 하지만, 프로젝트의 깊은 이해를 바탕으로 개발을 하기위해서는…Vue의 핵심 구성요소를 알아야겠다 다음 포스팅은 Vue의 3대 필수 구성인 Vuex와 Vue CLI, 그리고 Vue Router에 대해 자세히 공부해서 포스팅해야겠다."
  },
  
  {
    "title": "[Vue.js] 사전 필수요소",
    "url": "/posts/vueJs-01/",
    "categories": "Vue.js",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2022-01-10 00:00:00 +0900",
    





    "snippet": "필수 요소Crome 설치Vue는 ECMAScript 5 기능을 사용하기 때문에 IE8 이하 버전을 지원하지 않습니다. 하지만 모든 ECMAScript5 호환 브라우저를 지원합니다.Node.js 설치LTS 버전을 다운로드 합니다.[Node.js] 시작하기를 참고.Vue Devtools(개발자 도구) 설치일반적으로 프론트엔드 개발시 크롬 개발자 도구로 디버깅을 했다면, Vue는 자체적으로 제공하는 개발자 도구를 사용합니다.설치가 완료되었다면, 크롬 브라우저 오른쪽 설정에서도구 더보기 &amp;gt; 확장 프로그램 클릭vue.js devtools &amp;gt; 세부정보 클릭 &amp;gt; 사이트 엑세스 &amp;gt; 모든 사이트에서로 변경VScode 설치무료 IDE 점유율 1위로 가장 많이 쓰이는 툴입니다."
  },
  
  {
    "title": "[ESLint] 포맷팅에 특화된 프리티어(Prettier)",
    "url": "/posts/eslint-03/",
    "categories": "ESLint",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2022-01-06 00:00:00 +0900",
    





    "snippet": "PrettierESLint는 포맷팅과 코드 품질에 도움을 주는 도구라면 프리티어(Prettier)는 포맷팅에만 특화된 도구이다.ESLint에 없는 기능들을 프리티어(Prettier)가 해결해준다.install    npm install -D prettier    var x = &#39;asd&#39;;;;    console.log(&#39;########################################### 80자 넘음 #######################################################&#39;);    module.exports = {        &quot;env&quot;: {            &quot;browser&quot;: true,            &quot;es2021&quot;: true,        },        &quot;extends&quot;: [&quot;eslint:recommended&quot;,&quot;google&quot;],        &quot;parserOptions&quot;: {            &quot;ecmaVersion&quot;: 13,            &quot;sourceType&quot;: &quot;module&quot;        },        &quot;rules&quot;: {        }    };app.js의 코드를 ESLint는 어떻게 처리하는지 확인해보자.    $ npx eslint app.js --fix    E:\\study\\frontend\\eslint_sample\\app.js        1:7  error  &#39;x&#39; is assigned a value but never used                no-unused-vars        3:1  error  This line has a length of 122. Maximum allowed is 80  max-len    ✖ 2 problems (2 errors, 0 warnings)    const x = &#39;asd&#39;;    console.log(&#39;########################################### 80자 넘음 #######################################################&#39;);  var 키워드를 const 키워드로 수정  세미클론 중복을 수정그 외에는 console에 에러 메시지로 출력해준다.Use프리티어(Prettier)를 사용하면 ESLint에는 없는 포맷팅 기능을 처리해준다.    $ npx prettier app.js --write--write 옵션은 파일을 재작성해준다. 넣지않으면 터미널에 출력한다.    var x = &quot;asd&quot;;    console.log(      &quot;########################################### 80자 넘음 #######################################################&quot;    );  작은 따옴표를 큰 따옴표로 수정  max-len규칙을 어떻게 수정해야하는지 알고 있기 때문에 다시 작성ESLint와 통합하기Integrating with Linters매번 ESLint와 프리티어(Prettier)를 개별적으로 사용하면 얼마나 불편할까? 프리티어(Prettier)의 모든 규칙을 ESLint의 규칙으로 설정하는 방법을 설명한다.  프리티어가 ESLint에 없는 포맷팅 기능을 제공한다고는 하지만, 서로 겹치는 기능도 존재한다.  eslint-config-prettier는 프리티어와 ESLint와 겹치는 규칙을 제외시키는 기능을 제공한다.    npm i -D eslint-config-prettierextends에 &quot;eslint-config-prettier&quot;를 추가해준다.    module.exports = {        ...        &quot;extends&quot;: [            &quot;eslint:recommended&quot;,            &quot;eslint-config-prettier&quot;        ]    };  eslint-plugin-prettier는 프리티어의 모든 규칙을 ESLint 규칙으로 추가하는 플러그인이다.  eslint-plugin-prettier를 사용하면 ESLint만 실행해도 프리티어를 같이 사용할 수 있다.    npm i -D eslint-config-prettier아래 객체를 추가한다.    module.exports = {        ...        plugins: [            &quot;prettier&quot;        ],        rules: {            &quot;prettier/prettier&quot;: &quot;error&quot;        },    };이제 ESLint만 실행해도 프리티어가 적용되어 포맷팅이 될 것이다.    $ npx eslint app.js --fixRecommended Configuration  eslint-plugin-prettier 플러그인과 eslint-config-prettier config를 한번에 모두 설정하는 방법  extends에 &quot;plugin:prettier/recommended&quot; 추가    module.exports = {        ...        extends: [&quot;plugin:prettier/recommended&quot;]    };"
  },
  
  {
    "title": "[ESLint] Style-Guide 설정",
    "url": "/posts/eslint-02/",
    "categories": "ESLint",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2022-01-05 00:00:00 +0900",
    





    "snippet": "style-guideESLint는 커스터마이징이 쉽고 확장성이 뛰어나 많이 사용되고 있는 추세이다.또한, ESLint는 개발자들이 커스터마이징한 style-guide 설정들을 외부에 공개하여 공유할 수 있다.가장 널리 쓰고있는 2가지를 소개하자면  Airbnb Style Guide  Google Style Guide서로 제공하는 Style Guide를 참고하여 사용자의 목적에 맞게 사용하면 된다.initnpx eslint --init으로  .eslintrc 파일을 생성한다.    $ npx eslint --init    √ How would you like to use ESLint? · problems    √ What type of modules does your project use? · esm    √ Which framework does your project use? · none    √ Does your project use TypeScript? · No / Yes    √ Where does your code run? · browser    √ What format do you want your config file to be in? · JavaScript    Successfully created .eslintrc.js file in E:\\study\\frontend\\eslint_sample프로젝트 루트에 .eslintrc.js 파일이 생성되었을 것이다. 만약 --init에서 마지막 물음에 대한 답변이 js가 아니라면본인이 설정한 파일 포멧에 맞춰 .eslintrc.*로 생성되었을 것이다. 나는 js를 선택했다.module.exports = {    &quot;env&quot;: {        &quot;browser&quot;: true,        &quot;es2021&quot;: true    },    &quot;extends&quot;: &quot;eslint:recommended&quot;,    &quot;parserOptions&quot;: {        &quot;ecmaVersion&quot;: 13,        &quot;sourceType&quot;: &quot;module&quot;    },    &quot;rules&quot;: {    }};Airbnb Style Guide자세한 설치 가이드 참고install    $ npm install --save-dev eslint-config-airbnb-baseextends에 airbnb-base 추가하기기존 eslint에서 제공하는 eslint:recommended 설정을 지우고  airbnb-base를 추가module.exports = {    &quot;env&quot;: {        &quot;browser&quot;: true,        &quot;es2021&quot;: true    },    &quot;extends&quot;: &quot;airbnb-base&quot;,    &quot;parserOptions&quot;: {        &quot;ecmaVersion&quot;: 13,        &quot;sourceType&quot;: &quot;module&quot;    },    &quot;rules&quot;: {    }};    var x = 30;;;;;;;;;    var y = 20;;;;;;;;;    function test(){console.log(x)}build 결과를 보면 아래의 내용이 적용 된 것을 확인할 수 있다.  var 키워드를 const 키워드로 수정  세미클론 수정  함수의 띄어쓰기 수정이것은 airbnb에서 제공하는 코드작성 스타일가이드가 적용된 것이다.    $ npx eslint app.js --fix     E:\\study\\frontend\\eslint_sample\\app.js        2:7   error    &#39;y&#39; is assigned a value but never used  no-unused-vars        4:10  error    &#39;test&#39; is defined but never used        no-unused-vars        4:19  warning  Unexpected console statement            no-console    ✖ 3 problems (2 errors, 1 warning)    const x = 30;    const y = 20;    function test() { console.log(x); }google Style Guideinstall    $ npm install --save-dev eslint-config-googleextends에 google 추가하기module.exports = {    &quot;env&quot;: {        &quot;browser&quot;: true,        &quot;es2021&quot;: true    },    &quot;extends&quot;: &quot;google&quot;,    &quot;parserOptions&quot;: {        &quot;ecmaVersion&quot;: 13,        &quot;sourceType&quot;: &quot;module&quot;    },    &quot;rules&quot;: {    }};    var x = 30;;;;;;;;;    var y = 20;;;;;;;;;    function test(){console.log(x)}build 결과를 보면 airbnb에서 제공하는 코드작성 스타일가이드와 다르게 google은  세미클론이 없는 경우에는 추가로 작성해주지만 중복 세미클론에 대해서는 없애지않고 띄어쓰기한다.  자바스크립트에서는 중복 세미클론을 한다고 해서 오류가 아니기 때문에 google 스타일 가이드에서는 없애지 않는 것 같다.  또한, 함수에서 들여쓰기로 가독성을 높여준 것을 확인할 수 있다.    $ npx eslint app.js --fix     E:\\study\\frontend\\eslint_sample\\app.js        2:7   error  &#39;y&#39; is assigned a value but never used  no-unused-vars        4:1   error  Missing JSDoc comment                   require-jsdoc        4:10  error  &#39;test&#39; is defined but never used        no-unused-vars    ✖ 3 problems (3 errors, 0 warnings)    const x = 30; ;;;;;;;;    const y = 20; ;;;;;;;;    function test() {        console.log(x);    }"
  },
  
  {
    "title": "[ESLint] ESLint 시작하기",
    "url": "/posts/eslint-01/",
    "categories": "ESLint",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2022-01-05 00:00:00 +0900",
    





    "snippet": "ESLint란?  ESLint란 코딩 컨벤션에 위배되는 코드나 안티 패턴을 자동으로 검출하는 분석 도구이다.  코드를 분석하여 문법적인 오류나 안티 패턴을 찾고 일관된 코드 스타일로 작성할 수 있도록 도와준다.  ESLint는 유용하게 사용할 수 있도록 style-guide를 제공한다.  대표적으로 Airbnb Style Guide, Google Style Guide이 있다.  개발자가 직접 style-guide를 작성할 수도 있다.Install   $ npm install eslint --save-dev   $ mkdir eslint_sample  // 프로젝트 폴더 생성   $ cd eslint_sample/    // 프로젝트 이동   $ npm init             // 프로젝트 생성     // eslint 설치    $ npm install eslint --save-dev 프로젝트 구조    eslint_sample/        ├── node_modules/        ├── package-lock.json        └── package.jsonConfiguration Files환경설정 파일에 대한 자세한 설명은 Configuration File Formats를 참조.ESLint는 여러 형식의 구성 파일을 제공한다.  JavaScript  JavaScript (ESM)  YAML  JSON  package.json프로젝트 최상위 디렉토리에 여러 구성 파일이 있는 경우에는 ESLint는 하나의 구성파일만 사용한다. 그 우선순위는 다음과 같다.  .eslintrc.js  .eslintrc.cjs  .eslintrc.yaml  .eslintrc.yml  .eslintrc.json  package.json  .eslintrc.js를 최상위 디렉토리에 생성합니다.    Configuration Files 작성방법rulesESLint는 검사 규칙을 제공한다. 자세한 내용은 Rules를 참조.그 중 하나인 no-extra-semi를 적용.밑에 disallow unnecessary semicolons라고 되어있다. 즉 불필요한 세미콜론을 허용하지 않겠다는건데 어떻게 적용되는지 확인해보자.규칙을 설정하는 값은 3가지로  “off” or 0 - turn the rule off, 규칙을 끔  “warn” or 1 - turn the rule on as a warning (doesn’t affect exit code), 규칙을 경고로 설정(종료 코드에 영향을 주지 않음)  “error” or 2 - turn the rule on as an error (exit code is 1 when triggered), 규칙을 오류로 설정(트리거될 때 종료 코드는 1)    module.exports = {        rules: {            &quot;no-extra-semi&quot;: &quot;error&quot;,        },    }./app.js 를 생성하여 세미클론을 여러개 작성해본다.    var x = 30;;    console.log(x);;실행해보면 불필요한 세미클론 수 만큼 error 메시지를 출력한다.    $ npx eslint app.js            E:\\study\\frontend\\eslint_sample\\app.js    1:12  error  Unnecessary semicolon  no-extra-semi    3:16  error  Unnecessary semicolon  no-extra-semi    ✖ 2 problems (2 errors, 0 warnings)    2 errors and 0 warnings potentially fixable with the `--fix` option.error 메시지 맨 밑에“2 errors and 0 warnings potentially fixable with the --fix option.” 문구를 보면 --fix 옵션을 줘서 자동으로 수정할 수 있는 옵션이 있다.    $ npx eslint app.js --fix자동으로 세미클론을 수정.    var x = 30;    console.log(x);이번에는 no-unused-vars(사용하지 않는 변수를 허용하지 않음) 규칙을 추가해보자.    module.exports = {        rules: {            &quot;no-extra-semi&quot;: &quot;error&quot;,            &quot;no-unused-vars&quot;: &quot;error&quot;,        },    }    var x = 30;;    var y = 20;    console.log(x);;    $ npx eslint app.js --fix            E:\\study\\frontend\\eslint_sample\\app.js    2:5  error  &#39;y&#39; is assigned a value but never used  no-unused-vars    ✖ 1 problem (1 error, 0 warnings)결과:    var x = 30;    var y = 20;    console.log(x);불필요한 세미클론은 제거가 되었는데 var y = 20;은 수정이 되지 않고 error 메시지만 출력한다. 왜 그럴까?ESLint의 모든 규칙은 --fix가 적용되는 게 아니다.밑의 사진을 보자왼편에 no-extra-semi는 수리 이모티콘이 있고 no-unused-vars는 수리 이모티콘이 없다.즉, 수리 이모티콘이 있는 규칙만 --fix가 적용되기 때문에 개발자는 error 내용을 직접 수정 해야한다.Using [eslint:recommended]사용자가 필요한 규칙들을 일일이 명시하여 사용하는게 얼마나 귀찮은 일인가…따라서, ESLint는 규칙을 유형별로 그룹화하여 제공한다.그것이 eslint:recommended이다. babel의 프리셋이라고 생각하면 된다.이것을 사용하기 위해서는 extends 설정을 추가한다.    module.exports = {        extends: [            &quot;eslint:recommended&quot;,         ],    }rules 적용된 목록을 확인해 보시면 왼편에 체크 이모티콘이 표시된 규칙들이 해당 설정에 적용되어 있다.이외 추가적인 규칙이 필요하면 직접 rules에 추가하면 된다.–initconfiguration file을 구성하는 가장 쉬운 방법은, --init 플래그를 사용하는 것이다.--init을 명령하면 대화식 명령으로 어떻게 구성할 건지 물어보는데, 목적에 맞게 선택하면 된다.    $ npx eslint --init    √ How would you like to use ESLint? · problems    √ What type of modules does your project use? · esm    √ Which framework does your project use? · none    √ Does your project use TypeScript? · No / Yes    √ Where does your code run? · browser    √ What format do you want your config file to be in? · JavaScript    Successfully created .eslintrc.js file in E:\\study\\frontend\\eslint_sample자동으로 생성    module.exports = {        &quot;env&quot;: {            &quot;browser&quot;: true,            &quot;es2021&quot;: true        },        &quot;extends&quot;: &quot;eslint:recommended&quot;,        &quot;parserOptions&quot;: {            &quot;ecmaVersion&quot;: 13,            &quot;sourceType&quot;: &quot;module&quot;        },        &quot;rules&quot;: {        }    };"
  },
  
  {
    "title": "[기록] 나의 첫, 단독 SI프로젝트에서 생긴 문제들과 해결(미완성)",
    "url": "/posts/issue-01/",
    "categories": "Issue",
    "tags": "",
    "date": "2022-01-02 00:00:00 +0900",
    





    "snippet": "인트로2021-01 ~ 2021-099개월간의 대장정의 서사시를 지금에서야 기록하게 된다.본론전에, 나의 첫 번째 SI프로젝트는 만도였다. 6개월 동안 선배들과 상주하였고 동고동락하면서 선배들의 지식과 경험들을 흡수하기위해 노력했다.1년차도 안된 주니어가 큰 프로젝트에 투입할 수 있다는것에 감사함과 행운을 가지고 어떻게 해서든 배워나갔다. 자바스크립트, 제이쿼리, HTML, CSS 등과 같은 기술들 그리고 소통과 협업… 그렇게, 나의 첫 실무경험이 시작되었다.어느덧 6개월이 지나 끝나지않을 것 같았던 대장정이 마무리가 되었고, 다시 본사로 복귀하여 새로운 일거리를 찾아 서성였다.그렇게 시작된 나의 첫 단독 프로젝트PS테크놀로지의 환경안전 모니터링 시스템 프로젝트!!문제 01 - 개발자의 영역이 맞아?현재 근무중인 위즈코어는 스마트팩토리를 전문적으로 구축하는 회사이다. 나는 여기서 웹 기반의 모니터링 시스템을 구축하는 팀에서 일을 하고 있다.중소기업이다보니 팀 단위의 업무환경을 기대하기 힘들다 특히 2021년 상반기까지만해도 일이 밀려 1인당 1개의 프로젝트를 맡아 처리를 했어야 했다.그래서 주니어인 나도 프로젝트를 혼자 맡을 수 있었던 것이었다.밑에 사진을 보면, 나는 모니터링 시스템 섹터를 담당한다.그리고 아주 밑단으로 내려가면 데이터수집영역은 PLC팀이 따로 있다.회사에 PLC 팀이 있지만, 프로젝트를 여러개 맡아서 하다보니 타업체를 끼고 진행하게 되었다.사건의 발단데이터 수집을 하기 위한 준비 단계는 설비 I/F, 센서 I/F이다.모든 I/F가 끝나면 본격적으로 데이터 수집 단계로 들어가게 되는데 데이터 수집의 단계도 3단계로 나뉜다.1.설비데이터, 센서데이터(PLC업체담당)-&amp;gt; 2.MASTER PLC(PLC업체담당) -&amp;gt; Edge device(PLC업체담당) -&amp;gt; 3.Database(나의 담당)간단하게 설명하자면, I/F된 설비와 센서에서 ROW 데이터가 생성되면 MASTER PLC에서 데이터를 모아옵니다.MASTER PLC는 모아온 데이터들을 메모리에 들고만 있을 뿐 DB로 넣어주지 않는다.DB로 넣어주는 역할이 바로 Edge device!, 엣지 디바이스는 마스터 PLC의 데이터를 가져와 DB로 INSERT해준다!DB로 Insert 하는 방법은 크게 2가지로 알고 있다.  직접 Insert  DB 프로시저 호출(현재 사업에서 사용된 방법)자! 이렇게 Database에 데이터가 수집되면 이제부터 시작이다…스마트팩토리 사업에서 가장 중요하면서 동시에 사건의 발단인 데이터 정합성!!DB의 데이터를 가지고 모니터링 시스템을 구축하게 되는데 사용자는 사용하면서 이런말을 자주 내뱉게 된다.데이터가 안맞는데요?우리는 프로시저 호출시 넘겨주는 파라미터 그대로 테이블에 Insert하고 그걸 가공하여 차트로 화면에 보여준다."
  },
  
  {
    "title": "[ECMAScript6] let, const 키워드",
    "url": "/posts/javascript-04/",
    "categories": "Javascript",
    "tags": "Javascript, ES6",
    "date": "2022-01-02 00:00:00 +0900",
    





    "snippet": "ES6(2015) 이전에는 자바스크립트에서 변수를 선언할 수 있는 방법은 var뿐이었습니다.이것은 많은 문제를 발생시켰습니다.  전역 변수로 인한 스코프 충돌          ES6이전에 스코프는 전역 스코프(Global Scope) 와 함수 스코프(Function Scope)만 있었습니다. 자바스크립트는 함수 스코프 외에는 모두 전역 스코프로 적용되기 때문에 전역 변수를 남발하여 스코프 충돌의 문제를 발생시켰습니다.        변수 중복 선언          자바스크립트의 코드양이 많으면 많을 수록 스코프 충돌의 문제를 발생시킵니다. 이미 선언된 변수를 또 재선언을 하거나 다른 값을 넣거나하는 문제를 발생할 수 있습니다.      보통 전역변수로 인해 발생하는 문제로, 이를 해결하고자 ES6(2015)부터는 let과 const Keyword를 도입했습니다.letES6(2015)이전의 자바스크립트는 함수 내에서 선언된 변수 외 모든 코드 블록 내에서 선언된 변수는 전역 스코프(Global Scope)를 갖습니다.Block ScopeES6(2015) 이전  var x = 10;  {      var x = &#39;change&#39;;  }  console.log(x);  changex에 10을 넣었지만, { } 블록 내부에 x를 재선언 되었기 때문에 change로 변경되어 출력되었습니다.ES6(2015) let Keyword  let x = 10;  {    let x = &#39;change&#39;;  }  console.log(x);  10{ } 코드 내부에 선언된 x는 블록 스코프를 따르기 때문에 외부에서 접근할 수 없습니다. 즉 재선언이 안된다는 말이죠.따라서 전역 변수로 선언한 x=10이 출력되는 것을 확인할 수 있습니다.  let x = &#39;Global&#39;; // 전역 변수  {    let x = &#39;x Local&#39;; // 지역 변수    let y = &#39;y Local&#39;; // 지역 변수  }  console.log(x); // Global  console.log(y); // ReferenceError: bar is not defined  Global  Uncaught ReferenceError: y is not defined    at &amp;lt;anonymous&amp;gt;:9:13전역 스코프를 갖는 let x=&#39;Global&#39;는 { } 코드 내부에 선언한 let x = &#39;x Local&#39;로 재선언되지 않으며y는 블록 스코프를 따르기 때문에 외부에서 접근할 수 없기 때문에 console.log시 ReferenceError 오류를 확인할 수 있습니다.재선언 금지var 키워드는 동일한 이름을 갖는 변수를 몇 번이고 재선언을 할 수 있습니다. 하지만 let 키워드는 동일한 이름으로 재선언을 할 수 없습니다.중복 선언하게 되면 문법 에러(SyntaxError)를 발생시킵니다.  var x = 10; // 최초 선언  var x = 20; // 재 선언  let y = 10; // 최초 선언  let y = 20; // 재 선언  console.log(x);  console.log(y);  Uncaught SyntaxError: Identifier &#39;y&#39; has already been declared호이스팅자바스크립트에서 선언된 모든 것(var, let, const, function, class)을 호이스팅이라고 합니다. 호이스팅(Hoisting)이란, var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성을 말한다.예시를 먼저 보겠습니다.  console.log(x);  var x = 30;  undefined변수 x를 선언하기 전에 console.log로 출력을 했는데 x is not defined 오류가 발생하지 않았습니다. 왜 그런지 알아봅시다.변수는 3단계를 걸쳐 생성됩니다.1단계: 선언 단계(Declaration phase)  변수를 실행 컨텍스트의 변수 객체(Variable Object)에 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다.2단계: 초기화 단계(Initialization phase)  변수 객체(Variable Object)에 등록된 변수를 위한 공간을 메모리에 확보한다. 이 단계에서 변수는 undefined로 초기화된다.3단계: 할당 단계(Assignment phase)  undefined로 초기화된 변수에 실제 값을 할당한다.var는 선언 단계와 초기화 단계가 한 번에 실행됩니다. 스코프에 변수를 등록(선언 단계)하여 메모리에 공간을 확보한 뒤,undefined로 초기화(초기화 단계)합니다. 이러한 이유로 변수선언문 이전에 변수에 접근하여도 에러가 발생하지 않고 undefined를 반환한 것입니다.이후 변수에 값을 할당(할당 단계)해야 비로소 값이 할당 되는 것입니다. 이런 현상을 변수 호이스팅(Variable Hoisting)이라 합니다.  // 스코프의 선두에서 선언 단계와 초기화 단게가 한 번에 이루어 집니다.  // 따라서, 변수 선언 이전에 변수에 참조할 수 있습니다.  console.log(x);  // undefined  var x;           // 선언 단계  console.log(x);  // undefined    x = 10;          // 할당 단계  console.log(x);  // 10  undefined  undefined  10let은 선언 단계와 초기화 단계가 분리되어 진행합니다.let은 스코프에 변수를 등록(선언단계)은 하지만 초기화 단계는 변수 선언문에 도달했을 때 실행합니다. 따라서 초기화 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생합니다.그 이유는 초기화 단게가 이루어지지 않았기 때문입니다. 즉, 변수를 담을 메모리 공간이 확보되지 않았기 때문입니다. 정리해서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없습니다. 이 구간을 일시적 사각지대(Temporal Dead Zone; TDZ)라고 부릅니다.  // 스코프의 선두에서 선언 단계가 이루어집니다.  // 변수 초기화 단계는 이루어지지 않았습니다.  // 따라서, 변수 선언 이전에 변수에 참조할 수 없습니다.  console.log(x);  // Uncaught ReferenceError: x is not defined  let x;           // 선언 단계  console.log(x);  // undefined    x = 10;          // 할당 단계  console.log(x);  // 10  Uncaught ReferenceError: x is not defined    at &amp;lt;anonymous&amp;gt;:3:15그럼 let은 호이스팅이 안되는게 아닐까?  let x = 10;  {      console.log(x);  }  10결과를 보면 선언단계와 초기화단계가 먼저 이루어졌기 때문에 정상적으로 결과값이 출력됩니다.아래 코드에 let 선언을 추가해봅니다.  let x = 10;  {      console.log(x);      let x = 20;  }  Uncaught ReferenceError: Cannot access &#39;x&#39; before initialization전역변수 x가 console.log에 출력될 것 처럼 보일 수 있다. 하지만, { } 블록안에서 호이스팅이 발생하기 때문에 참조 에러(ReferenceError)가 발생하게 됩니다.ES6의 let과 const 키워드는 코드블록 내에서는 블록 스코프를 따르므로 { }블록 내에 선언 된 let x는 지역 변수로 적용됩니다. 따라서 { } 블록 안 스코프에서 호이스팅이 적용되고 코드 블록의 선두에서 초기화가 이루어 지는 지점까지는 일시적 사각지대(TDZ)에 빠지게 됩니다. 그렇기 때문에 참조 에러(ReferenceError)가 발생하게 됩니다.let은 전역 객체가 아니다전역 객체(Global Object)란 모든 객체의 최상위 객체를 의미합니다.Browser-side에서는 window 객체, Server-side(Node.js)에서는 global 객체를 의미합니다.여기서 var로 선언된 변수를 전역 변수로 사용하게 된다면 전역 객체의 프로퍼티가 됩니다.하지만, let로 선언된 변수를 전역 변수로 사용하게 되더라도 전역 객체의 프로퍼티가 아닙니다.다시말해, window 객체로 접근할 수 없으며, global 객체에만 접근할 수 있습니다.  var x = &#39;Global Object&#39;; // var 키워드 선언  console.log(window.x);   // var 키워드는 전역 객체(Global Object)의 프로퍼티가 되므로 window 객체 접근 가능  Global Object  let x = &#39;Global Object&#39;; // let 키워드 선언  console.log(window.x);  // let 키워드는 전역 객체(Global Object)의 프로퍼티가 되므로 window 객체 접근 불가능  undefinedconstconst는 상수(변하지 않는 값)을 위해 사용하는 키워드입니다.const는 let과 대부분 비슷하지만 다른점에 대해서만 알아보겠습니다.선언과 초기화let 의 특징  중복선언 불가능    let x=20;  // 최초 선언let x=50;  // 중복 선언        Uncaught SyntaxError: Identifier &#39;x&#39; has already been declared        재할당 가능    let x=30;   // 최초 선언x =20;      // 재할당console.log(x); // 20 출력         20          const의 특징  중복선언 불가능    const x=20;  // 최초 선언const x=50;  // 중복 선언        Uncaught SyntaxError: Identifier &#39;x&#39; has already been declared        재할당 불가능    const x=30;   // 최초 선언x =20;      // 재할당시 문법 에러 발생        Uncaught TypeError: Assignment to constant variable.        const의 키워드는 반드시 선언과 동시에 할당이 이루어져야 합니다. 그렇지 않으면 이미 선언된 변수에 값을 할당할 수 없습니다. 그 이유는 재할당이 안되기 때문입니다.    const x;    // 초기화x =20;      // 할당        Uncaught SyntaxError: Missing initializer in const declaration      const의 객체  const는 재할당이 되지 않는다고 말씀드렸습니다. 하지만, 객체의 프로퍼티는 변경할 수 있습니다.    const obj = {&#39;name&#39; : &#39;seongsik&#39;};obj.name = &#39;good&#39;;console.log(obj);        {name: &#39;good&#39;}      const 키워드는 객체의 내용이 변경(추가, 변경, 삭제)되더라도 객체 타입 변수에 할당된 메모리 주소값은 변경되지 않습니다.따라서, 객체 타입 변수 선언에는 const를 사용하는 것이 좋습니다. 만약 객체 타입 변수의 주소값을 변경(재할당)해야 한다면 let을 사용합니다.끝으로  ES6(2015)+를 사용한다면 var를 사용하지 않는 것이 좋습니다.  자바스크립트 코드양이 많아질 수록 의도치 않은 재할당 실수를 하게되는데 이를 방지하기 위해 const를 사용합니다.  재할당이 필요한 경우에는 let을 사용합니다."
  },
  
  {
    "title": "[Javascript] Scope 개념 확실히 알고 넘어가자",
    "url": "/posts/javascript-03/",
    "categories": "Javascript",
    "tags": "Javascript, ES6",
    "date": "2022-01-02 00:00:00 +0900",
    





    "snippet": "자바스크립트 ScopeScope는 변수의 접근성을 결정합니다.ES6(2015) 이전에는 자바스크립트에 Global Scope 와 Function Scope만 있었습니다.ES6(2015)가 생기면서 const와 let 이 도입되었고, 이 두 키워드는 자바스크립트에서 Block Scope를 제공합니다.  자바스크립트의 3가지 Scope 유형 :      Block scope    Function scope    Global scope    자바스크립트의 2가지 변수 유형 :      Global variable    Local variable  Scope 예시Scope는 변수의 접근성을 결정한다고 했는데, 정의로 이해하는 것보다 실습으로 이해해봅시다.x변수에 Global Scope 선언과 fn 함수내부 x변수에 Function Scope를 선언하였습니다.똑같은 이름으로 중복 선언을 하였는데 실행하면 어떤 결과가 나올까요?  var x = &#39;Global Scope&#39;;  function fn () {      var x = &#39;Functuin Scope&#39;      console.log(x);  }  fn();   console.log(x);  Functuin Scope  Global Scope실행 순서대로 Functuin Scope -&amp;gt; Global Scope가 console.log에 찍힌 것을 확인할 수 있습니다.스코프는 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙입니다.자바스크립트는 이 규칙대로 식별자를 찾습니다.프로그래밍은 변수를 선언하고 값을 할당하여 변수를 참조하는 기본적인 기능을 제공합니다. 이것으로 프로그램의 상태를 관리할 수 있습니다. 변수는 전역 또는 코드 블록(if, for, while, try/catch 등)이나 함수 내에 선언하며 코드 블록이나 함수는 중첩될 수 있다. 식별자는 자신이 어디에서 선언됐는지에 의해 자신이 유효한(다른 코드가 자신을 참조할 수 있는) 범위를 갖습니다.다시 예제로 돌아와, 전역에 선언된 x는 어디에든 참조할 수 있습니다. 하지만 fn() 함수 안에 선언된 x는 함수 내부에서만 참조할 수 있고 함수 외부에서는 참조할 수 없습니다.이것을 스코프(Scope)라 부릅니다.스코프(Scope)가 있기 때문에 같은 식별자 이름은 중복되서 사용할 수 없게하여 식별자 이름의 충돌을 방지합니다.블록 스코프(block Scope)자바스크립트는 기본적으로 함수 레벨 스코프(function-level scope)를 따릅니다. 함수 레벨 스코프란 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 참조할 수 없습니다.하지만, ES6(2015)에 도입된 let, const는 블록 레벨 스코프(block-level scope)를 제공합니다.  {    let x = 10;    const y = 20;  }  console.log(x);  console.log(y);  Uncaught ReferenceError: x is not defined    at &amp;lt;anonymous&amp;gt;:6:13  if (true) {    let x = 10;    const y = 20;  }  console.log(x);  console.log(y);  Uncaught ReferenceError: x is not defined    at &amp;lt;anonymous&amp;gt;:6:13{ } 블록 내부에 let과 const로 선언된 x,y는 블록 레벨 스코프를 따르기 때문에 외부에서 접근할 수 없습니다.하지만, var 키워드로 선언된 변수는 블록 레벨 스코프를 가질 수 없습니다. { } 블록 내부에 선언된 변수는 외부에서 접근할 수 있습니다.  {    var x = 10;  }  console.log(x);  10  if (true) {    var x = 10;  }  console.log(x);  10전역 스코프(Global Scope)전역으로 선언된 변수(함수 외부)는 전역 스코프(Global Scope)를 가지며, 자바스크립트 프로그램의 어디에서나 접근할 수 있습니다.var, let, const로 선언된 변수는 모두 Global Scope가 있습니다.  var x = 10;  let y = 20;  const z = 30;  function fn(){      console.log(x);      console.log(y);      console.log(z);  }  fn();  10  20  30함수 스코프(Function Scope)아까 자바스크립트는 기본적으로 함수 레벨 스코프를 따른다고 말씀드렸습니다.다시 말해, 함수 내에서 선언된 변수는 함수 외부에서는 접근할 수 없습니다.  function fn(){    var x = 20;  }  console.log(x);  Uncaught ReferenceError: x is not defined    at &amp;lt;anonymous&amp;gt;:5:13자동 전역 스코프(Automatically Global Scope)만약 var or let or const 로 선언되지 않은 변수에 값을 할당하게 되면 자동으로 전역 변수가 됩니다.  function fn(){    x = 20;  }  fn();  console.log(x);  20엄격모드(Strict Mode)엄격모드에서는 선언되지 않는 변수는 자동으로 전역적이지 않습니다.참고자료 출저스코프JavaScript Scope"
  },
  
  {
    "title": "[Babel] Webpack에 통합하여 사용하기",
    "url": "/posts/Babel-03/",
    "categories": "Babel",
    "tags": "Webpack, Node.js, Javascript",
    "date": "2021-12-28 00:00:00 +0900",
    





    "snippet": "babel-loader  바벨을 직접사용하여 변환하는 것보다는 Webpack과 통합여 사용하는 것이 일반적입니다.  바벨 로더를 사용하면 Babel 및 Webpack을 사용하여 Javascript 파일을 변환할 수 있습니다.install :    npm install -D babel-loader./src/app.js :    const a = 30;    let b = 20;    const alert_func = msg =&amp;gt; window.alert(msg);    alert_func(a+b);    const aa = new Promise();webpack.config.js :  babel-loader는 .js 확장자로 끝나는 파일들을 모두 처리합니다.  babel.config.js에서 프리셋 설정을 options 객체에 babel.config.js의 내용을 넣어서 사용하면 됩니다.  만약, babel.config.js 설정파일을 사용하고 싶으면  babel-loader만 로드시키십시오. 그러면 바벨로더가 빌드시 자동으로 babel.config.js 설정파일을 읽습니다.  바벨로더는 프로젝트안에서 .js 확장자를 모두 처리하기 때문에 exclude에 node_modules를 설정하여 node_modules안에 있는 라이브러리까지 처리 하지 않게 제외시킬 수 있습니다.  exclude에 node_modules을 제외시키면 core-js를 설치 해야합니다. 그 이유는, 폴리필 설정 시  require(&quot;core-js/modules/es6.promise&quot;)  require(&quot;core-js/modules/es6.object.to-string&quot;)  위 코드를 바벨이 생성 하게 되는데, node_modules을 제외시켰기 때문에 core-js를 찾을 수 없습니다. 따라서 별도의 core-js를 설치해야 합니다.install :    npm install core-js@3 --save    # or    npm install core-js@2 --save    module.exports = {        module: {            rules: [                {                    test: /\\.m?js$/,                    exclude: /(node_modules|bower_components)/,                    use: {                        loader: &#39;babel-loader&#39;,                        options: {                            presets: [                                [                                &quot;@babel/preset-env&quot;,                                {                                    targets: {                                        chrome: &quot;79&quot;,                                         ie: &quot;10&quot;                                    },                                    useBuiltIns: &quot;usage&quot;,                                    corejs: {                                        version: 2,                                    },                                },                                ],                            ],                        }                    }                },            ],        },    }build 결과 :    &amp;gt; npm run buildbuild된 output인 ./dist/main.js를 살펴보면 babel이 적용된 것을 확인할 수 있습니다.    &amp;gt; npm run build  core-js 패키지로부터 promise 모듈을 가져오는 임포트 구문이 추가되었습니다.  arrow function인 alert_func 함수가 일반 함수로 바뀌었고, const -&amp;gt; var로 변경되었습니다.  const a = 30; -&amp;gt; var a = 30;  let b = 20; -&amp;gt; var b = 20; 으로 변경되었습니다."
  },
  
  {
    "title": "[Babel] 바벨의 프레셋(Presets) 사용",
    "url": "/posts/Babel-02/",
    "categories": "Babel",
    "tags": "Webpack, Node.js, Javascript",
    "date": "2021-12-23 00:00:00 +0900",
    





    "snippet": "프레셋(Presets)이란?플러그인으로 코드 변환을 하기 위해서는 필요한 플러그인을 각각 설정해야 했습니다.    module.exports = {        plugins: [            &quot;@babel/plugin-transform-block-scoping&quot;,            &quot;@babel/plugin-transform-arrow-functions&quot;,            &quot;@babel/plugin-transform-strict-mode&quot;,        ]    }혹은build :    &amp;gt; npx app.js --plugins=@babel/plugin-transform-block-scoping --plugins=@babel/plugin-transform-arrow-functions --plugins=@babel/plugin-transform-strict-mode바벨은 필요한 플러그인들을 모아 만든 프레셋(Presets)이라는 기능을 제공합니다.이제는 하나하나 세팅할 필요가 없습니다.프레셋(Presets) 만들기기존의 세개의 플러그인을 하나의 프리셋으로 만들어 보겠습니다.    module.exports = function custompreset(){        return {            plugins: [                &quot;@babel/plugin-transform-block-scoping&quot;,                &quot;@babel/plugin-transform-arrow-functions&quot;,                &quot;@babel/plugin-transform-strict-mode&quot;,            ]        };    }    module.exports = {        presets:[&#39;./customPreset.js&#39;]    }build 결과 :    &amp;gt; npx babel app.js    &quot;use strict&quot;;    // Babel Input: ES2015 arrow function, const/let 스코프    [1, 2, 3].map(function (data) {    return data + 1;    });    var test = 3;    var test2 = 5;플러그인을 하나의 프리셋으로 묶어 babel.config.js 기본설정 파일 presets 배열에 추가만 해주면 됩니다.바벨의 프레셋(Presets) 사용하기바벨 곰식홈페이지에 들어가면 바벨은 목적에 맞는 프리셋을 제공합니다.실제로 실무에서는 플로그인이나 커스텀 프리셋을 만들지 않고 바벨이 제공하는 프리셋을 사용합니다.preset-react는 리액트를 preset-typescript는 타입스크립트를 preset-flow는 flow을 변환해주는 프리셋입니다. 이번 포스트는 ES6 문법으로 진행할 것이기 때문에 preset-env에 대해서만 알아보도록 하겠습니다.preset-envpreset-env은 대상 환경에 필요한 변환을 세세하게 관리할 필요 없이, 최신 ES2015+ Javascript를 사용할 수 있는 환경을 제공합니다. 이전에는 연도별로 프리셋을 제공했지만(babel-reset-es2015, babel-reset-es2016, babel-reset-es2017, babel-reset-latest …) 이제는 preset-env로 통합하여 제공합니다.install :    npm install --save-dev @babel/preset-env    module.exports = {        presets: [            &quot;@babel/preset-env&quot;        ]    }build 결과 :    &amp;gt; npx babel app.js    &quot;use strict&quot;;    // Babel Input: ES2015 arrow function, const/let 스코프    [1, 2, 3].map(function (data) {    return data + 1;    });    var test = 3;    var test2 = 5;Optionstargets  브라우저의 최소 환경 버전을 지정하여 타겟 브라우저 환경에 맞는 플러그인들을 찾아 변환해 줍니다.  targets에 아무것도 지정하지 않으면 최상위 옵션이 설정됩니다.  targets에 브라우저를 여러개 지정하면, 바벨은 알아서 최소 환경 기준으로 변환 합니다.브라우저 호환성 체크  can i use 에서 확인  크롬 58 버전은 arrow function, const, let을 모두 제공하지만 IE10은 제공하지 않습니다. 최저 환경인 IE10 기준으로 변환 되는지 확인해보겠습니다.    module.exports = {        presets: [        [            &quot;@babel/preset-env&quot;,            {            targets: {                chrome: &quot;58&quot;,                 ie: &quot;10&quot;            }            }        ]        ]    }build 결과 :    &amp;gt; npx babel app.js    &quot;use strict&quot;;    // Babel Input: ES2015 arrow function, const/let 스코프    [1, 2, 3].map(function (data) {    return data + 1;    });    var test = 3;    var test2 = 5;폴리필(polyfills)  useBuiltIns 옵션을 다루기전에 폴리필이라는 개념을 먼저 알아야합니다. 예제를 보시면 app.js에 ES6 문법인 new Promise() 사용했습니다.  하지만 build 결과는 변함이 없습니다. 바벨은 ES6에서 ES5로 변환할 수 있는 것만 빌드합니다.  그렇지 못한 것들은 폴리필(polyfills)이라고 부르는 코드조각을 추가하여 해결합니다.  정리하여 Promise()는 ES5로 변환할 수 없기 때문에, 폴리필을 사용하여 ES5 버전에서 구동될 수 있도록 구현합니다.    // Babel Input: ES2015 Promise    new Promise()    module.exports = {        presets: [        [            &quot;@babel/preset-env&quot;,            {            targets: {                chrome: &quot;58&quot;,                 ie: &quot;10&quot;            }            }        ]        ]    }build 결과 :    &amp;gt; npx babel app.js    &quot;use strict&quot;;    // Babel Input: ES2015 Promise    new Promise();분명 preset-env 프리셋을 적용했는대도 ES5로 변환이 안됩니다. 그useBuiltIns  useBuiltIns은 폴리필을 처리하는 방법을 구성합니다.  &quot;usage&quot;, &quot;entry&quot;, false 3가지 중 하나를 선택, default는 false  &quot;usage&quot;, &quot;entry&quot; 옵션을 선택하면 core-js을 모듈로 가져와서 사용합니다.  @babel/polyfill은 7.4.0버전부터는 사용되지 않습니다. 따라서 직접 추가하는 것을 추천하고 있습니다.install :    npm install core-js@3 --save    # or    npm install core-js@2 --savecorejs의 기본값은 “2” 버전입니다.    module.exports = {    presets: [        [        &quot;@babel/preset-env&quot;,        {            useBuiltIns: &quot;usage&quot;,            corejs: {            version: 2,            },        },        ],    ],    }build 결과 :  corejs의 기본값은 “2” 버전입니다. build 결과를 보면 corejs에서 Promise 모듈을 import하는 구문이 상단에 추가된 것을 확인할 수 있습니다.  corejs를 install해서 직접 import 구문을 추가하는 방법을 사용해도 무관합니다.    &amp;gt; npx babel app.js       &quot;use strict&quot;;    require(&quot;core-js/modules/es6.object.to-string.js&quot;);    require(&quot;core-js/modules/es6.promise.js&quot;);    // Babel Input: ES2015 Promise    new Promise();"
  },
  
  {
    "title": "[Babel] 바벨의 이해와 동작원리 파악하기",
    "url": "/posts/Babel-01/",
    "categories": "Babel",
    "tags": "Webpack, Node.js, Javascript",
    "date": "2021-12-23 00:00:00 +0900",
    





    "snippet": "Babel의 등장 배경  브라우저마다 사용하는 언어가 다르다.  ECMAScript2015+ 이후의 Javascript 언어를 특정 브라우저 및 버전에 따라 사용할 수 없는 문제  예를 들어, 크롬 79버전 기준으로 개발했으나, IE에서는 작동이 안되는 크로스브라우징이 발생한다.  Babel은 이러한 크로스브라우징 이슈를 해결해준다. ECMAScript2015+ 로 작성한 코드를 모든 브라우저에 호환할 수 있도록 코드를 변환해준다.Babel의 동작원리교육자료 : 프론트엔드 개발환경의 이해: Babel참고자료 : Babel 공식사이트참고자료 : Babel Plugin Handbook기본 동작  파싱(Parsing) - 코드를 토큰별로 분해  변환(Transforming) - 파싱한 코드를 ES5로 변환한다.(플러그인 담당)  출력(Printing) - 변환된 결과물을 출력하여 작업을 완료ECMAScript2015+ 문법을 사용한 .js파일을 생성하고 이 파일을 IE에서도 읽을 수 있도록 변환해 보는 작업을 진행해 봅시다.install :    &amp;gt; npm install --save-dev @babel/core @babel/cli    // Babel Input: ES2015 arrow function    [1, 2, 3].map(data =&amp;gt; data + 1);    // Babel Input: ES2015 const, let 스코프    const test = 3;    let test2 = 5;  일단 path.node.name의 값들은 무엇인지 살펴보자.    module.exports = function myBabelPlugin() {        return {        visitor: {            Identifier(path) {            const name = path.node.name;                        console.log(&quot;Identifier() name:&quot;, name)            // reverse the name: JavaScript -&amp;gt; tpircSavaJ            // path.node.name = name            //    .split(&quot;&quot;)            //    .reverse()            //    .join(&quot;&quot;);            },        },        };    }babel build :  path.node.name의 값들을 확인할 수 있습니다.    &amp;gt; npx babel app.js --plugins ./myBabelPlugin.js    Identifier() name: map    Identifier() name: data    Identifier() name: data    Identifier() name: test    Identifier() name: test2    ...  플로그인은 visitor 객체를 반환해야 합니다. 이 객체는 바벨이 파싱하여 만든 추상 구문 트리(AST)에 접근할 수 있는 메소드를 제공합니다.  그 중 Identifier() 메소드의 동작을 알아보면 Identifier()에 들어온 인자 path에 접근하면 파싱된 코드들을 뒤집어서 집어 넣는 예제입니다.  실제로 ./app.js의 코드들이 뒤집혀 출력되는지 확인해봅시다.    module.exports = function myBabelPlugin() {        return {        visitor: {            Identifier(path) {            const name = path.node.name;            // reverse the name: JavaScript -&amp;gt; tpircSavaJ            path.node.name = name                .split(&quot;&quot;)                .reverse()                .join(&quot;&quot;);            },        },        };    }직접만든 babel 플로그인을 사용해서 ./app.js 변환 :  path.node.name : map, data, data, test, test2 들이 뒤집혀서 출력    // npx babel [변환할.js] --plugins [적용할 plugin]    &amp;gt; npx babel app.js --plugins ./myBabelPlugin.js    // Babel Input: ES2015 arrow function, const/let 스코프    [1, 2, 3].pam(atad =&amp;gt; atad + 1);    const tset = 3;    let 2tset = 5;VariableDeclaration를 사용하여 const, let 스코프를 var로 변환해주는 코드 작성해보기VariableDeclaration() 메소드는 이름 그대로 변수가 어떤 스코프로 선언되었는지 참조할 수 있습니다.AST Node VariableDeclaration shape:                              kind: “var”          “let”          “const” (required)                      declarations: Array (required)  declare: boolean (default: null, excluded from builder function)app.js에서 변수선언의 종류를 console.log로 확인    module.exports = function myBabelPlugin() {        return {        visitor: {            VariableDeclaration(path) {                console.log(&quot;VariableDeclaration() kind:&quot;, path.node.kind) // const                            },        },        };    }build 결과 :const, let이 출력    &amp;gt; npx babel app.js --plugins=./myBabelPlugin.js    VariableDeclaration() kind: const    VariableDeclaration() kind: letconst, let -&amp;gt; var로 변경    module.exports = function myBabelPlugin() {        return {        visitor: {            VariableDeclaration(path) {                console.log(&quot;VariableDeclaration() kind:&quot;, path.node.kind)                                // const, let -&amp;gt; var 로 변환                if (path.node.kind === &quot;const&quot; || path.node.kind === &quot;let&quot;) {                    path.node.kind = &quot;var&quot;                }            },        },        };    }build 결과 :    &amp;gt; npx babel app.js --plugins=./myBabelPlugin.js    // Babel Input: ES2015 arrow function, const/let 스코프    [1, 2, 3].map(data =&amp;gt; data + 1);    var test = 3;    var test2 = 5;플러그인 사용babel에서 제공하는 플러그인들을 사용해서 변환해보겠습니다.@babel/plugin-transform-block-scoping  block scoping을 따르는 const, let을 함수 스코핑인 const, let 처럼 블록 스코핑을 따르는 예약어를 함수 스코핑을 사용하는 var로 변경해 준다.@babel/plugin-transform-arrow-functions  arrow function을 일반 함수로 변경해 준다.@babel/plugin-transform-strict-mode  strict 모드는 ES5(ECMA Script 5)에 추가된 키워드입니다.  자바스크립트가 묵인했던 에러들의 에러 메세지를 발생시킵니다. 즉, 엄격하게 문법검사를 하겠다로 이해하면 됩니다.  스크립트 시작부분에 &quot;use strict&quot;를 선언하면 strict 모드로 코드를 작성할 수 있습니다.install :    &amp;gt; npm install --save-dev @babel/plugin-transform-block-scoping @babel/plugin-transform-arrow-functions @babel/plugin-transform-strict-modepackage.json devDependencies 에 추가된 것을 확인할 수 있습니다.build 결과 :    &amp;gt; npx babel app.js --plugins=@babel/plugin-transform-block-scoping --plugins=@babel/plugin-transform-arrow-functions --plugins=@babel/plugin-transform-strict-mode    &quot;use strict&quot;;    // Babel Input: ES2015 arrow function, const/let 스코프    [1, 2, 3].map(function (data) {    return data + 1;    });    var test = 3;    var test2 = 5;babel.config.js(기본 설정파일) 사용하기사용하려는 babel 플러그인이 많아지면 많아질수록 커맨드 명령어도 길어지기 때문에 webpack.config.js 처럼 설정파일로 분리하여 사용하는 것이 좋습니다. 이 역할을 babel.config.js가 합니다. babel은 babel.config.js 파일이 있으면 자동으로 처리합니다.    module.exports = {        plugins: [            &quot;@babel/plugin-transform-block-scoping&quot;,            &quot;@babel/plugin-transform-arrow-functions&quot;,            &quot;@babel/plugin-transform-strict-mode&quot;,        ]    }build 결과 :    &amp;gt; npx babel app.js    &quot;use strict&quot;;    // Babel Input: ES2015 arrow function, const/let 스코프    [1, 2, 3].map(function (data) {    return data + 1;    });    var test = 3;    var test2 = 5;"
  },
  
  {
    "title": "[Web] 서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR) 개념",
    "url": "/posts/Web-SSR-CSR/",
    "categories": "Web",
    "tags": "Web",
    "date": "2021-12-21 00:00:00 +0900",
    





    "snippet": "요즘 기업이 SSR을 선택하는 이유가 있을까?우리가 많이 알고 있는 네이버 블로그 모바일 서비스도 2019년 5월 29일 “내 동영상 페이지”를 시작으로 Node.js 기반의 SSR 아키텍처가 네이버 모바일 블로그에 적용되었다고 합니다.또한, 월마트도 SEO 최적화와 좋은 퍼포먼스를 위해 SSR 아키텍처를 선택했다고 합니다.왜!? Why!?밑의 자료를 통해 저의 궁굼증을 해결했습니다.참고자료 :어서 와, SSR은 처음이지? - 도입 편SSR(server-side rendering)이란 무엇인가?서버 사이드 렌더링은 서버에서 클라이언트(브라우저)에게 보여줄 페이지를 모두 구성하여 클라이언트(브라우저)에게 페이지를 보여주는 방식입니다. JSP/Servlet의 아키텍처에서 이 방식을 사용했습니다.서버 사이드 렌더링을 사용하면 모든 데이터가 매핑된 서비스 페이지를 클라이언트(브라우저)에게 바로 보여줄 수 있습니다. 서버 사이드 렌더링은 서버에서 페이지를 구성하기 때문에 클라이언트 사이드 렌더링보다 페이지를 구성하는 속도는 늦지만 전체적으로 사용자에게 보여주는 콘텐츠 구성이 완료되는 시점은 빨라진다는 장점이 있습니다.SSR(server-side rendering)의 장점서버 사이드 렌더링을 사용하는 목적은 크게 2가지 입니다.  SEO(search engine optimization)  빠른 페이지 렌더링SEO, 검색 엔진 최적화는 구글이나 네이버와 같은 검색사이트에서 검색 결과가 사용자에게 최대한 많이 노출될 수 있도록 최적화 하는 기법입니다. 서버 사이드 렌더링은 빈 HTML 페이지를 받아 브라우저에서 그리는 클라이언트 사이드 렌더링과 다르게 서버에서 모두 구성되어 브라우저로 보내주기 때문에 페이지를 그리는 시간이 빠릅니다.SSR(server-side rendering) VS CSR(client-side rendering)출처자료: The Benefits of Server Side Rendering Over Client Side Rendering서버 사이드 렌더링은 브라우저의 요청에 대해 렌더링할 준비가 된 페이지의 HTML을 응답하는 반면, 클라이언트 사이드 렌더링은 브라우저가 모든 자바스크립트의 링크가 포함된 빈 HTML 문서를 가져옵니다.다시 말해, 서버 사이드 렌더링은 모든 자바스크립트 파일이 다운로드 및 실행될 때까지 기다릴 필요 없이 브라우저가 서버에서 HTML 렌더링을 시작합니다.반면 클라이언트 사이드 렌더링은 서버 사이드 렌더링보다 초기 전송되는 페이지 속도는 빠르지만 서비스에서 필요한 데이터를 클라이언트(브라우저)에서 추가로 요청하여 재구성해야 하기 때문에 전체적인 페이지 완료 시점은 서버 사이드 렌더링 보다 느립니다.Node.js의 기반의 SSR기본적으로 SPA 기반의 어플리케이션을 개발하기 위해서는 프론트엔드와 백엔드 영역의 분리가 선행되어야 합니다.아래 그림과 같이 기존의 JSP/Servlert 페이지를 CSR, SSR 영역 API로 분리함으로써 프론트엔드와 백엔드 영역에서 담당하는 페이지의 역할을 나누어야 합니다.출처자료 : 어서 와, SSR은 처음이지? - 도입 편저 그림만 보면 무슨 차이인지 모를 수 있습니다.SPA는 Single Page Application의 약자로 하나의 HTML 파일을 기반으로 자바스크립트를 이용해 동적으로 화면의 컨텐츠를 바꾸는 웹 어플리케이션을 말합니다. 요즘 프론트엔드 프레임워크 중 React, Vue, Angular를 SPA 프레임워크라고도 부르는데CSR를 이용한다고 생각하면 됩니다.너무나 빠른 프론트엔드의 생태계2015년 ES6 표준이 개정되면서 Javascript의 많은 변화가 일어났습니다. 또한, 이전의 자바스크립트의 단점을 보완하기 위해 나온 Jquery가 react, vue, angular 같은 강력한 프레임워크가 나오자 더이상 필요가 없어지는 상황까지 오고야 말았습니다.또한 ES6 이후로 프론트엔드 환경 최적화에 필요한 웹팩, 바벨, 린트 같은 기술들이 출시되면서 프론트엔드의 생태계가 빠르게 변화되고 있다는 걸 알 수 있습니다.이런 상황에서, 프론트엔드 개발자들은 개발영역 확장에 대한 도전이 필요하게 되었습니다.[jqeury 추이 그래프]Full Stack Developer의 한계2004-현재까지 Full Stack Developer 트렌드를 보면 지속적으로 증가하는 것을 확인할 수 있습니다. 많은 기업에서도 Full Stack Developer를 육성하거나 선호하고 있는데 빠르게 변화되는 프론트 엔드 생태계에서 양쪽 모두 잘하는 개발자를 만들어 내기에는 한계가 있습니다.이에 따라, 프론트엔드 개발 영역의 확대가 커지고 있습니다. Node.js의 등장으로 백엔드 역할까지 모두 할 수 있으며 SSR, CSR 페이지를 프론트엔드 영역에서 모두 수행할 수 있게 되었습니다.[Full Stack Developer 트렌드]Node.js의 기반의 SSR의 이점JavaScript를 최대한 사용할 수 있습니다.이게 가능한 이유는 밑의 포스트를 한번 보시기 바랍니다.[Node.js] Node.js - 개념 이해하기프론트엔드와 백엔드 영역의 완전한 분리로 생산성 향상기존의 CSR 페이지는 프론트엔드에서 SSR 페이지는 백엔드에서 개발했다면, SSR 환경을 구축하면 페이지의 소유권이 온전히 프론트엔드 영역에 존재하게 되므로 페이지가 변경될 때마다 불필요한 요청/응답을 할 필요가 없습니다.이렇게되면 백엔드 영역에서는 API 영역과 데이터 활용에 더 집중할 수 있어 서비스 품질을 높이는 데 기여할 수 있습니다.여러 가지 대안 활용필요에 따라서 CSR로만 구성할 수도 있고 CSR과 prependering을 함께 사용하도록 개발할 수도 있습니다."
  },
  
  {
    "title": "[Webpack] plugin",
    "url": "/posts/Webpack-05/",
    "categories": "Webpack",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2021-12-17 00:00:00 +0900",
    





    "snippet": "plugin란?파일단위로 처리하는 loader와 다르게 플러그인은 번들링된 결과를 처리합니다. 번들링된 자바스크립트를 난독화하거나 텍스트를 추출하는 등의 용도로 사용합니다.플러그인을 빌드하는 것은 로더를 빌드하는 것보다 조금 더 고급입니다. 플러그인을 이해하려면 webpack 저수준 내부의 이해가 필요합니다.이해를 위해 플러그인을 직접 만들어보고 내부적으로 어떻게 작동하는지 알아보겠습니다!plugin 만들기  plugin은 apply 메소드가 있는 javascript 객체입니다.  apply 메서드는 웹팩 컴파일러에 의해 한 번 호출되어 전체 컴파일에 대한 엑서스를 제공합니다.   class HelloWorldPlugin {    apply(compiler) {        compiler.hooks.done.tap(        &#39;Hello World Plugin&#39;,        (            stats /* stats is passed as an argument when done hook is tapped.  */        ) =&amp;gt; {            console.log(&#39;Hello World!&#39;);        }        );    }    }    module.exports = HelloWorldPlugin;    const MyPlugin = require(&quot;./myplugin&quot;)    module.exports = {        ...        plugins: [new MyPlugin()],    }build 결과 :  맨위에 Hellow World! log가 찍힌 것을 확인할 수 있습니다.      &amp;gt; npm run build  &amp;gt; webpack-demo@1.0.0 build  &amp;gt; webpack  Hello World!  asset images/bg.jpg 612 KiB [emitted] [from: src/bg.jpg] (auxiliary name: main)  asset main.js 33.8 KiB [emitted] (name: main)  runtime modules 2.39 KiB 7 modules  javascript modules 10.8 KiB  modules by path ./node_modules/ 8.66 KiB      modules by path ./node_modules/style-loader/dist/runtime/*.js 5.75 KiB 6 modules      modules by path ./node_modules/css-loader/dist/runtime/*.js 2.91 KiB 3 modules  modules by path ./src/ 2.19 KiB      modules by path ./src/*.js 323 bytes 2 modules      modules by path ./src/*.css 1.88 KiB      ./src/app.css 1.11 KiB [built] [code generated]      ./node_modules/css-loader/dist/cjs.js!./src/app.css 785 bytes [built] [code generated]  asset modules 5.17 KiB (javascript) 612 KiB (asset)  ./src/webpack.png 5.13 KiB [built] [code generated]  ./src/bg.jpg 42 bytes (javascript) 612 KiB (asset) [built] [code generated]  webpack 5.65.0 compiled successfully in 867 ms      여기서 중요한 건 loader는 파일 수 만큼 log가 찍혔다면 plugin은 한 번만 찍힌 것을 확인할 수 있습니다.위에 설명대로 plugin은 하나로 번들링된 결과에 대해서 처리하기 때문입니다.번들링된 결과(파일) 접근  비동기 이벤트 후크 : tapAsync  tapAsync 메소드를 사용하여 플로그인을 사용할 때는 함수의 마지막 인수로 제공되는 콜백 함수를 호출해야 합니다.  compiler 모듈은 CLI 또는 Node API를 통해 전달된 모든 옵션으로 컴파일 인스턴스를 생성하는 메인 엔진입니다.  Compilation 모듈은 compiler에서 새 컴파일 또는 빌드를 만드는데 사용합니다. Compilation 객체는는 모든 모듈과 디펜던시에 접근할 수 있습니다.compiler에 의해 번들링된 결과가 compilation 인자로 들어오면 compilation 객체로 청크를 복원하여 파일 소스를 콘솔에 찍습니다.   class MyPlugin {        apply(compiler) {            compiler.hooks.emit.tapAsync(&#39;MyPlugin&#39;, (compilation, callback) =&amp;gt; {            // 각 청크를 탐색합니다.            compilation.chunks.forEach((chunk) =&amp;gt; {                // 청크에 의해 생성된 각 asset 파일 이름을 탐색합니다.                chunk.files.forEach((filename) =&amp;gt; {                // 청크에 의해 생성된 각 파일의 asset 소스를 가져옵니다.                var source = compilation.assets[&#39;main.js&#39;].source();                console.log(source);                });            });            callback();            });        }    }  module.exports = MyPlugin;build 결과 : log 상단의 주석과 번들링 결과인 main.js의 상단의 주석이 같은 것을 확인할 수 있습니다.BannerPlugin  생성된 각 chunk 상단에 정보들을 추가 입력할 수 있게 도와주는 플러그인입니다.  예) 빌드 버전, 커밋 버전, 개발자명, 참여인원, 수정날짜 등BannerPlugin :    const webpack = require(&#39;webpack&#39;);    new webpack.BannerPlugin(banner);    // or    new webpack.BannerPlugin(options);Options :    {        banner: string | function, // the banner as string or function, it will be wrapped in a comment        raw: boolean, // if true, banner will not be wrapped in a comment        entryOnly: boolean, // if true, the banner will only be added to the entry chunks        test: string | RegExp | [string, RegExp], // Include all modules that pass test assertion.        include: string | RegExp | [string, RegExp], // Include all modules matching any of these conditions.        exclude: string | RegExp | [string, RegExp], // Exclude all modules matching any of these conditions.    }사용방법 :    import webpack from &#39;webpack&#39;;    // string    new webpack.BannerPlugin({        banner: &#39;hello world&#39;,    });    // function    new webpack.BannerPlugin({        banner: (yourVariable) =&amp;gt; {            return `yourVariable: ${yourVariable}`;        },    });    Place배너 파일 생성 :  배너 정보가 많을 경우에는 파일을 따로 생성해서 적용할 수 있습니다.    const webpack  = require(&#39;webpack&#39;);    const banner = require(&#39;./banner.js&#39;);    module.exports = {        ...        plugins : [new webpack.BannerPlugin(banner)],    }    const childProcess = require(&quot;child_process&quot;);    module.exports = function banner() {        const user_name = childProcess.execSync(&quot;git config user.name&quot;);        const date = new Date().toLocaleString();        const commit = childProcess.execSync(&quot;git rev-parse --short HEAD&quot;)        const node = childProcess.execSync(&quot;node --version&quot;)        return (            `                user name : ${user_name}            `+            `                Build date : ${date}            `+            `                Commit version : ${commit}            `+            `                node.js version : ${node}            `        )            }build 결과 :DefinePlugin  DefinePlugin을 사용하면 컴파일 타임에 구성할 수 있는 전역 상수를 만들 수 있습니다.  DefinePlugin은 개발환경, 운영환경에 따라 다른 동작을 하고 싶을 때 사용합니다.  가령, 개발환경에서는 로깅을 수행하지만, 운영환경에서는 수행하지 않는 경우에 전역 상수를 사용하여 로깅의 수행여부를 결정할 수 있습니다.  DefinePlugin을 사용하여 개발 및 운영 빌드 환경을 잊어버리시면 됩니다.  참고로, process.env.NODE_ENV 는 노드 환경정보가 들어있는 변수이다. 처음 webpack 설정의 mode값이 들어가 있다.    const webpack  = require(&#39;webpack&#39;);    module.exports = {        ...        plugins : [            new webpack.DefinePlugin({                PRODUCTION: JSON.stringify(true),                VERSION: JSON.stringify(&#39;5fa3b9&#39;),                BROWSER_SUPPORTS_HTML5: true,                TWO: &#39;1+1&#39;,                &#39;typeof window&#39;: JSON.stringify(&#39;object&#39;)            })        ],    }        ...    // DefinePlugin에서 구성한 전역 상수를 사용할 수 있다.    console.log(PRODUCTION);    console.log(VERSION);    console.log(BROWSER_SUPPORTS_HTML5);    console.log(TWO);    console.log(typeof window);    console.log(process.env.NODE_ENV);build 결과 :CleanWebpackPlugin  CleanWebpackPlugin은 build된 폴더를 제거/정리하는 webpack plugin 입니다.  Node v10+ 및 webpack v4+ 에서 지원됩니다.  기본적으로 이 플러그인은 output.path 성공적인 재구축 후 webpack 디렉토리 내의 모든 파일과 사용되지 않는 webpack 자산들을 모두 제거합니다.install :    npm install --save-dev clean-webpack-plugin    // default export가 아니기 때문에 { name } 으로 불러옵니다.    const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;);    module.exports = {        ...        plugins : [            new CleanWebpackPlugin(),        ],    }dist 폴더에 test.js 추가 :build 결과 :    npm run build    &amp;gt; webpack-demo@1.0.0 build    &amp;gt; webpack    asset images/bg.jpg 612 KiB [emitted] [from: src/bg.jpg] (auxiliary name: main)    asset main.js 34.1 KiB [emitted] (name: main)    runtime modules 2.39 KiB 7 modules    javascript modules 11 KiB    modules by path ./node_modules/ 8.66 KiB        modules by path ./node_modules/style-loader/dist/runtime/*.js 5.75 KiB 6 modules        modules by path ./node_modules/css-loader/dist/runtime/*.js 2.91 KiB 3 modules    modules by path ./src/ 2.36 KiB        modules by path ./src/*.js 494 bytes 2 modules        modules by path ./src/*.css 1.88 KiB        ./src/app.css 1.11 KiB [built] [code generated]        ./node_modules/css-loader/dist/cjs.js!./src/app.css 785 bytes [built] [code generated]    asset modules 5.17 KiB (javascript) 612 KiB (asset)    ./src/webpack.png 5.13 KiB [built] [code generated]    ./src/bg.jpg 42 bytes (javascript) 612 KiB (asset) [built] [code generated]    webpack 5.65.0 compiled successfully in 3267 msdist 디렉토리를 깔끔하게 지우고 다시 build된 것을 확인할 수 있습니다.HtmlWebpackPlugin  HtmlWebpackPlugin은 HTML파일 생성을 단순화합니다. 빌드 타임에 값을 넣거나 코드를 압축할 수 있습니다.  webpack.config.js에서 설정한 output path에 dist/index.html 파일이 생성됩니다.  3rd party 패키지입니다.install :   npm install --save-dev html-webpack-plugin./index.html :    &amp;lt;!DOCTYPE html&amp;gt;    &amp;lt;html lang=&quot;en&quot;&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;        &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;body&amp;gt;        &amp;lt;!-- 스크립트 제거 --&amp;gt;        &amp;lt;!-- &amp;lt;script src=&quot;./dist/main.js&quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;    &amp;lt;/body&amp;gt;    &amp;lt;/html&amp;gt;   const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);   module.exports = {        ...        plugins : [            new HtmlWebpackPlugin(),        ],    }build 결과 :  dist/index.html 파일이 생성되었고 webpack의 엔트리 포인트는 생성된 HTML에 모두 &amp;lt;script&amp;gt; 태그로 포함됩니다.  만약 webpack 출력에 css asset이 있다면((MiniCssExtractPlugin으로 추출된 CSS) 이들은 생성된 HTML 파일의 &amp;lt;head&amp;gt;요소 안에 &amp;lt;link&amp;gt; 태그로 포함됩니다.Options를 줘서 커스텀할 수 있습니다.  HtmlWebpackPlugin Options 참고하기 (click)  ./index.html -&amp;gt; src/index.html에 하나 복사합니다.    &amp;lt;!DOCTYPE html&amp;gt;    &amp;lt;html lang=&quot;en&quot;&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;        &amp;lt;title&amp;gt;webpack app &amp;lt;%= env %&amp;gt;&amp;lt;/title&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;body&amp;gt;        &amp;lt;!-- &amp;lt;script src=&quot;./dist/main.js&quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;    &amp;lt;/body&amp;gt;    &amp;lt;/html&amp;gt;   const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);   module.exports = {        ...        plugins : [            new HtmlWebpackPlugin({            title: &#39;siksik webpack&#39;,        // 생성된 HTML에 사용할 제목            filename : &#39;siksik.html&#39;,       // 생성할 HTML 파일명, 기본값은 index.html            template: &#39;./src/index.html&#39;,   // 템플릿 경로를 지정            templateParameters: {           // 템플릿에 사용된 매개변수를 덮어쓸 수 있습니다.              env: process.env.NODE_ENV === &#39;development&#39; ? &#39;(development)&#39; : &#39;(product)&#39;,            },        })        ],    }NODE_ENV=production npm run build 결과 :   NODE_ENV=production npm run buildNODE_ENV=development npm run build 결과 :   NODE_ENV=development npm run buildMiniCssExtractPlugin  MiniCssExtractPlugin은 CSS를 별도의 파일로 추출합니다. CSS가 포함된 JS파일별로 CSS파일을 생성합니다.  CSS가 많아 질수록 하나의 Js 결과물로 만드는 것이 부담될 수 있습니다. 번들된 결과에서 CSS 코드만 뽑아 별도의 CSS 파일로 만들어 파일을 분리하는게 유리할 수 있습니다. 브라우저에서 큰 파일을 하나 받는 것 보다, 여러 개의 작은 파일을 동시에 다운로드하는게 빠릅니다.  css-loader와 함께 사용합니다.  production 환경인 경우엔 MiniCssExtractPlugin.loader를 사용하고  development 환경인 경우엔 style-loader를 사용해보자  MiniCssExtractPlugin.loader는 MiniCssExtractPlugin에서 제공하는 로더이다.install :   npm install --save-dev mini-css-extract-plugin   const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);   module.exports = {       plugins: [new MiniCssExtractPlugin()],       module: {           rules: [               {                   test: /\\.css$/i,                   use: [                        process.env.NODE_ENV === &#39;production&#39;                        ? MiniCssExtractPlugin.loader                        : &#39;style-loader&#39;,                        &#39;css-loader&#39;                   ]               },            ],        },        plugins : [            ...(process.env.NODE_ENV === &#39;production&#39;            ? [new MiniCssExtractPlugin({filename: &#39;[name].css&#39;})]            : []        ],    };    import &#39;./app.css&#39;;    ...app.css :    body {        background-image: url(bg.jpg);    }NODE_ENV=production npm run build 결과 :  main.css 파일이 dist 폴더에 생성된 것을 확인할 수 있습니다.  HtmlWebpackPlugin에 의해 생성된 HTML안에 css asset(main.css)이 &amp;lt;head&amp;gt; 요소 안에 &amp;lt;link&amp;gt; 태그로 포함된 것을 확인할 수 있습니다."
  },
  
  {
    "title": "[Webpack] loader (2)",
    "url": "/posts/Webpack-04/",
    "categories": "Webpack",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2021-12-15 00:00:00 +0900",
    





    "snippet": "자주 사용하는 로더css-loader  css-loader를 사용하면 스타일시트도 import 구문으로 불러와 모듈로 변환할 수 있습니다.  ./src/app.css 를 생성하여 밑의 코드를 저장합니다.  ./src/app.js에서 app.css를 import 구문을 추가합니다.  html에 css 태그를 넣지 않아도 적용되는지 확인해보겠습니다.install :    npm install --save-dev css-loader  ./package.json -&amp;gt; devDependencies에 css-loader가 추가된 것을 확인할 수 있습니다.    {        &quot;name&quot;: &quot;webpack-demo&quot;,        &quot;version&quot;: &quot;1.0.0&quot;,        &quot;description&quot;: &quot;&quot;,        &quot;main&quot;: &quot;index.js&quot;,        &quot;scripts&quot;: {            &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;amp;&amp;amp; exit 1&quot;,            &quot;build&quot;: &quot;webpack&quot;        },        &quot;author&quot;: &quot;&quot;,        &quot;license&quot;: &quot;ISC&quot;,        &quot;devDependencies&quot;: {            &quot;css-loader&quot;: &quot;^6.5.1&quot;,            &quot;webpack&quot;: &quot;^5.65.0&quot;,            &quot;webpack-cli&quot;: &quot;^4.9.1&quot;        }    }    body {        background-color: red;    }    &amp;lt;!DOCTYPE html&amp;gt;    &amp;lt;html lang=&quot;en&quot;&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;        &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;body&amp;gt;        &amp;lt;script src=&quot;./dist/main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;    &amp;lt;/body&amp;gt;    &amp;lt;/html&amp;gt;    import * as math from &#39;./math.js&#39;    import &#39;./app.css&#39;; // 추가    console.log(math.sum(1, 2));    export function sum(a, b){        return a + b;    }    const path = require(&#39;path&#39;);    module.exports = {        mode : &#39;development&#39;,        entry : {            main : &#39;./src/app.js&#39;        },        output : {            path : path.resolve(&#39;./dist&#39;),            filename : &#39;[name].js&#39;        },        module : {            rules : [{                test: /\\.css$/, // .css 확장자를 갖는 모든 파일을 대상으로 한다.                use: [&#39;css-loader&#39;)] // .css 파일을 모듈료 변환해주는 로더            }]        }    }결과 :    npm run build    &amp;gt; webpack-demo@1.0.0 build    &amp;gt; webpack    asset main.js 9.67 KiB [emitted] (name: main)    runtime modules 937 bytes 4 modules    cacheable modules 2.92 KiB    modules by path ./src/ 605 bytes        ./src/app.js 90 bytes [built] [code generated]        ./src/math.js 48 bytes [built] [code generated]        ./src/app.css 467 bytes [built] [code generated]    modules by path ./node_modules/css-loader/dist/runtime/*.js 2.33 KiB        ./node_modules/css-loader/dist/runtime/noSourceMaps.js 64 bytes [built] [code generated]        ./node_modules/css-loader/dist/runtime/api.js 2.26 KiB [built] [code generated]    webpack 5.65.0 compiled successfully in 2024 ms  &quot;./dist/main.js&quot;에서 javascript로 변환된 것을 확인할 수 있습니다.style-loader  css-loader는 자바스크립트 코드로 변환만 해주고, 실제 DOM에 적용되지 않습니다.  style-loader는 변환된 CSS코드를 동적으로 DOM에 추가해줍니다.  webpack으로 css를 번들링 하기 위해서는 css-loader와 style-loader를 함께 사용합니다.install :    npm install --save-dev style-loader  ./package.json -&amp;gt; devDependencies에 style-loader가 추가된 것을 확인할 수 있습니다.      {      &quot;name&quot;: &quot;webpack-demo&quot;,      &quot;version&quot;: &quot;1.0.0&quot;,      &quot;description&quot;: &quot;&quot;,      &quot;main&quot;: &quot;index.js&quot;,      &quot;scripts&quot;: {          &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;amp;&amp;amp; exit 1&quot;,          &quot;build&quot;: &quot;webpack&quot;      },      &quot;author&quot;: &quot;&quot;,      &quot;license&quot;: &quot;ISC&quot;,      &quot;devDependencies&quot;: {          &quot;css-loader&quot;: &quot;^6.5.1&quot;,          &quot;style-loader&quot;: &quot;^3.3.1&quot;,          &quot;webpack&quot;: &quot;^5.65.0&quot;,          &quot;webpack-cli&quot;: &quot;^4.9.1&quot;      }  }        css-loader로 변환된 자바스크립트 코드를 DOM에 삽입하기 때문에, css-loader -&amp;gt; style-loader 순서로 처리되어야합니다.여기서 중요한 포인트! loader은 역순으로 처리한다고 저번 포스터에 말씀드렸습니다. 그러므로 use: [&#39;style-loader&#39;,&#39;css-loader&#39;] 로 작성하셔야 합니다.      const path = require(&#39;path&#39;);  module.exports = {      mode : &#39;development&#39;,      entry : {          main : &#39;./src/app.js&#39;      },      output : {          path : path.resolve(&#39;./dist&#39;),          filename : &#39;[name].js&#39;      },      module : {          rules : [{              test: /\\.css$/,              use: [&#39;style-loader&#39;,&#39;css-loader&#39;]          }]      }  }      결과 :    npm run build    &amp;gt; webpack-demo@1.0.0 build    &amp;gt; webpack    asset main.js 23.7 KiB [emitted] (name: main)    runtime modules 937 bytes 4 modules    cacheable modules 9.77 KiB    modules by path ./node_modules/ 8.07 KiB        modules by path ./node_modules/style-loader/dist/runtime/*.js 5.75 KiB 6 modules        modules by path ./node_modules/css-loader/dist/runtime/*.js 2.33 KiB        ./node_modules/css-loader/dist/runtime/noSourceMaps.js 64 bytes [built] [code generated]        ./node_modules/css-loader/dist/runtime/api.js 2.26 KiB [built] [code generated]    modules by path ./src/ 1.7 KiB        modules by path ./src/*.js 138 bytes        ./src/app.js 90 bytes [built] [code generated]        ./src/math.js 48 bytes [built] [code generated]        modules by path ./src/*.css 1.57 KiB        ./src/app.css 1.11 KiB [built] [code generated]        ./node_modules/css-loader/dist/cjs.js!./src/app.css 467 bytes [built] [code generated]    webpack 5.65.0 compiled successfully in 903 ms  index.html을 열어보면 css가 적용된 것을 확인할 수 있습니다.Asset Moduleswebpack 공식문서 참고webpack 4 버전에서는 아래의 기능을 사용하는게 일반적이었습니다.  raw-loader, 파일을 문자열로 가져오는 기능  url-loader, 파일을 데이터 URI로 인라인하는 기능  file-loader, 파일을 출력 디렉토리로 보내는 기능webpack 5 버전에서는 Asset Modules의 4가지의 새로운 type을 추가하여 위의 로더를 대체합니다.  asset/resource, file-loader의 기능을 대체합니다.  asset/inline, url-loader의 기능을 대체합니다.  asset/source, raw-loader의 기능을 대체합니다.  asset, 파일 크기의 제한에 따라 file 내보내기와 URI 내보내기 중에서 자동으로 선택합니다,  url-loader의 기능 대체(limit에 따라 file or URI을 자동선택하여 내보냈었음)준비물 :  2개의 이미지 파일을 준비해주세요.  1개는 파일크기가 큰 이미지, 1개는 파일크기가 작은 이미지  .png, .jpg 아무거나 준비하셔도 됩니다.파일이 큰 이미지 파일을 body의 background-image로 써보겠습니다.    body {        background-image: url(bg.png);    }파일이 작은 이미지를 body안에 넣어서 써보겠습니다.    import * as math from &#39;./math.js&#39;    import &#39;./app.css&#39;;    import webpackImage from &#39;./webpack.png&#39;;    document.addEventListener(&#39;DOMContentLoaded&#39;, ()=&amp;gt;{        document.body.innerHTML = `            &amp;lt;img src=&quot;${webpackImage}&quot; /&amp;gt;        `    })    console.log(math.sum(1, 2));asset/resource    const path = require(&#39;path&#39;);    module.exports = {        mode : &#39;development&#39;,        entry : {            main : &#39;./src/app.js&#39;        },        output : {            path : path.resolve(&#39;./dist&#39;),            filename : &#39;[name].js&#39;        },        module : {            rules : [                {                    test: /\\.css$/,                    use: [&#39;style-loader&#39;,&#39;css-loader&#39;]                },{                    test: /\\.(png|jpg)/,                    type: &#39;asset/resource&#39;                }            ]        }    }결과 :    npm run build    &amp;gt; webpack-demo@1.0.0 build    &amp;gt; webpack    asset 07cd38e60ab3ac16ae90.jpg 612 KiB [emitted] [immutable] [from: src/bg.jpg] (auxiliary name: main)    asset main.js 28.8 KiB [emitted] (name: main)    asset 870be3fe12bc3abc096d.png 3.8 KiB [emitted] [immutable] [from: src/webpack.png] (auxiliary name: main)    runtime modules 2.39 KiB 7 modules    javascript modules 10.8 KiB    modules by path ./node_modules/ 8.66 KiB        modules by path ./node_modules/style-loader/dist/runtime/*.js 5.75 KiB 6 modules        modules by path ./node_modules/css-loader/dist/runtime/*.js 2.91 KiB 3 modules    modules by path ./src/ 2.19 KiB        modules by path ./src/*.js 323 bytes 2 modules        modules by path ./src/*.css 1.88 KiB        ./src/app.css 1.11 KiB [built] [code generated]        ./node_modules/css-loader/dist/cjs.js!./src/app.css 785 bytes [built] [code generated]    asset modules 84 bytes (javascript) 616 KiB (asset)    ./src/webpack.png 42 bytes (javascript) 3.8 KiB (asset) [built] [code generated]    ./src/bg.jpg 42 bytes (javascript) 612 KiB (asset) [built] [code generated]    webpack 5.65.0 compiled successfully in 970 ms  아래 그림을 보면, 출력(output) 디렉토리에 이미지가 저장된것을 확인할 수 있습니다.  이미지 이름이 해쉬코드로 변경되어 저장된 것을 확인할 수 있습니다.  ./index.html으로 결과를 확인해보면 이미지가 적용되었습니다.asset/inline    const path = require(&#39;path&#39;);    module.exports = {        mode : &#39;development&#39;,        entry : {            main : &#39;./src/app.js&#39;        },        output : {            path : path.resolve(&#39;./dist&#39;),            filename : &#39;[name].js&#39;        },        module : {            rules : [                {                    test: /\\.css$/,                    use: [&#39;style-loader&#39;,&#39;css-loader&#39;]                },{                    test: /\\.(png|jpg)/,                    type: &#39;asset/resource&#39;                }            ]        }    }결과 :    npm run build    &amp;gt; webpack-demo@1.0.0 build    &amp;gt; webpack    asset main.js 848 KiB [emitted] (name: main)    runtime modules 1.33 KiB 5 modules    javascript modules 10.8 KiB    modules by path ./node_modules/ 8.66 KiB        modules by path ./node_modules/style-loader/dist/runtime/*.js 5.75 KiB 6 modules        modules by path ./node_modules/css-loader/dist/runtime/*.js 2.91 KiB 3 modules    modules by path ./src/ 2.19 KiB        modules by path ./src/*.js 323 bytes 2 modules        modules by path ./src/*.css 1.88 KiB        ./src/app.css 1.11 KiB [built] [code generated]        ./node_modules/css-loader/dist/cjs.js!./src/app.css 785 bytes [built] [code generated]    asset modules 825 KiB    ./src/webpack.png 5.13 KiB [built] [code generated]    ./src/bg.jpg 820 KiB [built] [code generated]    webpack 5.65.0 compiled successfully in 1122 ms  asset/resource는 출력(output) 디렉토리에 해쉬코드로 이미지를 저장했지만, asset/inline은 저장되어있지않고 데이터를 URI로 내보냅니다.  추가로, 이미지를 Base64로 인코딩하여 문자열 형태로 소스코드에 넣는 형식입니다.  개발자도구를 통해 이미지들을 학인해보면 base64로 인코딩된 문자열이 들어가 있는것을 확인할 수 있습니다.asset  asset tpye은 디폴드로 파일 크기가 8kb 작으면 inline으로 크면 resource로 처리합니다.  Rule.parser.dataUrlCondition.maxSize 옵션을 추가하여 조건을 변경할 수 있습니다.  기준을 10kb로 잡아보겠습니다.이미지 크기 확인  bg.jpg : 626kb  webpack.png : 3.9kb    디렉터리: E:\\study\\frontend\\webpack-demo\\src    Mode                 LastWriteTime         Length Name    ----                 -------------         ------ ----    -a----      2021-12-16   오후 5:08             45 app.css    -a----      2021-12-16   오후 5:06            275 app.js    -a----      2019-12-07   오후 6:09         626435 bg.jpg    -a----      2021-12-15   오후 3:43             48 math.js    -a----      2021-12-16   오후 4:56           3890 webpack.png    const path = require(&#39;path&#39;);    module.exports = {        mode : &#39;development&#39;,        entry : {            main : &#39;./src/app.js&#39;        },        output : {            path : path.resolve(&#39;./dist&#39;),            filename : &#39;[name].js&#39;        },        module : {            rules : [                {                    test: /\\.css$/,                    use: [&#39;style-loader&#39;,&#39;css-loader&#39;]                },{                    test: /\\.(png|jpg)/,                    type: &#39;asset&#39;,                    parser: {                        dataUrlCondition: {                        maxSize: 10 * 1024 // 10kb                    }                }                }            ]        }    }결과 :    npm run build    &amp;gt; webpack-demo@1.0.0 build    &amp;gt; webpack    asset 07cd38e60ab3ac16ae90.jpg 612 KiB [emitted] [immutable] [from: src/bg.jpg] (auxiliary name: main)    asset main.js 33.8 KiB [emitted] (name: main)    runtime modules 2.39 KiB 7 modules    javascript modules 10.8 KiB    modules by path ./node_modules/ 8.66 KiB        modules by path ./node_modules/style-loader/dist/runtime/*.js 5.75 KiB 6 modules        modules by path ./node_modules/css-loader/dist/runtime/*.js 2.91 KiB 3 modules    modules by path ./src/ 2.19 KiB        modules by path ./src/*.js 323 bytes 2 modules        modules by path ./src/*.css 1.88 KiB        ./src/app.css 1.11 KiB [built] [code generated]        ./node_modules/css-loader/dist/cjs.js!./src/app.css 785 bytes [built] [code generated]    asset modules 5.17 KiB (javascript) 612 KiB (asset)    ./src/webpack.png 5.13 KiB [built] [code generated]    ./src/bg.jpg 42 bytes (javascript) 612 KiB (asset) [built] [code generated]    webpack 5.65.0 compiled successfully in 1502 ms  8kb이상인 bg.jpg는 resource 타입으로 처리되었고, 미만인 webpack.png는 inline 타입으로 처리되었습니다.Output File 커스텀  기본적으로 asset/resource 모듈은 [hash][ext][query] 파일 이름으로 출력 디렉토리에 내보냅니다.  webpack.config.js -&amp;gt; output.assetModuleFilename 구성에서 설정하여 파일명을 커스텀할 수 있습니다.  지정된 디렉토리에 내보낼 수도 있습니다.  images/[name][ext] 형태로 저장되는지 확인해보겠습니다.file 수준에서 대체 가능한 항목  webpack 공식문서 참고    const path = require(&#39;path&#39;);    module.exports = {        mode : &#39;development&#39;,        entry : {            main : &#39;./src/app.js&#39;        },        output : {            path : path.resolve(&#39;./dist&#39;),            filename : &#39;[name].js&#39;,            assetModuleFilename: &#39;images/[name][ext]&#39; // + 추가        },        module : {            rules : [                {                    test: /\\.css$/,                    use: [&#39;style-loader&#39;,&#39;css-loader&#39;]                },{                    test: /\\.(png|jpg)/,                    type: &#39;asset&#39;,                    parser: {                        dataUrlCondition: {                            maxSize: 10 * 1024 // 10kb                        }                    }                }            ]        }    }  ./dist/images/ 디렉토리에 생성된 것을 확인할 수 있습니다.  ./index.html을 열어서 개발자도구로 bg.jpg를 확인해보면 /iamges/[name][ext]로 되어있는 것을 확인할 수 있습니다."
  },
  
  {
    "title": "[Webpack] loader (1)",
    "url": "/posts/Webpack-03/",
    "categories": "Webpack",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2021-12-15 00:00:00 +0900",
    





    "snippet": "loader란로더는 파일을 다른언어(예:TypeScript)에서 javascript로 변환하거나 인라인 이미지를 데이터 URL로 로드할 수 있습니다. 로더를 사용하면 import javascript 모듈에서 직접 CSS, HTML 파일과 같은 작업을 수행할 수 있습니다.loader의 기능  로더는 Node.js에서 실행되며, 가능한 모든 작업을 수행할 수 있습니다.  로더를 연결할 수 있으며, 체인의 각 로더는 처리된 리소스에 변환을 적용합니다. 체인은 역순으로 실행됩니다. 첫 번째 로더의 결과를 다음 로더에 전달하는 식으로 진행합니다. webpack은 마지막 로더가 Javascript로 변환할 것으로 예상합니다.  플러그인은 로더에게 더 많은 기능을 제공합니다.loader의 사용애플리케이션에서 로더를 사용하는 방법은 두 가지 방법이 있습니다.  Configuration(권장) : webpack.config.js 파일에 로더를 지정합니다.  Inline : 각 import문에 명시적으로 지정합니다.webpack에서 권장하는 1번 방법만 포스팅하였습니다.Configuration(권장) 작성 방법  module.rules(배열)로 webpack 구성 내에서 여러 로더를 지정할 수 있습니다. 이 방법은 로더를 표시하는 간결한 방법이고 깨끗한 코드를 유지하는데 도움이 됩니다.  로더는 오른쪽에서 왼쪽으로(또는 아래에서 위로) 실행됩니다. 즉, 역순으로 실행됩니다예시 :    module.exports = {        module: {            rules: [                {                    test: /\\.css$/,                    use: [                    // 세 번쨰로 실행됩니다.                    { loader: &#39;style-loader&#39; },                    // 두 번쨰로 실행됩니다.                    {                        loader: &#39;css-loader&#39;,                        options: {                        modules: true                        }                    },                    // 첫 번쨰로 실행됩니다.                    { loader: &#39;sass-loader&#39; }                    ]                }            ]        }    };    module.exports = {        module: {            rules: [                {                    test: /\\.css$/,                    use: [                        &#39;style-loader&#39;, // 세 번쨰로 실행됩니다.                        &#39;css-loader&#39;, // 두 번쨰로 실행됩니다.                        &#39;sass-loader&#39; // 첫 번쨰로 실행됩니다.                    ]                }            ]        }    };작성 TIP  loader들을 단순하게 유지  체이닝을 활용,  모듈식 출력으로 내보내야 합니다. 로더 생성 모듈은 일반 모듈과 동일한 설게 원칙을 준수해야 합니다.  프로젝트의 루트가 이동할 때 해싱을 중단하므로 모듈 코드에 절대경로를 삽입하지 마세요.로더의 동작원리를 이해하기 위해 직접 만들어보기로더에 사용되는 모듈형식은 표준 모듈 시스템이 아닌 webpack에서 사용하는 모듈을 사용합니다.webpack.config.js에서test는 로딩에 적용할 파일 확장자를 지정합니다. .js 확장자를 갖는 파일을 모두 처리합니다.use는 test에서 적용한 파일들을 처리할 로드를 설정합니다. 방금 만든 myloader를 지정합니다.로더는 .js를 갖는 모든 파일을 읽어 함수 인자 content로 전달됩니다.전달받은 content에는 무엇이 있는지 확인해보기 위해 console.log를 찍어보겠습니다.    module.exports = function myloader(content){        console.log(&#39;content 시작&#39;);        console.log(content);        console.log(&#39;content 종료&#39;);        console.log(&#39;\\n&#39;);        return content;    }    const path = require(&#39;path&#39;);    module.exports = {        mode : &#39;development&#39;,        entry : {            main : &#39;./src/app.js&#39;        },        output : {            path : path.resolve(&#39;./dist&#39;),            filename : &#39;[name].js&#39;        },        module : {            rules : [{                test: /\\.js$/,                use: [path.resolve(&#39;./myloader.js&#39;)]            }]        }    }    import * as math from &#39;./math.js&#39;    console.log(math.sum(1, 2));    export function sum(a, b){        return a + b;    }    &amp;lt;!DOCTYPE html&amp;gt;    &amp;lt;html lang=&quot;en&quot;&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;        &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;body&amp;gt;        &amp;lt;script src=&quot;./dist/main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;    &amp;lt;/body&amp;gt;    &amp;lt;/html&amp;gt;webpack build :  webpack을 build 할 때 모든 .js 파일을 로드하여 myloader 모듈에 넘겨 변환 합니다.  첫 번쨰로, app.js를 content로 넘겨받아 리턴  두 번쨰로 math.js를 content로 넘겨받아 리턴    &amp;gt; npm run build   &amp;gt; webpack-demo@1.0.0 build    &amp;gt; webpack    content 시작    import * as math from &#39;./math.js&#39;    console.log(math.sum(1, 2));    content 종료    content 시작    export function sum(a, b){        return a + b;    }    content 종료    asset main.js 4.09 KiB [compared for emit] (name: main)    runtime modules 670 bytes 3 modules    cacheable modules 113 bytes    ./src/app.js 65 bytes [built] [code generated]    ./src/math.js 48 bytes [built] [code generated]    webpack 5.65.0 compiled successfully in 277 ms[.js] 소스코드 변환해보기  &quot;console.log(&quot; -&amp;gt; &quot;alart(&quot; 로 수정하여 알람창이 뜨게 수정해봅시다.    module.exports = function myloader(content){        console.log(&#39;content 시작&#39;);        console.log(content);        console.log(&#39;content 종료&#39;);        console.log(&#39;\\n&#39;);        return return content.replace(&quot;console.log(&quot;, &quot;alert(&quot;);    }결과 :"
  },
  
  {
    "title": "[Webpack] entry, output",
    "url": "/posts/Webpack-02/",
    "categories": "Webpack",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2021-12-14 00:00:00 +0900",
    





    "snippet": "webpack의 번들링 작업을 실행하는 방법은 2가지가 있습니다.  콘솔 실행  ./webpack.config.js 파일로 실행2가지 실행 방법과 결과에 대해 알아보겠습니다.프로젝트 구조 확인    webpack-demo        |- /moda_modules        |- package.json        |- package-lock.json        |- index.html        |- /src            |- app.js            |- math.js  번들링 결과의 예상 경로로 script 태그를 수정합니다.    &amp;lt;!DOCTYPE html&amp;gt;    &amp;lt;html lang=&quot;en&quot;&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;        &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;        &amp;lt;!-- type=modules 삭제, script 경로 수정 --&amp;gt;        &amp;lt;script src=&quot;./dist/main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;body&amp;gt;    &amp;lt;/body&amp;gt;    &amp;lt;/html&amp;gt;    import * as math from &#39;./math.js&#39;    console.log(math.sum(1, 2));    export function sum(a, b){        return a + b;    }콘솔 실행  entry : 번들링할 파일을 &quot;./src/app.js&quot; 로 설정  output : 결과가 저장될 경로를 &quot;./dist/&quot; 로 설정, default는 &quot;main.js&quot;로 생성됩니다.  mode : 개발모드로 진행할 것이기 때문에 &quot;development&quot; 로 설정  명령어 : &quot;.\\node_modules\\.bin\\webpack --mode development --entry ./src/app.js --output-path ./dist/&quot;    &amp;gt;.\\node_modules\\.bin\\webpack --mode development --entry ./src/app.js --output-path ./dist/     asset main.js 4.08 KiB [emitted] (name: main)    runtime modules 670 bytes 3 modules    cacheable modules 110 bytes    ./src/app.js 64 bytes [built] [code generated]    ./src/math.js 46 bytes [built] [code generated]    webpack 5.65.0 compiled successfully in 162 ms  결과물이 ./dist/main.js 경로에 생성된 것을 확인할 수 있습니다.  주의해야 할점! 4버전에서는 &quot;--output ./dist/main.js&quot; -&amp;gt; 경로/파일명.js 로 생성됐지만 5버전부터는 경로로 인식하는 것 같습니다.  따라서 &quot;./dist/main.js&quot;라고 입력하면  &quot;./dist/main.js(폴더)/main.js(js)&quot; 로 결과물이 생성됩니다.결과 :webpack.config.js 파일로 실행  기본적으로 webpack은 ./webpack.config.js 설정 파일이 있는지 찾고 있으면 파일을 읽습니다.      const path = require(&#39;path&#39;);  module.exports = {      mode : &#39;development&#39;,      entry : {          main : &#39;./src/app.js&#39;      },      output : {          path : path.resolve(&#39;./dist&#39;),          filename : &#39;[name].js&#39;      }  }        scripts에 build라는 명령어를 등록합니다. build 명령어는 webpack을 실행시킵니다.      {      &quot;name&quot;: &quot;webpack-demo&quot;,      &quot;version&quot;: &quot;1.0.0&quot;,      &quot;description&quot;: &quot;&quot;,      &quot;main&quot;: &quot;index.js&quot;,      &quot;scripts&quot;: {          &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;amp;&amp;amp; exit 1&quot;,          &quot;build&quot; : &quot;webpack&quot;      },      &quot;author&quot;: &quot;&quot;,      &quot;license&quot;: &quot;ISC&quot;,      &quot;devDependencies&quot;: {          &quot;webpack&quot;: &quot;^4.41.5&quot;,          &quot;webpack-cli&quot;: &quot;^3.3.10&quot;      }  }        &quot;npm run build&quot;로 webpack 실행    &amp;gt;npm run build    &amp;gt; webpack-demo@1.0.0 build    &amp;gt; webpack    asset main.js 4.09 KiB [emitted] (name: main)    runtime modules 670 bytes 3 modules    cacheable modules 113 bytes    ./src/app.js 65 bytes [built] [code generated]    ./src/math.js 48 bytes [built] [code generated]    webpack 5.65.0 compiled successfully in 203 ms  &quot;.\\node_modules\\.bin\\webpack&quot; 파일을 실행해도 결과는 같습니다.    &amp;gt;.\\node_modules\\.bin\\webpack    asset main.js 4.09 KiB [emitted] (name: main)    runtime modules 670 bytes 3 modules    cacheable modules 113 bytes    ./src/app.js 65 bytes [built] [code generated]    ./src/math.js 48 bytes [built] [code generated]    webpack 5.65.0 compiled successfully in 150 ms결과 :"
  },
  
  {
    "title": "[Webpack] 시작하기",
    "url": "/posts/Webpack-01/",
    "categories": "Webpack",
    "tags": "Webpack, Babel, Node.js, Javascript",
    "date": "2021-12-13 00:00:00 +0900",
    





    "snippet": "webpack을 다루기전에  모듈 시스템에 대한 이해가 수반되어야 합니다.  Node.js과 npm을 알아야 합니다.모듈 시스템을 모르신다면, 아래의 포스트를 먼저 보고 오시는 것을 추천드립니다.[Javascript] ES2015(ES6) 표준 모듈 시스템 (export, import)webpack이란Webpack은 오픈 소스 자바스크립트 모듈 번들러이다. 웹 어플리케이션 개발에 필요한 다양한 요소(HTML, CSS, Javascript, Images, Font 등 …)들을 하나의 파일로(혹은 여러개의 파일로) 병합 및 압축을 해주는 역할을 한다. 주요한 요소로는 Entry, Output, Loaders, Plugins, Mode, Browser Compatibility가 있다.웹팩의 필요성모듈 시스템은 모든 브라우저가 지원하지 않는다[Javascript] ES2015(ES6) 표준 모듈 시스템 (export, import) 내용에서 알 수 있듯이, 모듈 시스템은 모든 브라우저에서 지원하지 않습니다.Webpack은 브라우저와 무관하게 모듈을 사용할 수 있습니다.웹 애플리케이션의 로딩 속도와 성능 개선사용자들은 웹브라우저를 통해 애플리케이션을 접속할 수 있는데, 많은 리소스(js, images, css 등)들을 서버에 http 방식으로 요청하게 됩니다. 리소스들이 많을 수록 요청 수도 늘어나기 때문에속도와 성능이 저하될 수 밖에 없습니다. Webpack은 이런 문제들을 해결합니다.번들러 도구자바스크립트 개발에서는 JS, CSS, IMAGES, ES6와 이전 버전과의 호환을 해주는 트랜스 파일, 모듈 라이브러리 등 많은 로드 작업이 필요합니다. 이런 작업을 한 번에 해주는 번들러 도구가 Webpack입니다.npm 프로젝트 생성npm initnpm init은 node.js에서 사용하는 모듈들을 패키지로 관리하기 위해 package.json을 생성하여 Node 패키지에 관리 정보와 의존중인 버전에 관한 정보로 node.js에서 사용하는 모듈들을 패키지로 만들어서 관리하기 위해 사용하는 것입니다.  Working 디렉토리를 먼저 생성합니다.  &quot;npm init&quot; 로 프로젝트를 시작하게 되면, package name 부터 license 까지 입력할 수 있습니다. enter시 default값이 들어갑니다.  처음부터 default로 시작하고 싶으시면, &quot;npm init -y&quot; 로 생성합니다. -y는 yes의 약자로 default 패키지를 생성할 때 사용하는 옵션입니다.    mkdir webpack-demo    cd webpack-demo    npm init  npm을 통해 webpack과 webpack-cli을 설치합니다.  webpack 패키지는 webpack의 핵심 패키지이며, webpack-cli 패키지는 터미널에서 webpack 명령어를 실행할 수 있게 해주는 커맨드라인 도구입니다.  개발환경에서 필요한 의존성이므로 -D 옵션을 붙여 설치합니다.  package.json는 npm init으로 생기는 패키지입니다.  기본적으로 node package를 설치하게 되면 &quot;path/node_modules/&quot; 하단에 설치됩니다. 따라서, 최초 npm install시에 생성되며 그 이후로는 node_modules 하위에 패키지들이 설치됩니다.  package-lock.json은 node_modules 트리나 package.json 파일을 수정하게 되면 자동으로 생성됩니다. 이 파일은 파일이 생성되는 시점의 의존성 트리에 대한 정확한 정보를 가지고 있습니다.    seong@DESKTOP-O5CIEJV MINGW64 /e/study/frontend/webpack-demo (test)    $ ll    total 105    drwxr-xr-x 1 seong 197610     0 12월 14 17:05 node_modules/    -rw-r--r-- 1 seong 197610   290 12월 14 17:05 package.json    -rw-r--r-- 1 seong 197610 89604 12월 14 17:05 package-lock.jsonpackage.json 구조 파악하기    {        &quot;name&quot;: &quot;webpack-demo&quot;,        &quot;version&quot;: &quot;1.0.0&quot;,        &quot;description&quot;: &quot;&quot;,        &quot;main&quot;: &quot;index.js&quot;,        &quot;scripts&quot;: {            &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;amp;&amp;amp; exit 1&quot;        },        &quot;author&quot;: &quot;&quot;,        &quot;license&quot;: &quot;ISC&quot;,        &quot;devDependencies&quot;: {            &quot;webpack&quot;: &quot;^5.65.0&quot;,            &quot;webpack-cli&quot;: &quot;^4.9.1&quot;        }    }devDependencies :  설치된 npm 패키지들은 devDependencies 항목에서 관리됩니다.scripts :  scripts 항목에 다양한 명령어들을 설정하여 콘솔에서 사용할 수 있습니다.  보통 npm run [명령어]로 스크립트 명령어를 실행합니다.  test, start는 npm test, npm start로 실행합니다.디렉토리 구조 생성  현재는 모듈 시스템 기반으로 script를 로드합니다.    webpack-demo        |- /moda_modules        |- package.json        |- package-lock.json     +  |- index.html     +  |- /src     +      |- app.js     +      |- math.js    &amp;lt;!DOCTYPE html&amp;gt;    &amp;lt;html lang=&quot;en&quot;&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;        &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;body&amp;gt;        &amp;lt;script type=&quot;module&quot; src=&quot;./src/app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;    &amp;lt;/body&amp;gt;    &amp;lt;/html&amp;gt;    import * as math from &#39;./math.js&#39;    console.log(math.sum(100,200));    export function sum(a, b){        return a+b;    }webpack의 주요 요소  --help 옵션을 통해 webpack 사용 방법을 확인해봅시다.  &quot;node_modules\\.bin\\webpack --help&quot; 입력  –mode, –entry, –output-path(-o) 옵션을 사용해서 웹팩으로 번들링 작업을 수행할 수 있습니다.    E:\\study\\frontend\\webpack-demo&amp;gt;.\\node_modules\\.bin\\webpack --help        Usage: webpack [entries...] [options]    Alternative usage to run commands: webpack [command] [options]    The build tool for modern web applications.    Options:    -c, --config &amp;lt;value...&amp;gt;                Provide path to a webpack configuration file e.g. ./webpack.config.js.    --config-name &amp;lt;value...&amp;gt;               Name of the configuration to use.    -m, --merge                            Merge two or more configurations using &#39;webpack-merge&#39;.    --env &amp;lt;value...&amp;gt;                       Environment passed to the configuration when it is a function.            --node-env &amp;lt;value&amp;gt;                     Sets process.env.NODE_ENV to the specified value.    --progress [value]                     Print compilation progress during build.    -j, --json [value]                     Prints result as JSON or store it in a file.    -d, --devtool &amp;lt;value&amp;gt;                  Determine source maps to use.    --no-devtool                           Do not generate source maps.    --entry &amp;lt;value...&amp;gt;                     The entry point(s) of your application e.g. ./src/main.js.    --mode &amp;lt;value&amp;gt;                         Defines the mode to pass to webpack.    --name &amp;lt;value&amp;gt;                         Name of the configuration. Used when loading multiple configurations.     -o, --output-path &amp;lt;value&amp;gt;              Output location of the file generated by webpack e.g. ./dist/.            --stats [value]                        It instructs webpack on how to treat the stats e.g. verbose.    --no-stats                             Disable stats output.    -t, --target &amp;lt;value...&amp;gt;                Sets the build target e.g. node.    --no-target                            Negative &#39;target&#39; option.    -w, --watch                            Watch for files changes.    --no-watch                             Do not watch for file changes.    --watch-options-stdin                  Stop watching when stdin stream has ended.    --no-watch-options-stdin               Do not stop watching when stdin stream has ended.    ... (생략)webpack.config.js  webpack의 기본 설정파일입니다. --help 옵션에서 알 수 있듯이 ./webpack.config.js 로 만들어서 사용합니다.mode  webpack의 실행 모드를 설정합니다.  production : 운영모드  development : 개발모드  none : 기본 최적화 모드entry  webpack 번들링의 시작점입니다. 쉽게 말해 webpack 번들링 하고 싶은 자바스크립트 파일 경로들을 선언합니다.  webpack은 entry 속성을 기준으로 번들링하기 때문에 웹 어플리케이션의 전반적인 구조와 내용이 있어야 합니다.  그 이유는, entry에 선언된 자바스크립트 파일을 기준으로 웹 어플리케이션에서 사용되는 모듈들의 연관 관계를 이해하고 분석하기 때문입니다.output  webpack 번들링의 결과물이 저장되는 경로를 선언합니다.loader  webpack은 자바스크립트 파일뿐만 아니라 모든 파일을 모듈로 바라볼 수 있습니다.  CSS, HTML, FONT, IMAGES 등 전부 모듈로 보기 때문에 import 구문을 사용하여 자바스크립트 코드안으로 가져올 수 있습니다. 이게 가능한 이유가 loader 때문입니다.plugin  loader는 파일 단위로 처리하지만 plugin은 번들된 결과물을 처리합니다.  보통 번들된 자바스크립트를 난독화(읽기 어렵게) 한다거나 텍스트를 추출하는 용도로 사용됩니다."
  },
  
  {
    "title": "[Git] Git 되돌리기(undo)",
    "url": "/posts/git-04/",
    "categories": "Git",
    "tags": "Git, Github",
    "date": "2021-12-12 00:00:00 +0900",
    





    "snippet": "개발을 하다보면 이전으로 되돌려야 하는 상황이 오기 마련입니다.Git에서도 undo의 기능을 제공합니다.commit 재작성  방금 commit하고 나서, 너무 일찍 commit 했거나 파일을 뺴먹었거나 commit 메시지를 잘못 입력했을 경우 사용합니다.  --amend 옵션을 사용하여 커밋을 재작성 할 수 있습니다.  다시 commit을 하고 싶으면, [파일을 수정후] -&amp;gt; [Staging Area에 추가] -&amp;gt; [git commit --amend] -&amp;gt; [재작성 후 저장하면 끝]  --amend 옵션으로 커밋을 고치는 작업은, 추가로 작업한 일이 작다고 하더라도 이전의 커밋을 완전히 새로 고쳐서 새 커밋으로 변경합니다.  따라서, 이전의 커밋을 일어나지 않은 일이 되고 당연히 히스토리에도 남지 않습니다.  --amend 옵션의 장점은 아주 작게 뭔가를 빠드리거나, 변경한 것을 새 커밋으로 분리하지 않고 하나의 커밋으로 처리하는 것입니다.        // test01.py 파일 생성        $ vi test01.py        // test02.py 파일 생성        $ vi test01.py        // test01.py만 Staging Area에 추가후 commit 진행        $ git add test01.py        $ git status        On branch test        Your branch is up to date with &#39;origin/test&#39;.        Changes to be committed:        (use &quot;git restore --staged &amp;lt;file&amp;gt;...&quot; to unstage)                new file:   test01.py        $ git commit -m &quot;new test01.py&quot;        [test 17156f0] new test01.py        1 file changed, 0 insertions(+), 0 deletions(-)        create mode 100644 test01.py        // 엇?! test02.py 파일도 같이 commit 해야 하므로 --amend 옵션 사용        // 먼저 test02.py 파일을 Staging Area에 추가        $ git add test02.py        $ git commit --amend                // git commit --amend를 하게 되면 바로 이전 commit 을 재작성할 수 있습니다.        // commit 메시지를 &quot;new test01.py&quot; -&amp;gt; &quot;new test01.py test02.py&quot; 로 변경 후 저장        new test01.py test02.py        # Please enter the commit message for your changes. Lines starting        # with &#39;#&#39; will be ignored, and an empty message aborts the commit.        #        # Date:      Mon Dec 13 11:09:51 2021 +0900        #        # On branch test        # Your branch is ahead of &#39;origin/test&#39; by 1 commit.        #   (use &quot;git push&quot; to publish your local commits)        #        # Changes to be committed:        #       new file:   test01.py        #       new file:   test02.py        #        # Untracked files:        #       sample_01/                // 히스토리를 확인해보면 변경된 것을 확인할 수 있습니다!        $ git log        commit 4893401cd6b8723d49bfad2d6ae906d85f674c36 (HEAD -&amp;gt; test)        Author: s-seongsik &amp;lt;52439201+s-seongsik@users.noreply.github.com&amp;gt;        Date:   Mon Dec 13 11:09:51 2021 +0900        new test01.py test02.pyUnstage로 변경하기  Working 디렉토리 &amp;lt;-&amp;gt; Staging Area 사이를 넘나드는 방법입니다.  Working 디렉토리 -&amp;gt;  Staging Area에 추가하는 방법은 &quot;git add [filename]&quot; 으로 알고 있습니다.  반대로 Unstage 상태로 되돌리기 위해서는 &quot;git restore --staged [filename]&quot;을 사용합니다.          // git test01.py을 수정한뒤 상태를 확인      $ git status      On branch test      Your branch is ahead of &#39;origin/test&#39; by 1 commit.      (use &quot;git push&quot; to publish your local commits)      Changes not staged for commit:      (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)      (use &quot;git restore &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)              modified:   test01.py      // Staging Area에 추가      // 상태를 확인해보면 Staging Area에 추가된 것을 확인할 수 있습니다.      $ git add test01.py      $ git status      On branch test      Your branch is ahead of &#39;origin/test&#39; by 1 commit.      (use &quot;git push&quot; to publish your local commits)      Changes to be committed:      (use &quot;git restore --staged &amp;lt;file&amp;gt;...&quot; to unstage)              modified:   test01.py      // 다시 Unstage 상태로 되돌리기      // 상태를 확인해보면 Unstage 상태로 돌아간 것을 확인할 수 있습니다.      $ git restore --staged test01.py              $ git status      On branch test      Your branch is ahead of &#39;origin/test&#39; by 1 commit.      (use &quot;git push&quot; to publish your local commits)      Changes not staged for commit:      (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)      (use &quot;git restore &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)              modified:   test01.py      변경사항 취소하기  modified된 파일을 취소하는 방법입니다.  &quot;git restore [filename]&quot;  해당 명령어는 변경된 사항을 취소하여 이전으로 되돌립니다.        // 위에 Unstage로 변경된 test01.py의 상태를 확인해보시면        // (use &quot;git restore &amp;lt;file&amp;gt;...&quot; to discard changes in working directory) 라는 문구를 확인할 수 있습니다.        // 해당 명령어로 Working 디렉토리에서 변경사항을 취소할 수 있다고 되어있습니다.        // 한번 실행해 보겠습니다.        $ git status        On branch test        Your branch is ahead of &#39;origin/test&#39; by 1 commit.        (use &quot;git push&quot; to publish your local commits)        Changes not staged for commit:        (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)        (use &quot;git restore &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)                modified:   test01.py        // 참고로 test01.py 파일에는 x=10이라는 코드가 들어있습니다.        // 상태에서는 사라진 것을 확인할 수 있습니다.        $ git restore test01.py        $ git status        On branch test        Your branch is ahead of &#39;origin/test&#39; by 1 commit.        (use &quot;git push&quot; to publish your local commits)        // test01.py에서 변경된 내용이 취소되었는지 확인해보겠습니다.        // 아무것도 없던 이전으로 돌아간 것을 확인할 수 있습니다!        $ vi test01.py        [test01.py]        ~        ~        ~        ~        ~        ~        ~        ~        test01.py [unix] (11:41 13/12/2021)                        0,0-1 모두        &quot;test01.py&quot; 0L, 0C"
  },
  
  {
    "title": "[Javascript] ES2015(ES6) 표준 모듈 시스템 (export, import)",
    "url": "/posts/javascript-02/",
    "categories": "Javascript",
    "tags": "Javascript, ES6",
    "date": "2021-12-08 00:00:00 +0900",
    





    "snippet": "표준 모듈 시스템의 등장 배경모듈 시스템이 없었던 자바스크립트 환경은 html 헤더에 script 태그를 명시하여 js를 순서대로 불러오는 방법을 사용했습니다. 이러한 방식은 여러가지 문제점을 발생시켰습니다. 그 중 가장 문제점은 전역 스코프가 충돌 된다는 것입니다.그 이유는, script로 태그된 js파일들을 로드할 때 함수와 변수가 전역 공간에 노출되기 때문입니다.  math.js에 sum이라는 함수를 만들고, app.js에서 console.log로 찍어보겠습니다.  html에서는 math.js -&amp;gt; app.js 순서대로 불러오겠습니다.  웹서버를 하나 띄어서 개발자 도구로 log가 찍히는지 확인해보겠습니다.    &amp;lt;!DOCTYPE html&amp;gt;    &amp;lt;html lang=&quot;en&quot;&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;        &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;body&amp;gt;        &amp;lt;script src=&quot;src/math.js&quot;&amp;gt;&amp;lt;/script&amp;gt;        &amp;lt;script src=&quot;src/app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;    &amp;lt;/body&amp;gt;    &amp;lt;/html&amp;gt;    function sum(input1, input2){        return input1+input2;    }    console.log(math.sum(10,20));결과 : console log에 30이 찍힌 것을 확인할 수 있습니다. 또한 sum 함수를 전역함수로 사용할 수 있습니다.모듈 시스템 이전의 문제점문제1 : 설계 및 개발 완료 후 테스트를 진행하므로, 잘못된 설계 및 개발코드의 재수정 필요  app.js와 math.js 태그 순서를 바꿔본다.    &amp;lt;!DOCTYPE html&amp;gt;    &amp;lt;html lang=&quot;en&quot;&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;        &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;body&amp;gt;        &amp;lt;script src=&quot;src/app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;        &amp;lt;script src=&quot;src/math.js&quot;&amp;gt;&amp;lt;/script&amp;gt;    &amp;lt;/body&amp;gt;    &amp;lt;/html&amp;gt;결과 : app.js을 먼저 로드할 때 app.js 입장에서는 sum이라는 함수가 정의되어 있지 않기 사용할 수 없습니다.문제2 : 전역 스코프 충돌  app.js 에 sum 함수를 정의해 줍니다.    function sum(input1, input2){        return input1+input2;    }    sum = function(input1,input2){        return input1 - input2;    }    console.log(sum(10,20));결과 : math.js에서 선언한 sum 함수가, 나중에 호출된 app.js sum 함수로 재정의 되어 실행된 것을 확인할 수 있습니다.이렇듯, js가 로드되는 순서와 변수와 함수가 전역 공간에 노출되기 때문에 같은 각기 다른 js에서 동일한 이름으로 선언한다면 충돌이 발생하게 된다.이런 문제들을 해결하고자 모듈화 방법들이 나오게 되었다.ES2015(ES6) 표준 모듈 시스템대표적인 명세인 AMD와 CommonJS가 있지만, 서로 다른 스펙을 제안하기 때문에 이를 통합하고자 ES2015(ES6) 표준 모듈 시스템이 등장하게 되었다.export참고자료  javascript 모듈에서 함수, 객체, 원시 값을 내보낼 때 사용합니다.  export된 값은 다른 프로그램에서 import로 사용할 수 있습니다.  내보내는 모듈은 “use strict”의 존재 유무와 상관없이 무조건 엄격 모드입니다.  HTML 안에 작성된 스크립트에서는 사용할 수 없습니다.  내보내기 방법은 named, default 내보내기가 있습니다.  모듈 하나에서 named 내보내기는 여러 개 존재할 수 있지만, default 내보내기는 하나만 가능합니다.export named    &amp;lt;!DOCTYPE html&amp;gt;    &amp;lt;html lang=&quot;en&quot;&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;        &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;body&amp;gt;        &amp;lt;script type=&quot;module&quot; src=&quot;src/import.js&quot;&amp;gt;&amp;lt;/script&amp;gt;    &amp;lt;/body&amp;gt;    &amp;lt;/html&amp;gt;  내보낼 식별자 이름을 명시해서 내보냅니다.  export { cube, foo, graph }    function cube(x) {        return x * x * x;    }    const foo = Math.PI + Math.SQRT2;    var graph = {        options: {            color:&#39;white&#39;,            thickness:&#39;2px&#39;        },        draw: function() {            console.log(&#39;From graph draw function&#39;);        }    }    // 내보낼 식별자 이름을 사용하여 export 합니다.    export { cube, foo, graph };    import { cube, foo, graph } from &#39;./export.js&#39;;    console.log(graph.options); // {color:&#39;white&#39;, thickness:&#39;2px&#39;}    graph.options = {        color:&#39;blue&#39;,        thickness:&#39;3px&#39;    };    console.log(graph.options); // {color:&#39;blue&#39;, thickness:&#39;3px&#39;}    graph.draw(); // From graph draw function    console.log(cube(3)); // 27    console.log(foo);    // 4.555806215962888결과 : export default  export default에서 var, let, const는 사용할 수 없습니다.    &amp;lt;!DOCTYPE html&amp;gt;    &amp;lt;html lang=&quot;en&quot;&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;        &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;body&amp;gt;        &amp;lt;script type=&quot;module&quot; src=&quot;src/import.js&quot;&amp;gt;&amp;lt;/script&amp;gt;    &amp;lt;/body&amp;gt;    &amp;lt;/html&amp;gt;    export default function cube(x) {        return x * x * x;    }    import cube from &#39;./export.js&#39;;    console.log(cube(3)); // 27결과 : import참고자료  다른 모듈에서 내보낸 바인딩을 가져올 때 사용합니다.  내보내는 모듈은 “use strict”의 존재 유무와 상관없이 무조건 엄격 모드입니다.  HTML 안에 작성한 스크립트에서는 import를 사용할 수 없습니다.  함수형 구문을 가진 동적 import()도 있으며, type=”module”를 필요로 하지않습니다.  동적 가져오기는 모듈을 조건적, 필요할 때에 유용합니다.  초기 의존성을 불러올 때엔 정적 가져오기가 더 좋습니다.export named -&amp;gt; import   // export한 모든 것들은 myModule로 바인딩 되어 들어갑니다. 별칭으로 이해하는게 쉽겠네요.   import * as myModule from &quot;my-module.js&quot;;   // export한 모듈에서 하나의 멤버만 가져옵니다.   import {myMember} from &quot;my-module.js&quot;;   // export한 모듈에서 여러 개의 멤버를 가져옵니다.   import {foo, bar} from &quot;my-module.js&quot;;   // export한 모듈에서 멤버를 가져오고, 별칭을 사용하여 좀더 편리한 name으로 사용합니다.   import {reallyReallyLongModuleMemberName as shortName} from &quot;my-module.js&quot;;   // export한 모듈에서 여러 개의 멤버를 가져오고, 별칭을 사용하여 좀더 편리한 name으로 사용합니다.   import {reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short} from &quot;my-module.js&quot;;   // 어떠한 바인딩 없이 모듈 전체를 가져옵니다.   import &quot;my-module.js&quot;;default export -&amp;gt; import   // default를 가져오는 가장 간단한 방법입니다.   import myModule from &quot;my-module.js&quot;;   // default와 named를 함께 사용할 수 있습니다. 단, default를 먼저 선언해야 합니다.   // myModule used as a namespace   import myDefault, * as myModule from &quot;my-module.js&quot;;    import myDefault, {foo, bar} from &quot;my-module.js&quot;;브라우저 호환성exportimport"
  },
  
  {
    "title": "[Node.js] 시작하기",
    "url": "/posts/Node.js-02/",
    "categories": "Node.js",
    "tags": "Node.js, Javascript",
    "date": "2021-12-08 00:00:00 +0900",
    





    "snippet": "npm이란?npm은 Node Package Manager의 약자로 자바스크립트 프로그래밍 언어를 위한 패키지 관리자입니다. 즉, npm은 node.js에서 사용하는 모듈들을 패키지로 관리 및 배포하는 역할을 합니다.Node.js 설치  사용자의 운영체제에 맞게 다운로드 합니다.  [Node.js 홈페이지]](https://nodejs.org/ko/)  짝수버전(왼쪽), 홀수버전(오른쪽)이 있는데 짝수버전은 안정성과 신뢰성을 지원하는 버전으로 실제 서버에 배포용으로 사용할 때 사용하고 홀수버전은 최신 기능을 지원하므로 개발용으로 사용한다.  개발용으로 사용할 것이므로 오른쪽 버전을 다운로드 합니다.  2021-12-08 기준, 17.2.0 최신버전  터미널을 실행하여 node.js가 잘 설치되었는지 확인합니다.  저는 윈도우에서 실행했습니다.    C:\\Users\\seong&amp;gt;node    Welcome to Node.js v17.2.0.    Type &quot;.help&quot; for more information.    &amp;gt;  웹 브라우저 없이 JavaScript를 실행할 수 있습니다!  javaScript가 작동하는지 테스트 해보겠습니다.  ES6 문법인 const가 잘 작동됩니다.  const의 재사용이 안되는 것까지 잘되네요!    C:\\Users\\seong&amp;gt;node    Welcome to Node.js v17.2.0.    Type &quot;.help&quot; for more information.    &amp;gt; const x = 30;    undefined    &amp;gt; x    30    &amp;gt; x = 10;    Uncaught TypeError: Assignment to constant variable.    &amp;gt;  node.js의 버전을 확인합니다.      C:\\Users\\seong&amp;gt;node --version  v17.2.0        npm의 버전을 확인합니다.      C:\\Users\\seong&amp;gt;npm --version  v17.2.0        npm 을 입력합니다.  npm --version 처럼 명령어 사용방법에 대해 알려줍니다.      C:\\Users\\seong&amp;gt;npm  npm &amp;lt;command&amp;gt;  Usage:  npm install        install all the dependencies in your project  npm install &amp;lt;foo&amp;gt;  add the &amp;lt;foo&amp;gt; dependency to your project  npm test           run this project&#39;s tests  npm run &amp;lt;foo&amp;gt;      run the script named &amp;lt;foo&amp;gt;  npm &amp;lt;command&amp;gt; -h   quick help on &amp;lt;command&amp;gt;  npm -l             display usage info for all commands  npm help &amp;lt;term&amp;gt;    search for help on &amp;lt;term&amp;gt; (in a browser)  npm help npm       more involved overview (in a browser)  All commands:      access, adduser, audit, bin, bugs, cache, ci, completion,      config, dedupe, deprecate, diff, dist-tag, docs, doctor,      edit, exec, explain, explore, find-dupes, fund, get, help,      hook, init, install, install-ci-test, install-test, link,      ll, login, logout, ls, org, outdated, owner, pack, ping,      pkg, prefix, profile, prune, publish, rebuild, repo,      restart, root, run-script, search, set, set-script,      shrinkwrap, star, stars, start, stop, team, test, token,      uninstall, unpublish, unstar, update, version, view, whoami  Specify configs in the ini-formatted file:      C:\\Users\\seong\\.npmrc  or on the command line via: npm &amp;lt;command&amp;gt; --key=value  More configuration info: npm help config  Configuration fields: npm help 7 config  npm@8.1.4 C:\\Program Files\\nodejs\\node_modules\\npm      프로젝트 생성 해보기  프로젝트를 생성할 폴더(폴더명 : sample_01)를 만들어 줍니다.  저는 E:\\study\\frontend 위에 만들었습니다.  생성된 폴더에 이동합니다.      E:\\study\\frontend&amp;gt;mkdir sample_01  E:\\study\\frontend&amp;gt;dir      E 드라이브의 볼륨: seongsik      볼륨 일련 번호: 1819-824F      E:\\study\\frontend 디렉터리      2021-12-08  오후 05:04    &amp;lt;DIR&amp;gt;          .      2021-12-08  오후 05:04    &amp;lt;DIR&amp;gt;          ..      2021-12-08  오후 05:04    &amp;lt;DIR&amp;gt;          sample_01                  0개 파일                   0 바이트                  3개 디렉터리  14,627,414,016 바이트 남음      E:\\study\\frontend&amp;gt;cd sample_01  E:\\study\\frontend\\sample_01&amp;gt;        프로젝트 생성하기 : npm init  package name, version, description … 입력란이 나오지만 전부 엔터  package name defalut는 폴더명입니다.      E:\\study\\frontend\\sample_01&amp;gt;npm init  This utility will walk you through creating a package.json file.  It only covers the most common items, and tries to guess sensible defaults.  See `npm help init` for definitive documentation on these fields  and exactly what they do.  Use `npm install &amp;lt;pkg&amp;gt;` afterwards to install a package and  save it as a dependency in the package.json file.  Press ^C at any time to quit.  package name: (sample_01)  version: (1.0.0)  description:  entry point: (index.js)  test command:  git repository:  keywords:  author:  license: (ISC)  About to write to E:\\study\\frontend\\sample_01\\package.json:  {  &quot;name&quot;: &quot;sample_01&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: {      &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;amp;&amp;amp; exit 1&quot;  },  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;  }  Is this OK? (yes)        sample_01 폴더 밑에 package.json 파일이 생성되었습니다.  해당 파일을 실행해보면 프로젝트 정보들이 들어있습니다."
  },
  
  {
    "title": "[Javascript] ECMAScript?, ES6? 개념 이해",
    "url": "/posts/javascript-01/",
    "categories": "Javascript",
    "tags": "Javascript, ES6",
    "date": "2021-12-07 00:00:00 +0900",
    





    "snippet": "Javascript란?JavaScript는 1995년 넷스케이프(Netscape) 웹 브라우져에서 웹페이지에 동적인 요소를 구현하기 위해서 발명 되었다. 그 후 많은 다른 웹 브라우져들 또한 이 언어를 탑재하기 시작했고, 그 결과로 현대의 웹 어플리케이션의 구현을 가능하게 만든 언어이다. 이 언어로 인해 웹 어플리케이션에서 더 이상 사용자가 페이지 새로고침 또는 페이지를 새로 불러오지 않고도 웹과 직접적인 연결이 가능하게 되었다.예를들어 웹페이지에서 click 이벤트와 같은 동적 요소들이 javascript이며, html css를 정적인 요소라 할 수 있다.ESMAScript란?  JavaScript는 1995년 Brendan Eich에 의해 발명되었으며 1997년 ECMA 표준이 되었습니다.  ECMAScript는 언어의 공식 이름입니다.  ECMAScript 버전은 ES1, ES2, ES3, ES5 및 ES6으로 축약되었습니다.  2016년부터 새 버전의 이름은 연도별로 지정됩니다(ECMAScript 2016/2017/2018). 즉, 자바스크립트 언어 표준을 말합니다. (파이썬 2.x, 3.x 과 같은 버전으로 이해하면 될 것 같습니다.)ESMAScript Editions참고자료 : https://www.w3schools.com/js/js_versions.asp브라우저 지원  ES6부터는 Internet Explorer를 아예 지원 안한다고 되어있습니다.  ES5는 Internet Explorer 9를 지원하지 않으며, ES6부터는 Internet Explorer를 지원하지 않습니다.ESMAScript 표준을 알아야 하는 이유모든 언어가 그렇듯, release 버전을 이해하는 것은 굉장히 중요합니다. python을 예로 들자면 버전별로 지원하는 라이브러리와 문법들이 다르기 때문에 한 번 python2.xx로 개발하게 되면 나중에 python3.xx에서 지원하는 라이브러리를 사용하고 싶어도 못쓰는 경우가 발생하게 됩니다. 따라서, 표준을 아는 것은 굉장히 중요하다 할 수 있습니다.다시 돌아와서 현재 가장 널리 쓰이는 표준은 ES5(2009)입니다. ES6(2015)은 이제 널리 사용되고 있는 현재진행형입니다. 아직까지도 ES5표준을 많이 사용하기 때문에 ES6를 선뜻 바꾸기가 어려울 수 있습니다.이러한 괴리감을 해결하기 위해 나온 것이 Babel 과 같은 트랜스컴파일러 입니다. Babel은 ECMAScript 2015+ 코드를 이전 JavaScript 엔진에서 실행할 수 있도록 변환해줍니다. 정확하게 얘기하면 ES6로 작성된 JavaScript 언어를 이전 버전의 JavaScript 언어로 변환해주는 것입니다.Webpack과 Babel과 같은 기술들을 무작정 습득하기 보다는 해당 기술들이 나온 배경들을 이해하는 것이 어쩌면 더 중요할 수 있습니다.현재 Webpack과 Babel을 공부하고 있지만, 이게 왜 써야 되는지? 어떤 도움이 되는지 이해할 필요성을 느꼈기 때문에 ESMAScript에 대해 포스팅하게 되었습니다.마무리다음에는 JavaScript의 Scope와, ES6 표준 문법에 대해 포스팅 해보도록 하겠습니다."
  },
  
  {
    "title": "[Node.js] 개념 이해하기",
    "url": "/posts/Node.js-01/",
    "categories": "Node.js",
    "tags": "Node.js, Javascript",
    "date": "2021-12-07 00:00:00 +0900",
    





    "snippet": "Node.js란  Node.js는 Chrome V8 JavaScript 엔진으로 빌드 된 JavaScript 런타임입니다.  Node.js는 이벤트 기반, 논 블로킹 I/O 모델을 사용해 가볍고 효율적입니다.  Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.Node.js는 백엔드 vs 프론트엔드 ?  JavaScript 런타임(runtime)을 이해 할 필요가 있다. 런타임(runtime)이란 특정 언어로 만든 프로그램을 실행시킬 수 있는 환경을 뜻한다.  즉, Node.js는 javaScript 한 가지 언어로 Server와 Client를 모두 구현할 수 있는 환경을 제공하는 백엔드이다.  JavaScript는 java, python 등과 같은 독립적인 언어가 아닌 스크립트 언어입니다.  스크립트 언어는 웹 브라우저 환경에서만 돌아가기 때문에 웹 브라우저가 없으면 사용할 수 없었습니다.  하지만! Node.js가 탄생하게 되면서 JavaScript를 독립적인 언어로 사용할 수 있게 되었습니다.JavaScript 런타임이란?  런타임이란, 프로그래밍 언어가 실행되는 환경을 말합니다.  JavaScript 런타임이란, JavaScript가 실행되는 환경을 말합니다.  JavaScript 런타임은 기본적으로 웹 브라우저입니다.(현재 Node.js 추가)  Node.js가 나타난 뒤로 웹 브라우저 없이도 JavaScript를 실행시킬 수 있습니다.Chrome V8 엔진이란?  v8은 오픈 소스 자바스크립트 엔진입니다.  구글 크롬 브라우저와 안드로이드 브라우저에 탑재되어 있습니다.  ECMAScript(ECMA - 262) 3rd Edition 규격의 C++로 작성되었으며, 독립적으로 실행이 가능합니다.  V8은 자바스크립트를 바이트코드(bytecode)로 컴파일하고 실행하는 방식을 사용한다.(JIT 컴파일)V8엔진이 나온 가장 큰 배경은 JavaScript 속도개선 입니다. JavaScript는 인터프리터 방식으로 구동됩니다.우선, 인터프리터(Interpreter) 방식과 컴파일러(Compiler) 방식이 무엇인지 알아야겠죠?컴퓨터는 기본적으로 기계어만 이해할 수 있도록 만들어졌습니다. 따라서 어셈블리어나 고급언어로 작성된 코드들은 컴퓨터가 이해할 수 있는 기계어로 번역되어야 컴퓨터에서 실행됩니다.고급언어로 작성된 원시 프로그램을 기계어로 변역하는 방식은 컴파일러(Compiler) 방식과 인터프리터(Interpreter) 방식으로 구분됩니다.컴파일러 방식  고급언어로 작성된 코드 전체를 런타임 이전에 기계어로 변환해 주는 방식을 말합니다.  런타인 이전에 전체 코드를 기계어로 변환하기 때문에 시간이 오래 걸립니다.  런타임 이전에 전체 코드를 해석하여 기계어로 전환되기 때문에 OS 및 빌드환경에 종속적입니다.  대표적으로, C, C++이 있습니다.  구동시 시스템으로부터 메모리를 할당받으며, 할당받은 메모리를 사용합니다.인터프리터 방식  컴파일러 방식과 반대로 런타임 이후에 코드를 한 줄 씩 해석하여 실행시키는 방식을 말합니다.  한 줄씩 해석-&amp;gt;번역-&amp;gt;실행 하기 때문에 수정한 내용이 바로 반영되는 장점이 있습니다.  고급언어를 기계어로 바로 번역하지않고 런타임 이후에 해석-&amp;gt;실행 하기 때문에 컴파일러 방식보다 속도가 느립니다.  메모리를 별도로 할당받지 않기 때문에, 필요시 따로 할당해야합니다.  대표적으로 JavaScript, python이 있습니다.다시 본론으로 돌아와서 JavaScript는 인터프리터 방식으로 구동되기 때문에, 코드가 많아 질수록 속도가 느려지는 단점이 있습니다.V8 엔진은 느린 속도를 개선하고자 인터프리터 방식이 아닌 JIT(Just-In-Time)컴파일러를 적용하여 단점을 보완했습니다.JIT(Just-In-Time)컴파일러  실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지합니다.  JIT(Just-In-Time)컴파일러는 인터프리터 방식의 단점을 보완하기 위해 도입되었습니다.  다시말해, 실행시점에 인터프리터 방식으로 기계어 코드를 생성해서 캐시에 저장해 두었다가, 재사용시 컴파일을 다시 할 필요 없이 사용할 수 있습니다.  인터프리터 언어는 바이트코드나 소스코드를 최적화 과정 없이 변역하기 때문에 성능이 낮고, 정적 언어는 실행 전에 무조건 컴파일 해야하기 때문에 다양한 플랫폼에 맞게 컴파일 하려면 시간이 오래 걸립니다.  JIT(Just-In-Time)컴파일러는 정적 컴파일러 만큼 속도가 빠르고, 인터프리터 언어의 빠른 응답속도를 추구하기 위해 만들어 졌습니다. 즉, 컴파일러 방식과 인터프리터 방식을 혼합해 만들었습니다.이벤트 기반 비동기 방식클라이언트의 요청이 많은 서버의 경우 병목 현상이 발생하게 됩니다. 병목현상의 주 원인은 프로그램 로직보다는 입출력(I/O)에서 발생하게 됩니다. 통계자료에 따르면 I/O에 소요되는 비용 중 가장 많이 소요되는 비용은 Network와 Disk 라고 합니다.서버에서 I/O를 처리하다가 지연이 발생하면 다른 요청들을 처라히지 못하고 계속 대기하게 되는데 이런 현상을 병목현상이라 합니다.그렇기 때문에, 대부분의 기업들이 멀티 쓰레드 기반으로 사용자들의 요청을 처리하고 있습니다.멀티 쓰레드 방식은 요청이 올때마다 쓰레드를 발생시켜 처리합니다. 만약 동시에 대규모의 요청이 들어오게 되면 이에 대응되는 많은 쓰레드를 발생시키게 되는데 이는 많은 자원을 소모하게 됩니다.서버의 자원은 무한하지 않기 때문에 제한을 받게 됩니다.이런 문제들 때문에 이벤트 기반, Non-Blocking I/O모델을 사용하는 Node.js가 사랑받고 있는 것 같습니다.이벤트 기반 비동기 방식을 이해하기 전에 아래의 내용을 이해하는게 중요합니다.  Blocking I/O  Non-Blocking I/O  프로세스  프로그램  스레드  멀티스레드  비동기 처리Blocking I/O대부분의 프로그램은 Blocking I/O 모델을 사용합니다. Blocking I/O란 어떤 프로세스가 어떤 자원을 점유해 사용하고 있다면, 다른 프로세스는 해당 자원이 끝날 때 까지 대기해야 사용할 수 있습니다.예를들어  어플레케이션 -&amp;gt; 운영체제(커널) 파일 읽기를 요청  운영체제(커널) I/O 처리 시작 -&amp;gt; 다른 프로세스가 이미 사용중 -&amp;gt; 대기  대기가 끝나고 I/O처리 완료 -&amp;gt; 파일 읽기에 대해 응답2번을 보면, 대기 부분이 어플리케이션 입장에서는 Blocked(대기)이며, 응답이 올 때까지 아무것도 못하는 상태가 됩니다.Non-Blocking I/OBlocking 모델과는 반대로 I/O 작업이 진행되고 있더라도 해당 유저 프로세스의 작업을 중단시키기 않습니다.예를들어  어플레케이션 -&amp;gt; 운영체제(커널) 파일 읽기를 요청  운영체제(커널) I/O 처리 시작 -&amp;gt; 다른 프로세스가 이미 사용중 -&amp;gt; 데이터가 없어도 일단 응답  1,2 번 반복 후 데이터가 있으면 -&amp;gt; 결과 응답Blocking I/O와는 다르게 I/O의 진행상황에 상관없이 대기하지 않습니다. 하지만 결과를 응답하기 위해 반복적인 호출을 하기 때문에 자원이 낭비됩니다.프로세스위키백과 : 프로세스프로세스는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말합니다. 종종 스케줄링의 대상이 되는 작업(Task)이라는 용어와 거의 같은 의미로 쓰입니다. 여러 개의 프로세서를 사용하는 것을 멀티프로세싱이라고 하며, 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 멀티태스킹이라고 합니다.프로그램과 프로세스를 혼동할 수 있는데,  프로그램은 일반적으로 하드 디스크에 저장되어 있는 실행코드(파일)를 말합니다.  프로세스는 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에 실행되고 있는 작업 단위를 지칭합니다.  하나의 프로그램을 여러 번 구동하게 되면 여러 개의 프로세스가 메모라 상에서 실행됩니다.스레드위키백과 : 스레드스레드(Thread)는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 멀티스레드(multithread)라고 한다.프로세스 vs 스레드  멀티프로세스와 멀티스레드 둘다 여러 흐름이 동시에 진행된다는 공통점을 가지고 있습니다.  멀티프로세스에서 각 프로세스는 독립적으로 실행되며, 각각 별개의 메모리를 차지하고 있는 것과 달리 멀티스레드는 프로세스 내의 메모리를 공유해 사용할 수 있습니다.  프로세스 간의 전환 속도 보다 스레드 간의 전확 속도가 빠릅니다.  멀티스레드는 CPU가 여러 개일 경우에 각각의 CPU가 스레드 하나씩을 담당하는 방법으로 속도를 높일 수 있다는 장점을 가지고 있습니다.  그게 가능한 이유는 여러 스레드가 실제 시간상으로 동시에 수행될 수 있기 때문입니다.  하지만, 멀티스레드의 단점은 각각의 스레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없다는 것입니다.멀티 스레드위키백과 : 스레드멀티스레딩(multithreading) 컴퓨터는 여러 개의 스레드를 효과적으로 실행할 수 있는 하드웨어 지원을 갖추고 있다. 이는 스레드가 모두 같은 주소 공간에서 동작하여 하나의 CPU 캐시 공유 집합과 하나의 변환 색인 버퍼 (TLB)만 있는 멀티프로세서 시스템 (멀티 코어 시스템)과는 구별한다. 그러므로 멀티스레딩은 프로그램 안에서 병렬 처리의 이점을 맛볼 수 있지만 멀티프로세싱 시스템은 여러 개의 프로그램들을 병렬로 처리할 수 있다. 멀티프로세싱 시스템이 여러 개의 완전한 처리 장치들을 포함하는 반면 멀티스레딩은 스레드 수준뿐 아니라 명령어 수준의 병렬 처리에까지 신경을 쓰면서 하나의 코어에 대한 이용성을 증가하는 것에 초점을 두고 있다.정리하여  프로세스를 다수의 실행 단위로 나누어서 실행합니다.  프로세스 내에서 자원을 공유하며, 자원생성과 관리의 중복을 최소화합니다.  각각의 스레드가 고유의 레지스터와 스택을 사용합니다.멀티 스레드의 장단점장점  응답성 : 일부분의 레드가 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속되어, 사용자에 대한 응답성이 증가됩니다. 예를 들어 웹 브라우저 프로그램에서 하나의 스레드가 이미지 파일을 로드하고 있더라도, 다른 스레드에 사용자와의 상호작용이 가능합니다.  자원 공유 : 프로세스의 자원들과 메모리를 공유합니다.  경제성 : 프로세스 생성에 메모리와 자원을 할당하는 것은 비용이 많이 든다. 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에, 스레드를 생성하고 문맥교환을 하는 편이 보다 경제적입니다.  멀티프로세서 활용 : 멀티프로세서 구조에서는 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있다. 단일 스레드 프로세스는 CPU가 많아도 CPU 한개에서만 실행된다. 즉, 다중 스레드화를 하면 다중 CPU에서 병렬성이 증가된다.단점  같은 자원을 공유할 때 서로를 간섭할 수 있다.  멀티스레드 프로세스에서, 하나의 스레드만 실행 중인 경우 스레드의 실행 시간이 개선되지 않고 오히려 지연될 수 있다.  멀티스레딩의 하드웨어 지원을 위해 응용 프로그램과 운영체제 둘 다 충분한 변화가 필요하다.  스레드 스케줄링은 멀티스레딩의 주요 문제이기도 하다.한계멀티스레드 방식은 요청마다 스레드를 발생시켜 처리한다고 말씀드렸죠? 이런 방식은 IO Blocking 모델을 해결하는 이상적인 방법으로 보일 수 있습니다. 하지만 몇 가지 한계도 존재합니다.  멀티스레드 방식은 클라이언트 요청 마다 스레드를 발생시키기 때문에, 요청 수가 많으면 많을수록 스레드 수도 기하급수적으로 발생하게 됩니다. 그 만큼 메모리 자원을 사용한다는 말입니다. 하지만, 서버의 자원은 제한적이기 때문에 일정 수 이상의 스레드를 발생시킬 수 없습니다.  위의 근본적인 문제때문에 실제로, 서버의 사양을 업그레이드 시키거나 Load-Balancing 등으로 분산처리하여 해결하고 있습니다.비동기 처리  Node.js의 비동기 처리에 대해 잘 설명한 블로그를 참고참고자료 : Node.js: 비동기 프로그래밍 이해"
  },
  
  {
    "title": "TDD란 무엇이고, 왜 많은 기업에서 TDD 방식을 선호하지 않을까?",
    "url": "/posts/TDD/",
    "categories": "TDD",
    "tags": "TDD",
    "date": "2021-12-06 00:00:00 +0900",
    





    "snippet": "TDD란TDD란 Test Driven Development 약자로 ‘테스트 주도 개발’ 이라고 합니다. 즉, TEST CASE를 먼저 작성한 뒤 실제 코드를 작성하는 방법입니다.의문점2년동안 SI 프로젝트를 3건을 진행하고, 내부 프로젝트, REST API 개발 등 여러 가지를 개발 업무를 하면서 왜? 많은 기업에서 특히 중소기업에서는 TDD 방식을 선호하지 않을까? 라는 의문점과 그 이유를 경험을 기반으로 포스팅하려 합니다.기존 개발 방식의 문제점기존 개발방식은 설계 -&amp;gt; 코드개발 -&amp;gt; 테스트 -&amp;gt; 설계(수정)) 순서로 진행되며, 테스트를 하다가 설계 및 개발코드를 다시 수정하는 경우가 비일비재합니다.실제로 SI 프로젝트를 진행할 때 보통 화면설계, DB설계를 마친 뒤 코드개발을 진행 합니다.그 이후 테스트 시나리오를 작성하게 되는데, 보통 INPUT -&amp;gt; OUTPUT이 제대로 작동하고 있는지에 대한 테스트가 대부분이기 때문에 흔히 스파게티 코드, 하드코딩, 재사용성 Zero 여도 OUTPUT만 제대로 나온다면 통과가 됩니다.뿐만 아니라 많은 문제점이 있는데, 크게 3가지로 정리해봤습니다.[문제점 1] : 설계 및 개발 완료 후 테스트를 진행하므로, 잘못된 설계 및 개발코드의 재수정 필요  보통 개발이 완료된 후 테스트 시나리오를 작성하고 테스트를 진행하게 됩니다.  단순히 개발코드의 로직에 문제가 있으면 다행이지만(그냥 코드수정만 하면되므로) 설계 밑단부터 문제가 있으면 처음부터 다시 해야되는 상황이 발생하게 됩니다.  보통 기간 및 공수를 산정하고 프로젝트를 진행하기 때문에 이러한 문제가 발생하면 납기일에 차질이 생기게 됩니다.[문제점 2] : 납기 위주의 프로젝트성이 강하다 보니 소프트웨어의 완성도가 떨어짐  SI 프로젝트의 최고의 단점은 소프트웨어의 품질보다 납기일 준수입니다. 즉, 소프트웨어의 퀄리티가 떨어지더라도 프로젝트 완료에 초점을 둔다는 것입니다.  실제로 SI 프로젝트를 하다보면, 재사용성 및 유지보수를 염두해서 개발하시는 분들은 극히 드물다고 생각합니다. 그 이유는 충분한 시간이 보장되지 않으며 납기일 준수에만 집중하기 때문입니다.[문제점 3] : 유지보수의 어려움  만약, 화면상 데이터가 이상하게 나온다면 프론트 문제인지, 백엔드 문제인지, DB상의 문제인지, UI 문제인지 전부 하나씩 디버깅해야 한다. 왜냐하면 기능별로 테스트가 정의되어 있지 않기 때문에 어떤 에러가 발생했을 때 어떤 기능이 문제인지 알 방법이 없다.  따라서, 해당 섹터를 개발한 개발자가 아니라면 전체 로직을 이해하고 디버깅하는데 오랜 시간이 필요하다.TDD 방식의 장/단점TDD (테스트 주도 개발)은 기존 개발 방식과는 다르게 설계(디자인) &amp;lt;-&amp;gt; 테스트 코드 작성 -&amp;gt; 코드개발를 진행한다. 테스트 코드 작성 이라는 부분에서 기존의 테스트와 혼동할 수 있는데, 정확하게는 다르다. 또한 단위 테스트(unit Test)로 진행하기 때문에 실패시 최소한의 코드개선과 성공시 실제 코드개발로 적용하는 리팩토링 과정이 이루어진다.[장점 1] : TDD의 테스트 코드는 해당 기능의 정상 작동여부를 검증하기 위한 것  기존 방식의 테스트는 어떤 값이 들어오면 어떤값으로 나오겠지?의 단순한 INPUT 대비 OUTPUT이다. 하지만 TDD의 테스트는 코드는 해당 기능이 정상적으로 작동하기 위한 테스트이다.  예를들어, SUM(INPUT1,INPUT2, INPUT3) 이라는 기능을 만들 때 SUM의 기능이 정상적으로 작동하기 위한 테스트 코드를 작성해 볼 수 있다.          INPUT1, INPUT2, INPUT3 이 INT 타입으로 들어 오는가? -&amp;gt; 맞으면 True, 아니면 False      INPUT1, INPUT2, INPUT3 이 2자리 수 인가? -&amp;gt; 맞으면 True, 아니면 False      INPUT1, INPUT2, INPUT3 의 총합은 0이상 300 이하인가? -&amp;gt; 맞으면 True, 아니면 False        단위 테스트를 통해 개선코드를 최소화 할 수 있으며, 이는 철저한 모듈화로 종속성과 의존성이 낮은 소프트웨어 개발이 가능하게 합니다.  디버깅 시간을 단축할 수 있으며, 어디서 발생한 에러인지 손 쉽게 찾을 수 있습니다.[장점 2] : 불확실한 미래에 대비하여 큰 실패를 줄이기 위한 것  만약, 여러번 해본 개발이거나 어떤 결과가 나올지 뻔히 알고있는 경우라면 TDD가 비효율적이라고 생각한다. TDD를 하는 가장 큰 이유는          처음 해보는 프로젝트 (어떤 에러가 발생할 지 전혀 예상할 수 없기 때문에)      요구사항이 다양한 경우 (고객사의 요구사항이 매번 바뀌는 경우가 많음)      [장점 3] : 객체지향적인 개발로 재사용성 보장  TDD 방식의 목적이라고 말할 수 있을 정도로 중요합니다. 모든 코드는 재사용성을 기반으로 작성되어야 하기 때문입니다.  [장점 1] 이 가능하게 되는 이유가 여기에 있다고 말할 수 있습니다. 그 이유는 복잡한 기능을 모듈단위로 쪼개어 개발하기 때문에 테스트의 용이성을 보장하는 겁니다.[장점 4] : 시간 단축  시간 단축은 많은 것을 내포하고 있습니다.          디버깅 시간 단축      코드 수정 시간 단축      설계 수정 시간 단축      유지보수 시간 단축      [단점] : 개발 생산성 저하많은 개발자들은 TDD 방식이 생산성이 저하된다고 생각한다. 그 이유는 코드를 2번이나 짜야되기 때문이다. 많은 회사에서 TDD 방식을 사용하지 않기에 개발자들 또한 익숙하지 않다고 생각합니다.대한민국 개발 생태계에서는 납기일 준수가 중요하기 때문에 큰 기업이 아니고서야 TDD방식을 사용하는 기업은 드물다고 생각합니다.마무리예전 만O SI 프로젝트를 진행하면서 느꼈던 경험을 기반으로 포스팅을 작성했습니다. TDD 방식의 개발 경험은 없지만, 테스트를 일상화하는 개발자가 되고 싶어 해당 포스팅을 작성하게 되었습니다.1년차때는 왜 회사는 핫한 view, react, angular를 사용하지 않는지?, 왜 코드리뷰나 TDD 방식을 하지 않는지? 등의 여러 의구심과 불만을 가졌지만현재는 회사의 상황, 시대적 흐름, 개발 생태계와 같은 거시적인 관점으로 바라볼 필요성을 느끼게 되었습니다. 당장 내가 하고싶은 기술보다는 회사의 상황과 필요로하는 기술을 받아드리는게 우선이 아닐까? 라는 생각을 갖게 되었습니다."
  },
  
  {
    "title": "[Git] branch의 이해와 사용",
    "url": "/posts/git-03/",
    "categories": "Git",
    "tags": "Git, Github",
    "date": "2021-12-04 00:00:00 +0900",
    





    "snippet": "브랜치(branch)란?프로젝트를 진행할 때 개발자들은 동일한 소스코드를 같이 공유하고 작업하게 된다. 같이 작업을 하다보면 어떤 개발자는 새로운 기능을 추가하고 또 다른 개발자는 버그를 잡아내거나 합니다.이와 같이 동일한 소스코드를 공유하더라도 하는 업무는 다르기 때문에 각기 다른 버전의 코드가 만들어 질 수 밖에 없다.이럴 때 사용하는게 바로 브랜치(branch) 기능이다. 브랜치(branch)는 여러 개발자가 협업할 때 각기 다른 버전관리를 할 수 있도록 해준다. 각자 독립적인 작업 영역(저장소) 안에서 마음대로 소스코드를 생성 및 변경한다. 이렇게 분리된 여러 작업 내용들을 원래의 버전과 비교하여 병합(merge)하게 된다.브랜치는 메인 브랜치를 복제한다.처음 저장소를 생성하면, Git은 master라는 이름의 브랜치를 만들어 준다. 이걸 메인 브랜치라고 부르며, 새로운 브랜치를 생성하게되면 메인브랜치의 최신 소스코드를 복제하여 가져오게 된다.  이미지 출처브랜치의 종류프로젝트 버전관리를 효과적으로 하기 위해선, 협업하는 개발자들과 어떻게 브랜치를 생성할 것이며 어떻게 통합할 것인지 미리 정하고 작업한다.브랜치는 크게 2가지로 나누어 관리한다.통합 브랜치(Integration Branch)통합 브랜치는 언제든 배포할 수 있는 버전을 유지해야 하는 브랜치이다. 따라서, 미완성되거나 불안정한 상태의 소스코드가 있으면 안된다.다시 말해, 늘 안정적인 상태를 유지해야 한다는 것이다. 여기서 안정적인 상태란 애플리케이션의 모든 기능이 정상적으로 동작하는 상태를 말한다.따라서, 새로운 기능을 추가한다거나 버그를 수정할 때 통합 브랜치에서 작업하는 것이 아니라 토픽 브랜치를 따로 만들어서 작업을 해야 한다.일반적으로 저장소를 처음 생성할 때 master라는 이름의 브랜치가 생성되는데 이것을 통합 브랜치로 사용한다.토픽 브랜치(Topic Branch)토픽 브랜치란 기능추가, 개선, 수정 등의 Task 작업을 진행할 때 사용하는 브랜치이다. 여러 개의 작업을 동시에 진행할 때에는, 그 수만큼 토픽 브랜치를 생성할 수 있다.토픽 브랜치는 통합 브랜치의 최신 소스코드를 복제하여 만들어진다. 토픽 브랜치의 작업이 완료되면 통합 브랜치에 병합한다. 이러한 토픽 브랜치 방식을 Feature Branch라고도 부른다.이미지 출처브랜치 사용하기이론보다는 실습이 이해가 빠르므로 간단한 예제를 통해 브랜치 생성부터 병합까지 진행해보자.일단 저장소 하나를 생성하자.로컬 작업 디렉토리를 하나 생성하고 원격 저장소랑 연동한다.  $ echo &quot;# branch_test&quot; &amp;gt;&amp;gt; README.md  $ git init  $ git add README.md  $ git commit -m &quot;first commit&quot;  $ git remote add origin https://github.com/s-seongsik/branch_test.git  $ git push -u origin master브랜치 생성하기해당 명령어로 로컬 브랜치를 하나 생성할 수 있다.$ git branch &amp;lt;branchname&amp;gt;add_branch의 이름으로 만들어보자.$ git branch add_branch$ git branch -v  add_branch a9f3bae first commit* master     a9f3bae first commit브랜치 전환하기생성한 add_branch 브랜치에서 작업하기 위해서는 해당 브랜치로 전환해야한다.전환하게 되면 브랜치 안에 있는 마지막 커밋 내용이 작업 트리에 펼쳐진다. 브랜치가 전환되고 이 후의 커밋내용은 전환된 브랜치에 추가된다.브랜치를 전환할 때 사용하는 명령어는 checkout 이다.$ git checkout  add_branchSwitched to branch &#39;add_branch&#39;Tip) 브랜치 생성과 동시에 전환을 하고 싶다면 -b 옵션을 넣으면 된다.$ git checkout -b add_branch토픽 브랜치에서 작업하기add_branch의 내용을 담고있는 add_file.py파일을 하나 생성한다. 그리고 해당 로컬 브랜치에 커밋한다.$ echo &quot;# add_branch&quot; &amp;gt;&amp;gt; add_file.py$ lltotal 2-rw-r--r-- 1 seong 197610 13  1월 28 10:49 add_file.py-rw-r--r-- 1 seong 197610 14  1월 28 10:26 README.md$ git add add_file.py$ git commit -m &quot;add_file&quot;[add_branch ce2241e] add_file 1 file changed, 1 insertion(+) create mode 100644 add_file.py로컬 토픽 브랜치를 원격 저장소에 푸시하기새로 만든 토픽 브랜치에 어려번 커밋을 하게 되더라도 결국 로컬에만 저장된다. 원격 저장소에 백업 및 팀 구성원들이 작업 내용과 진도를 확일할 수 있도록 push한다.원격 저장소에는 add_branch 브랜치가 없기 때문에 git push -u origin &amp;lt;branchname&amp;gt;으로 push한다.여기서 -u (--set-upstream) 옵션은 로컬 기능 개발 브랜치와 원격 저장소와 같은 이름의 브랜치를 연결하는 역할을 한다. 쉽게말해, 로컬 브랜치를 원격 저장소에 똑같은 이름으로 동기화 하겠다는 말이다. 한 번 연결한 브랜치는 이후 git push로 푸시할 수 있다.$ git push -u origin add_branchEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 8 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 289 bytes | 289.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: remote: Create a pull request for &#39;add_branch&#39; on GitHub by visiting:remote:      https://github.com/s-seongsik/branch_test/pull/new/add_branchremote:To https://github.com/s-seongsik/branch_test.git * [new branch]      add_branch -&amp;gt; add_branchBranch &#39;add_branch&#39; set up to track remote branch &#39;add_branch&#39; from &#39;origin&#39;.풀 리퀘스트 검토 및 통합 브랜치에 병합하기add_branch 브랜치의 변경 사항을 바로 merge하기 보다는 변경사항이 무엇인지 검토하고 관리자가 통합 브랜치에 병합하는게 좋다.(병합 작업은 누구든 할 수 있다.)일단 로컬의 master 브랜치가 최신버전이라고 가정한다.  github에서 풀 리퀘스트 내용을 확인해서 병합할 것인지 검토한다.(UI를 제공하므로 깃허브에서 확인하길 바람)  master 브랜치로 전환  add_branch 브랜치의 내용을 가져온다.(fetch는 원격 저장소의 변경 내용을 먼저 로컬 저장소로 가져오는 명령어)  add_branch 브랜치의 내용을 로컬 master 브랜치와 병합한다.  로컬 master 브랜치의 내용을 원격 저장소에 커밋한다.  $ git checkout master  $ git fetch origin add_branch  $ git merge origin/add_branch  $ git push origin master브랜치 삭제하기이제 통합 브랜치에 통합되었기 때문에 더이상 add_branch 브랜치는 필요가 없다. 따라서 브랜치를 삭제하면된다.참고) 삭제할 브랜치에서 다른 브랜치로 전환해야 삭제가 가능하므로 참고바란다.seong@DESKTOP-O5CIEJV MINGW64 /e/study/branch_test (add_branch)$ git branch -d add_brancherror: Cannot delete branch &#39;add_branch&#39; checked out at &#39;E:/study/branch_test&#39;$ git checkout master$ git branch -d add_branch$ git branch* master"
  },
  
  {
    "title": "[Git] Github 원격저장소와 로컬저장소 연동하기",
    "url": "/posts/git-02/",
    "categories": "Git",
    "tags": "Git, Github",
    "date": "2021-12-03 00:00:00 +0900",
    





    "snippet": "깃허브 원격저장소와 로컬저장소 연동을 머리속에서만 알고있었고, git 관련 명령어도 필요할 때마다 구글링으로 찾아서 처리했었는데…날잡고 정리해서 내것으로 만들어야지 생각만하다가 오늘 정리하기로 맘먹었다.오늘은! 로컬 저장소(workspace)를 깃허브 원격저장소에 연동하는 방법에 대해 포스팅 해보겠습니다.참고로, git이 설치가 안되신분들은 git을 설치하고 오시기 바랍니다.로컬 저장소 생성  Git Bash 실행  본인이 작업할 로컬 workspace(폴더)를 생성합니다.  생성할 위치 이동 + git_test라는 이름의 폴더 생성합니다.      seong@DESKTOP-O5CIEJV MINGW64 ~  $ cd E:/project &amp;amp;&amp;amp; mkdir git_test        생성한 workspace(폴더) git_test에서 git 저장소를 생성합니다.      seong@DESKTOP-O5CIEJV MINGW64 /e/project  $ cd git_test/  seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test  $ git init  Initialized empty Git repository in E:/project/git_test/.git/        파일 생성      seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ vi test.py        git status로 상태를 확인해보면 생성된 test.py 파일을 git에 추가할 수 있다고 나옵니다.      seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git status  On branch master  No commits yet  Untracked files:  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)          test.py  nothing added to commit but untracked files present (use &quot;git add&quot; to track)        git 저장소에 추가  No commits yet : 아직 커밋을 하지 않다고 나옵니다.      seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git add test.py  seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git status  On branch master  No commits yet  Changes to be committed:  (use &quot;git rm --cached &amp;lt;file&amp;gt;...&quot; to unstage)          new file:   test.py        git commit  -m &quot;test commit add test.py&quot; &amp;lt;- commit message      seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git commit -m &quot;test commit add test.py&quot;  [master (root-commit) fc4e43a] test commit add test.py  1 file changed, 0 insertions(+), 0 deletions(-)  create mode 100644 test.py      원격 저장소 생성 및 연동      github repository 생성합니다.            code -&amp;gt; HTTPS 누르시면 URL이 나오는데 COPY합니다.        git remote, 로컬 저장소와 원격 저장소를 연동합니다.  git remote add [원격저장소별칭] [원격저장소URL]      seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git remote add origin https://github.com/s-seongsik/github_test.git        remote 연결을 확인합니다.      seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git remote  origin  $ git remote -v  origin    https://github.com/s-seongsik/github_test.git (fetch)  origin    https://github.com/s-seongsik/github_test.git (push)        git push [원격저장소별칭] [로컬브랜치이름]  --all 을 붙이면 로컬의 모든 브랜치를 push 합니다.```console  # 로컬브랜치 확인  seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git branch          master        # push  seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git push origin master  Enumerating objects: 3, done.  Counting objects: 100% (3/3), done.  Writing objects: 100% (3/3), 230 bytes | 230.00 KiB/s, done.  Total 3 (delta 0), reused 0 (delta 0)  remote:  remote: Create a pull request for ‘master’ on GitHub by visiting:  remote:      https://github.com/s-seongsik/github_test/pull/new/master  remote:  To https://github.com/s-seongsik/github_test.git          [new branch]      master -&amp;gt; master```            원격저장소를 보면 연동된 master 로컬브랜치에 test.py가 생성된것을 볼 수 있습니다.      파일 수정해보기      test.py를 수정합니다.        git status로 상태확인  modified : test.py &amp;lt;-라는 문구에서 변경 확인이 가능합니다.      seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git status  On branch master  Changes to be committed:  (use &quot;git restore --staged &amp;lt;file&amp;gt;...&quot; to unstage)          modified:   test.py        위에서 배운대로 git add -&amp;gt; git commit -&amp;gt; git push 를 진행합니다.  tip) git add . 을 하시면 변경된 모든 것을 add 합니다.      seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git add test.py  seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git commit -m &quot;modify test.py&quot;  [master 5a43c8b] modify test.py  1 file changed, 2 insertions(+)  seong@DESKTOP-O5CIEJV MINGW64 /e/project/git_test (master)  $ git push origin master  Enumerating objects: 5, done.  Counting objects: 100% (5/5), done.  Writing objects: 100% (3/3), 272 bytes | 272.00 KiB/s, done.  Total 3 (delta 0), reused 0 (delta 0)  To https://github.com/s-seongsik/github_test  c81e115..5a43c8b  master -&amp;gt; master        test.py 내용이 변경된 것을 확인할 수 있습니다.끝으로로컬저장소와 원격저장소 연동하는 과정을 정리하면서 좀더 github와 git를 깊게 공부하고 싶은 욕심이 생겼습니다.기회가 되면 git으로 협업하는 방법과 git의 원리 및 용어정리 대해 포스팅 해보겠습니다. 감사합니다."
  },
  
  {
    "title": "[Git] Git 이해하기",
    "url": "/posts/git-01/",
    "categories": "Git",
    "tags": "Git, Github",
    "date": "2021-12-02 00:00:00 +0900",
    





    "snippet": "Git과 Github를 활용하여 버전관리를 하는거에 익숙하지만, Git의 원리에 대해 묻는다면 정확하게 답변할 수 없습니다.이번 포스팅은 Git의 배경과 원리를 이해하여 정리해보는 시간을 갖게 되었습니다.목차는 아래와 같이 진행합니다.  버전 관리란?  Git의 배경  Git의 원리버전 관리란?버전 관리 시스템이란? 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템입니다. 버전 관리 방법은 크게 3가지로 나뉩니다.로컬 버전 관리  디렉토리로 파일을 복사하는 방법  이 방법은 가장 간단하므로, 많은 사람들이 사용한다.  하지만, 작업 디렉토리를 삭제하거나, 실수로 인한 수정 및 복사가 발생할 수 있다는 단점이 있다.중앙집중식 버전 관리(CVCS)  CVCS는 파일을 관리하는 중앙서버가 별도로 있고, 클라이언트가 중앙 서버에서 파일을 받아서 사용(Checkout)합니다.  CVCS는 모두 누가 무엇을 하고 있는지 알 수 있다는 장점이 있습니다.  치명적인 결점은, 중앙 서버에 문제가 발생했을 때 그 시간동안 아무도 다른 사람과 협업할 수 없으며 사람들이 하는 일을 백업할 방법도 없습니다.  그리고, 중앙 데이터베이스가 있는 하드디스크에 문제가 생기면 프로젝트의 모든 히스토리를 잃습니다.  즉, 중앙서버가 문제가 생기면 모든 것을 잃습니다.  대표적으로 SVN이 있습니다.분산 버전 관리 시스템(DVCS)  Git이 DVCS에 속하며, DVCS에서의 클라이언트는 단순히 파일의 마지막 스냅샷을 Checkout하지 않습니다.  그냥 저장소를 히스토리와 더불어 전부 복제합니다.  서버에 문제가 생겨도 이 복제물로 다시 작업을 할 수 있습니다.  클라이언트 중에서 아무거나 골라도 서버를 복원할 수 있습니다.  clone은 모든 데이터를 가진 진정한 백업입니다.  DVCS 환경에서는 리모트 저장소가 존재합니다. 리모트 저장소는 많을 수도 있습니다. 따라서 동시에 다양한 그룹과 다양한 방법으로 협업이 가능합니다.Git의 배경Linux 커널은 굉장히 규모가 큰 오픈소스 프로젝트다. Linux 커널의 삶 대부분은(1991–2002) Patch와 단순 압축 파일로만 관리했다. 2002년에 드디어 Linux 커널은 BitKeeper라고 불리는 상용 DVCS를 사용하기 시작했다. 2005년에 커뮤니티가 만드는 Linux 커널과 이익을 추구하는 회사가 개발한 BitKeeper의 관계는 틀어졌다. BitKeeper의 무료 사용이 재고된 것이다. 이 사건은 Linux 개발 커뮤니티(특히 Linux 창시자 Linus Torvalds)가 자체 도구를 만드는 계기가 됐다. Git은 BitKeeper를 사용하면서 배운 교훈을 기초로 아래와 같은 목표를 세웠다.  빠른 속도  단순한 구조  비선형적인 개발(수천 개의 동시 다발적인 브랜치)  완벽한 분산  Linux 커널 같은 대형 프로젝트에도 유용할 것(속도나 데이터 크기 면에서)Git의 원리Git을 사용하기 전에 Git의 원리를 먼저 이해하는 것이 중요할 것 같다. 기존의 VCS, CVCS와의 차이점은 무엇인지 알아보자.스냅샷Git이 다른 버전 관리 도구와 다른 점은 스냅샷(snapshot) 방식을 이용한다는 것입니다. CVS, Subversion, Perforce, Bazaar 등의 시스템들은 각 파일의 변화를 시간순으로 관리하면서 파일들의 집합을 관리합니다. 쉽게 말해 이전에 파일을 복사하여 관리합니다. 파일을 복사하는 방식으로 수정본을 관리하게 되면 같은 내용을 반복 저장하기 때문에 용량을 많이 차지합니다. 또 수정된 부분들을 일일이 찾아야 하므로 검색할 때 불편합니다.Git은 이러한 시스템적인 단점을 보완하고자 변경된 파일 전체를 저장하지 않고, 파일에서 변경된 부분만 찾아 수정된 내용만 저장합니다. 마치 변화된 부분만 찾아 사진을 찍는 것과 같다고 해서 스냅샷 방식이라고 말합니다.스냅샷 방식은 커밋을 기반으로 사진을 찍습니다. 커밋은 파일 변화를 깃 저장소에 영구적으로 기록합니다. 또한, 빠르게 버전의 차이점을 처리하고, 용량을 적게 사용합니다.거의 모든 명령은 로컬에서 실행거의 모든 명령이 로컬의 파일과 데이터만 사용하기 때문에 네트워크에 영향을 받지 않습니다. 이는 네트워크 속도에 영향을 받는 CVCS보다 월등히 높은 속도를 자랑합니다.Git은 프로젝트의 모든 히스토리가 로컬 디스크에 있기 때문에 모든 명령이 순식간에 실행됩니다.  Git은 프로젝트의 히스토리를 서버없이 조회합니다. 그냥 로컬 데이터베이스에서 읽기 때문에 속도가 빠릅니다.  Git은 현재버전과 예전버전 상태를 비교할 때 로컬에서 찾기 때문에 리모트에 있는 서버에 접근할 필요가 없습니다. 즉, 오프라인 상태거나, VPN이 없어거나, 네트워크가 안되도 막힘 없이 일 할 수 있는 장점을 가지고 있습니다.무결성Git은 데이터를 저장하기 전에 항상 체크섬을 구하고 그 체그섬으로 데이터를 관리합니다. 체크섬이란 Git에서 사용하는 가장 기본적인 데이터 단위이자 Git의 기본 철학입니다.Git 없이는 체크섬을 다룰 수 없어서 파일의 상태도 알 수 없고, 데이터를 잃어버릴 수도 없습니다.Git은 SHA-1 해시를 사용하여 체크섬을 생성합니다. 생성한 체크섬은 40자 길이의 16진수 문자열입니다. 파일의 내용이나, 디렉토리 구조를 이용하여 체크섬을 생성합니다.(체크섬 예시 : 24b9da6552252987aa493b52f8696cd6d3b00373)Git은 모든 것을 해시로 식별합니다. 그렇기 때문에 Git은 파일을 이름으로 저장하지 않고 해시로 저장합니다.Git은 데이터를 추가할 뿐이다Git은 어떤 작업을 하던 Git 로컬 데이터베이스에 데이터를 추가합니다. 하지만, 되돌리거나 삭제할 방법이 없습니다. 또한 커밋하지 않으면 변경사항을 잃어버릴 수 있습니다.하지만, 스냅샷을 커밋하고 나면 데이터를 잃어버리기 어렵습니다.Git의 3가지 상태Git은 파일을 Committed, Modified, Staged 이렇게 3가지 상태로만 관리합니다.  Committed는 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 말합니다.  Modified는 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 것을 말합니다.  Staged는 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태를 의미합니다.Git 프로젝트의 3가지 단계Git 프로젝트는 아래와 같은 3가지 단계로 나뉩니다.  Git 디렉토리          Git 디렉토리가 Git의 핵심입니다. 다른 컴퓨터에 있는 저장소를 clone할 때 Git 디렉토리가 생성됩니다.      Git 디렉토리는 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳을 말합니다.      Git 디렉토리는 현재 작업하는 디스크에 있으며, 그 디렉토리 안에 압축된 데이터베이스에서 파일을 가져와 Working 디렉토리를 생성합니다.        working 디렉토리          Working 디렉토리는 특정 버전을 Checkout한 것입니다.      Git 디렉토리에서 생성됩니다.        Staging Area          Staging Area는 Git 디렉토리 안에 있습니다.      Working 디렉토리에서 파일을 수정하면 Staging Area로 추가됩니다.      단순한 파일이며, 곧 커밋할 파일에 대한 정보를 저장합니다.        Git 디렉토리에 있는 파일들은 Committed된 상태입니다.  파일을 수정하고 Staging Area에 추가했으면, Staged 상태입니다.  Checkout 하고 수정했지만, 아직 Staging Area에 추가하지 않으면 Modified 상태입니다.Git의 3가지 상태 실습해보기      test branch에 test.py라는 파일이 있습니다.            test.py을 수정합니다.        Git 상태 확인          Changes not staged for commit: 에 있다고 합니다. 즉, 아직 staged 상태가 아니라는 것입니다.      modified: test.py 라고 되어있는 것을 확인할 수 있습니다.                $ git status        On branch test        Your branch is up to date with &#39;origin/test&#39;.        Changes not staged for commit:        (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)        (use &quot;git restore &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)                modified:   test.py        Untracked files:        (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)                sample_01/        no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)            Staging Area에 추가하기          staged 상태로 추가하기 위해서는 git add로 Staging Area에 추가해줘야 합니다.      git add test.py를 해주고 git status로 상태를 확인해 보니, Changes to be committed: 라고 되어있습니다.      즉, Staged 상태로 변경되었습니다.            $ git add test.py    $ git status    On branch test    Your branch is up to date with &#39;origin/test&#39;.    Changes to be committed:    (use &quot;git restore --staged &amp;lt;file&amp;gt;...&quot; to unstage)            modified:   test.py    Untracked files:    (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)            sample_01/            commit 하기          git commit -m “test.py” 으로 커밋을 실행합니다.      git status에 없는 것을 확인할 수 있습니다.                git log를 통해 commit history를 확인할 수 있습니다.      "
  },
  
  {
    "title": "[python] Windows 스케줄러 기능으로 파이썬 스크립트 작업 등록하기",
    "url": "/posts/python-scheduler-windows/",
    "categories": "Python",
    "tags": "Python, Windows, Linux, Cron, Crontab, Job Scheduler",
    "date": "2021-12-01 00:00:00 +0900",
    





    "snippet": "오늘은 Python 스크립트를 windows 작업 스케줄러에 등록하는 방법에 대해 포스팅 해보겠습니다~이전에 Linux cron과 python apscheduler에 대해 포스팅을 하고나서 windows 에서 제공하는 작업 스케줄러에 대해 포스팅 해야겠다고 생각했습니다.Linux cron과 apscheduler에 대해 궁굼하신 분들은 밑의 링크를 눌러세요![python] Apscheduler vs Cron Job1. 윈도우 작업 스케줄러 실행2. 윈도우 작업 등록      오른쪽 상단에 [작업 만들기]를 클릭        이름에는 작업 등록에 사용될 이름을 기입      관리자 권한으로 실행하는 경우가 많으므로, 가장 높은 수준의 권한으로 실행을 체크 (필요없으면 체크를 안하셔도 됩니다)        [트리거] 탭을 누르시면 작업 주기를 설정할 수 있는 창이 뜹니다.  설정에서 한 번 (최초 1회), 매일, 매주, 매월 중 본인에 맞는 주기를 선택  시작에서 작업 시작시간을 선택      매주 월~금 오후 11:25:55 시간에 파이썬 스크립트를 돌린다고 가정하고 선택        [동작] 탭을 누르시면 실행시킬 프로그램/스크립트를 등록할 수 있습니다  프로그램/스크립트에는 python이 깔려있는 경로 설치경로\\python.exe를 등록해줍니다(ex. D:\\anaconda3\\python.exe)  python으로 실행해야 하므로 python.exe를 등록해야 합니다.  만약, python 설치경로를 모르신다면 cmd -&amp;gt; where python을 입력하면 위치를 알 수 있습니다  저같은 경우에는 가상환경을 따로 만들었고 해당 경로의 python.exe를 입력  인수 추가(옵션)에는 실행시킬 python 스크립트의 절대 경로를 입력      시작 위치(옵션)에는 python 스크립트의 폴더 경로만 입력        [조건] 탭을 누르시면 작업 실행 여부를 결정할 수 있는 트리거들을 설정할 수 있습니다  만약 데스크탑이면 크게 바뀔 건 없지만, 노트북이라면 전원 &amp;gt; [컴퓨터의 AC 전원이 켜져 있는 경우에만 작업 시작] 을 해제  노트북은 배터리로 전원을 키기때문에 작업이 등록되어있어도 실행이 안되는 경우가 생깁니다.      작업 실행 여부에 영향을 미치는 조건을 배제시켜 무조건 돌아가게 만들 수 있습니다.        [설정] 탭을 누르시면 작업의 동작에 영향을 주는 추가 설정을 할 수 있습니다  작업 스케줄러가 제대로 동작 안했을 때 후 처리를 어떻게 할 것인지 설정      후 처리 요구사항이 있지 않다면, 건들지 않고 확인      3. 마무리  linux의 cron과 비슷하게 OS 플랫폼에서 제공하는 기능이다보니 간편하게 스케줄러 작업을 등록할 수 있었습니다.  앞으로 Linux, windows 환경에서 스케줄러 작업을 해야할 상황이 생기면 요긴하게 사용할 것 같습니다."
  },
  
  {
    "title": "[python] Apscheduler vs Cron Job",
    "url": "/posts/python-scheduler/",
    "categories": "Python",
    "tags": "Python, Windows, Linux, Cron, Crontab, Job Scheduler",
    "date": "2021-11-30 00:00:00 +0900",
    





    "snippet": "python 개발일을 하다보면 스케줄러 프로그램을 만들일이 생기는데, python에서 스케줄러 라이브러리와 linux에서 제공하는 스케줄링 기능에 대해 알아보고어떤 상황에 무엇을 사용해야 좋을지 포스팅 해보겠습니다.APSchedulerAdvanced Python Schedule의 약자로 python code가 한 번 또는 주기적으로 실행되도록 예약할 수 있는 python libary cron Daemon 이나 windows 작업 스케줄러와 같은 플랫폼별 스케줄러에 대체품으로 사용scheduling 방식  Cron 스타일 스케줄링  Interval(간격) 기간 실행  일회성 지연 실행같이 사용할 수 있는 시스템  메모리 (default)  SQLAlchemy  몽고DB  레디스  RethinkDB  주키퍼  Flask  Djangoscheduling 선택가장 많이 사용되는 2가지를 소개하겠습니다.  BlockingScheduler: 스케줄러가 프로세스에서 실행 중인 유일한 경우에 사용  BackgroundScheduler: 프레임워크를 사용하지 않고 스케줄러가 애플리케이션 내부의 백그라운드에서 실행되기를 원할 때 사용사용방법pip를 사용하여 설치 보통 작업하는 가상환경에 설치 $ pip install apschedulerBlockingScheduler    import time    from apscheduler.schedulers.blocking import BlockingScheduler    sched = BlockingScheduler()    # 3초마다 실행    @sched.scheduled_job(&#39;interval&#39;, seconds=3, id=&#39;test_1&#39;)    def test1():        print(f&#39;test1 : {time.strftime(&quot;%H:%M:%S&quot;)}&#39;)    print(&#39;job Start&#39;)    sched.start()    print(&#39;job end&#39;)    job Start    test1 : 10:13:44    test1 : 10:13:47    test1 : 10:13:50    test1 : 10:13:53    test1 : 10:13:56    ...BlockingScheduler 스케줄러를 사용하게되면 sched.start()에 block이 걸려 해당 프로세스만 계속해서 유지하고 있기 떄문에print(‘job end’)가 실행되지 않습니다.BackgroundScheduler    import time    from apscheduler.schedulers.background import BackgroundScheduler    sched = BackgroundScheduler()    # 3초마다 실행    @sched.scheduled_job(&#39;interval&#39;, seconds=3, id=&#39;test_1&#39;)    def test1():        print(f&#39;test1 : {time.strftime(&quot;%H:%M:%S&quot;)}&#39;)    print(&#39;job Start&#39;)    sched.start()    print(&#39;job end&#39;)    job Start    job endBackgroundScheduler 스케줄러를 사용하게 되면 sched.start() 3초를 기다리지않고 바로 프로그램이 종료됩니다. 백그라운드로 돌아가기 때문입니다.sched.start() 함수 다음에도 다른 작업을 하기 위해서는 BackgroundScheduler를 사용해야 합니다.    import time    from apscheduler.schedulers.background import BackgroundScheduler    sched = BackgroundScheduler()    # 3초마다 실행    @sched.scheduled_job(&#39;interval&#39;, seconds=3, id=&#39;test_1&#39;)    def test1():        print(f&#39;test1 : {time.strftime(&quot;%H:%M:%S&quot;)}&#39;)    print(&#39;job Start&#39;)    sched.start()    print(&#39;job end&#39;)    while True:        time.sleep(1)프로그램을 계속해서 유지하기 위해서는 while문 하나만 넣어주면 됩니다.    job Start    job end    test1 : 10:46:23    test1 : 10:46:26    test1 : 10:46:29    test1 : 10:46:32    test1 : 10:46:35    ...Crontab유닉스/리눅스에서 특정 시간에 특정 작업을 하는 데몬을 Cron이라고 합니다. Cron에서 어떤 명령을 언제 수행하도록 만든 리스트를 Crontab 이라고 합니다.Crontab을 특정 파일을 등록해서 스케줄링 작업한다고 이해한다기 보다, 리눅스 명령어(프로그램)를 스케줄링 한다고 이해하시는게 더 정확한 표현입니다.Crontab 등록, 조회, 삭제리눅스 쉘에서 아래의 명령어를 입력하면 Crontab을 등록할 수 있습니다.    $ crontab -e리눅스 쉘에서 아래의 명령어를 입력하면 동록된 Crontab 리스트를 조회할 수 있습니다.    $ crontab -l리눅스 쉘에서 아래의 명령어를 입력하면 동록된 Crontab 리스트를 삭제할 수 있습니다.    $ crontab -d리눅스 쉘에서 아래의 명령어를 입력하면 동록된 Crontab 리스트를 전체 삭제할 수 있습니다.    $ crontab -rCrontab 설정    * 분(0-59)　　　　　　* 시간(0-23)　　　　　　* 일(1-31)　　　　　　* 월(1-12)　　　　　　* 요일(0-6, 일요일=0)    # 1분 마다 실행    * * * * * path/test.sh    # 10분 마다 실행    */10 * * * * path/test.sh    # 1시간 마다 실행    0 * * * * path/test.sh    # 2시간 마다 실행    0 */2 * * * path/test.sh    # 매일 매시간 10분, 20분, 30분에 test.sh 를 실행    10,20,30 * * * * path/test.sh    # 06~12시내 1시간 마다 실행    00 06-12 * * * path/test.sh    # 매일 15시 0분부터 30분까지 매분 tesh.sh를 실행    0-30 15 * * * path/tesh.sh    # 특정 시간 마다 실행 / 매주 월요일 15시 30분 마다 실행    30 15 * * 1 path/test.shCrontab 주의사항      실행 파일 path 설정, cron은 보안문제로 개인 설정 파일을 참조하지 않습니다. 그러므로 실행 프로그램은 /bin/…/… 같은 일반 경로가 있어야 cron에 제대로 반영됩니다.        crontab 등록시 한줄에 하나씩 등록해야 합니다.        #를 사용하여 주석을 사용할 수 있습니다.        crontab이 실제로 실행됐는지 확인할 수 있는 방법이 없기 때문에 로그를 남겨야 합니다. 로그를 남기는 방법은      # &amp;gt; path/crontab.log 2&amp;gt;%1  입력한 path에 crontab.log라는 파일이 생성되며 실행될 때마다 log를 저장합니다.    * * * * * path/test.sh &amp;gt; path/crontab.log 2&amp;gt;%1  crontab 변경 후에는 반드시 cron을 다시 실행해야 변경 내용이 제대로 반영됩니다.apscheduler vs cron job이번 포스트의 핵심이죠, 저와 비슷한 상황의 사용자에게 도움이 되었으면 좋겠습니다.어떤 기능을 사용할지 고르기전에 어떤 상황인지를 설명드려야겠죠?  상황1 : python script 실행  상황2 : 매일 특정 시간이 되면 실행 (1일 - 1회)만약 python의 apscheduler를 매일 특정시간에 구동시켜야한다면, 세션이 종료되더라도 돌아갈 수 있게 만들어야합니다.예를들어, linux의 nohup과 &amp;amp;(백그라운드)를 사용해서 세션이 종료되더라도 백그라운드로 python script를 돌릴 수 있습니다.하지만, 하루에 한번만 실행하면 되는 조건에서 불필요한 전력, 메모리, cpu 등의 자원을 소비할 필요가 없다고 생각됩니다.반대로, apscheduler는 이미 작성된 code내에서 커스텀이 가능합니다.예를들어 기능마다 실행되야될 시간이 다르다면, 혹은 다른 시스템과의 협업으로 많은 요구사항이 필요하다면 apscheduler를 사용하는게 좋습니다.    import time    from apscheduler.schedulers.background import BackgroundScheduler    sched = BackgroundScheduler()    # 매일 13시 30분에 실행    @sched.scheduled_job(&#39;cron&#39;, hour=&#39;13&#39;, minute=&#39;30&#39;, id=&#39;job_1&#39;)    def job1():        print(&#39;job1&#39;)    # 매일 15시 50분에 실행    @sched.scheduled_job(&#39;cron&#39;, hour=&#39;13&#39;, minute=&#39;50&#39;, id=&#39;job_2&#39;)    def job2():        print(&#39;job2&#39;)    # 매일 17시 10분에 실행    @sched.scheduled_job(&#39;cron&#39;, hour=&#39;17&#39;, minute=&#39;10&#39;, id=&#39;job_3&#39;)    def job3():        print(&#39;job3&#39;)    while True:        time.sleep(1)crontab은 단순히 명령어(프로그램)를 등록하는 것이기 때문에 code내 커스텀이 불가능합니다.결론  자원의 관점, 요구사항이 특정 시간에만 스크립트가 실행되어야 한다(요구사항이 단순) -&amp;gt; crontab  기능의 관점, 기능별로 스케줄 시간이 달라야 하거나, 요구사항이 복잡하다 -&amp;gt; apscheduler"
  },
  
  {
    "title": "네이버 클라우드 서버에 putty, filezila 접속하기",
    "url": "/posts/cloud/",
    "categories": "Cloud, Naver Cloud",
    "tags": "cloud",
    "date": "2021-11-04 00:00:00 +0900",
    





    "snippet": "현재 플랫폼 서비스를 제공하기 위해 고객사에 WAS Server, DB Server를 납품하여 APP과 DB를 관리 및 운영하고있습니다. 이런 방식은 온프레미스 인프라가 증가함에 따라 관리 포인트도 증가하게 됩니다.계속해서, 서비스 환경의 패러다임이 Cloud로 변화되면서 IT산업은 클라우드 기술이 필수 불가결하게 됐다고 생각합니다.따라서, 최근 회사에서도 클라우드 기술에 관심을 갖고 있으며, 이번에 클라우드 기반 docker 컨테이너로 FastAPI기반 REST-API 서버를 구축하게 되었습니다.이번 POST에서는 전반적인 흐름으로 cloud + docker 컨테이너 환경에서 python app을 배포 및 운영하는 방법에 대해 다뤄보도록 하겠습니다.1. Naver Cloud 포트포워딩 설정      server 서비스를 구입을 하면 왼편 Bookmarks 탭에서 Server가 생긴 것을 확인할 수 있습니다.            Server 탭을 누르고 들어가면 아래와 같은 화면이 뜨는데, +서버생성 버튼을 눌러 간편하게 원하는 서버를 생성할 수 있습니다.저는 이미 생성되있는 서버에 배포할 예정입니다. (서버 생성시 인증키 설정을 하게 되는데 인증키는 서버에 접속할 계정생성에 사용됩니다.)            생성된 Server row을 클릭하면 빨간색 표시처럼 포트 포워딩 설정 버튼을 클릭할 수 있도록 변경됩니다.            클릭하게 되면 팝업창이 뜨는데 여기서 외부 포트, 내부 포트를 설정할 수 있습니다.외부포트는 외부에서 해당 클라우드로 접속하기 위한 포트 설정입니다. 저는 putty나 filezila로 ssh로 접속할 때 사용합니다. 이렇게 외부포트로 들어온 접속자를 설정한 내부포트로 연결됩니다.            마지막으로 cloud 서버에 접속하기 위해 서버생성 때 설정한 인증키 인증을 통해서 관리자 비밀번호를 확인한다. (naver cloud 설명서에 자세히 있으니 참고.)        자! 여기까지하면 클라우드 서버를 이용할 수 있습니다. 클라우드를 어렵게 생각할 필요가 없습니다.기존 PC나 서버실과 같은 물리적인 하드웨어가 아닌 가상환경에서 원하는 스펙의 서버를 사용료를 지불하고 이용한다고 생각하면 될 것 같습니다.가장 중요한건! 클라우드 서비스를 어떻게 활용하는가?에 중점을 두어야 합니다.2. putty와 fileZila로 cloud 서버 접속 및 파일 전송하는 방법  윈도우 pc를 사용하는 저는 다른 리눅스 서버에 접속하기 위한 putty와 FTP방식으로 파일을 주고 받을 수 있는 filezilla를 자주 사용합니다.서버, ssh, 원격, FTP, SFTP 등의 개념들을 모른다면..이창을 끄고 공부하고 오길 바랍니다. 기회가 되면 해당 post에 대해 자세히 다뤄보도록 하겠습니다.putty로 cloud 서버 접속  서버 접속용 공인 IP 입력  포트포워딩 설정에서 외부포트로 설정한 port를 입력  SSH 선택  Open  창이 열리면 위 cloud 서버 생성시 생성했던 계정과 비밀번호를 입력 후 접속자! 접속했습니다. 엄청 간단하죠? putty는 ssh로 클라우드 리눅스 서버로 접속하는 프로그램입니다. 윈도우 -&amp;gt; 윈도우 로 연결할 때는 원격데스크탑을 이용하는 것과 같습니다.filezilla로 cloud 서버 접속putty와 같은 ssh 프로토콜로 접속하는 것이기 때문에  서버 접속용 공인 IP 입력  포트포워딩 설정에서 외부포트로 설정한 port를 입력  SFTP - SSH File Transfer Protocol 선택  cloud 서버 생성시 생성했던 계정과 비밀번호를 입력  연결이제 cloud서버에 접속해서 app을 배포할 준비가 완료되었습니다! 다음 포스트는 cloud 서버에 docker container 환경을 구축하여 python app을 배포하는 내용으로 찾아뵙겠습니다."
  },
  
  {
    "title": "[python] 동기/비동기 프로그래밍의 이해",
    "url": "/posts/python-async/",
    "categories": "Python",
    "tags": "Python, Back-End, Synchronous, Asynchronous",
    "date": "2021-11-03 00:00:00 +0900",
    





    "snippet": "프론트엔드 개발자라면 JS의 async/await를 들어봤거나, 구현해본 경험이 있을 겁니다.python 3.5에서도 async/await 문법이 생기면서, 별도의 라이브러리 사용없이 비동기 프로그래밍이 가능해졌습니다.최근에 FastAPI로 REST-API 서버를 구축하는 업무를 맡게되면서 서비스로직을 비동기로 처리해야 할 상황이 생겼습니다.먼저 동기/비동기가 무엇인지, python에서 어떻게 사용하는지 알아보며 더 나아가 고수준의 API를 제공하는 concurrent.futures 모듈에 대해서 다뤄보도록 하겠습니다.동기(synchronous) 프로그래밍동시에 일어난다는 뜻으로, 요청과 결과가 동시에 일어난다는 의미입니다. 요청이 들어오면 시간이 얼마나 걸리던 결과를 return을 해주어야 합니다.동기 프로그래밍은 요청에 따른 결과를 반드시 return 해줘야할 때 사용합니다.기본적으로 python에서 사용하는 함수는 모두 동기프로그래밍입니다.아래 request_func() 함수는 synchronous_programming() 함수를 호출하여 리턴값을 받게 되는데 이는 호출과 동시에 함수에서 리턴해주는 결과 ‘return value’를 꼭 받아야지만 아래 print(result)가 실행됩니다. 만약 synchronous_programming() 에서 리턴을 1시간 후에 한다면, 요청한 client는 1시간을 기다려야 됩니다.  def synchronous_programming():    return &#39;return value&#39;  def request_func():    result = synchronous_programming()    print(result)비동기(Asynchronous) 프로그래밍꼭 요청에 대한 결과를 기다려서 받아야 합니까? 그것을 해결해주는 것이 바로 비동기 프로그래밍입니다.동기 프로그램과 반대로, 요청과 결과가 동시에 일어나지 않아도 됩니다. 결과가 얼마나 걸리든 그 시간동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있는 장점이 있습니다.python에서 사용하는 방법은 def 문법앞에 async를 붙이면 비동기 함수로 작동하게 됩니다.파이썬에서는 async가 붙은 함수를 코루틴(coroutine)라고도 부르는데, 동기 함수와 동일하게 호출하면 코루틴(coroutine) 객체로 리턴됩니다.따라서, async def 함수는 async로 선언된 다른 비동기 함수에 await를 붙여 사용합니다. js에서 async/await 호출 방식과 비슷한 원리입니다.(안다는 가정하에 넘어가겠습니다.)import timeimport asyncioasync def async_func1():    print(&#39;== async_func1 started ==&#39;)    await asyncio.sleep(5)    print(&#39;== async_func1 end ==&#39;)    return &#39;async_func1&#39;async def async_func2():    print(&#39;== async_func2 started ==&#39;)    await asyncio.sleep(3)    print(&#39;== async_func2 end ==&#39;)    return &#39;async_func2&#39;async def async_func3():    print(&#39;== async_func3 started ==&#39;)    await asyncio.sleep(1)    print(&#39;== async_func3 end ==&#39;)    return &#39;async_func3&#39;async def root():    start = time.time()    futures = [async_func1(), async_func2(), async_func3()]    res1, res2, res3 = await asyncio.gather(*futures)        end = time.time()    print(&#39;비동기 처리 시간 : {}&#39;.format(round(end-start)))    return {&quot;res1&quot;:res1, &quot;res2&quot;:res2, &quot;res3&quot;:res3}result = asyncio.run(root())print(result)실행결과를 보면 실행순서는async_func1() -&amp;gt; async_func2() -&amp;gt; async_func3()종료순서는 실행순서와 반대로 끝나는 것을 확인할 수 있다.async_func3() -&amp;gt; async_func2() -&amp;gt; async_func1()== async_func1 started ==== async_func2 started ==== async_func3 started ==== async_func3 end ==== async_func2 end ==== async_func1 end ==비동기 처리 시간 : 5{&#39;res1&#39;: &#39;async_func1&#39;, &#39;res2&#39;: &#39;async_func2&#39;, &#39;res3&#39;: &#39;async_func3&#39;}코드 순서를 자세히 살펴보면  최초 root() 함수를 run(실행)  root() -&amp;gt; 시작은 async_func1(), async_func2(), async_func3() 순서대로 비동기로 실행  async_func3() 함수는 1초후 종료  async_func2() 함수는 3초후 종료  async_func1() 함수는 5초후 종료  모든 비동기 함수가 종료되는 시간은 5초동기프로그래밍으로 작성하게 되면async_func1() 5초 후 종료 -&amp;gt; async_func2() 3초 후 종료 -&amp;gt; async_func3() 1초 후 종료= 총 소요시간 : 9초간단한 예제를 통해 파이썬에서 제공하는 async/await 문법을 사용해서 비동기프로그래밍을 테스트해봤습니다.여기서 알 수 있듯이, 병렬적으로 자원을 사용하기 때문에 동기프로그래밍보다 효율적인 장점이 있습니다.다음 포스트에서는 높은 수준의 API를 제공하는 concurrent.futures 비동기 모듈을 다뤄보도록 하겠습니다."
  },
  
  {
    "title": "01.Three.js 이해",
    "url": "/posts/three.js-chapter01/",
    "categories": "three.js",
    "tags": "Three.js, javascript, front-end, js, 3D, WebGL",
    "date": "2021-10-28 00:00:00 +0900",
    





    "snippet": "Three.js란 무엇인가?Three.js는 웹페이지에서 3차원 그래픽을 표현할 수 있도록 도와주는 자바스크립트 라이브러리, APIThree.js는 특정 웹 브라우저나 플러그인에 의존하지 않고 자바스크립트 언어를 사용하여 웹 컨텐츠의 한 공간을 GPU에서 가속되는 3차원 컨텐츠를 만들 수 있도록 도와준다.이를 가능하게 된 배경에는 WebGl 의 출현으로 가능하게 되었다.Three.js에서 WebGL의 이해가 중요한 것 같다. 밑에서 WebGL에 대해서 알아보자.WebGL이란 무엇인가?WebGL은 Web Graphics Library의 약자로 웹상에서 2D 및 3D 그래픽을 렌더링하기 위한 로우 레벨 Javascript API이다. OpenGL ES 2.0을 기반으로 브라우저 엔진에 내장된 HTML5 Canvas 요소 위에 그려진다.WebGL에 대해 잘 정리된 블로그를 참조했다.WebGL의 장점      로열티 없이 누구나 사용 가능하다.        렌더링 가속화를 지원하는 그래픽 하드웨어(그래픽 카드 등)을 활용한다.        별도의 플로그인이 필요 없으며, 웹 브라우저에 내장되어 실행된다.        OpenGL ES 2.0을 기반으로하므로, 이미 OpenGL API에 대한 경험이 있다면 다루기가 쉽다.        자바스크립트 프로그래밍이 가능하다. 자바스크립트는 자동 메모리 관리를 지원하기 때문에 메모리를 수동으로 할당할 필요도 없고 WebGL이 자바스크립트의 기능을 상속 받는다.        모바일 브라우저에서도 사용 가능하다(모든 모바일 브라우저를 의미하진 않습니다)  정리하자면, WebGL 을 지원하는 브라우저에서 사용가능하며, 자바스크립트로 프로그래밍이 가능한게 큰 매력인 것 같다. 스마트팩토리를 하는 나의 경우에는 실제 공장의 공간을 비슷하게 구현하여 웹에서 3D로 모니터링을 할 수 있도록 사용하면 좋을 것 같다.렌더링(Rendering)렌더링은 컴퓨터 프로그램을 사용하여 모델에서 이미지를 생성하는 프로세스이다. 렌더링 유형은 아래와 같다.  소프트웨어 렌더링          모든 그래픽 계산을 CPU의 도움으로 처리        하드웨어 렌더링          모든 그래픽 계산을 GPU에 의해 수행      이 말은, 서버 사이드 렌더링과 클라이언트 사이드 렌더링을 통해 수행할 수 있다.즉, 서버 사이드 렌더링으로 GPU를 통해 렌더링을 하거나, 클라이언트 사이드 렌더링으로 CPU에서 로컬로 수행할 수 있다는 장점이 있다.브라우저의 WebGL 지원 여부            브라우저      지원여부                  Mozilla Firefox      버전 4.0 이상              Google Chrome      버전 9 이상              Apple Safari      사파리 5.1 이상, 활성화 여부 확인              MS Edge      지원              internet explorer      지원안함, 하지만 IE11부터 마이크로소프트도 WebGL을 지원을 시작        Three.js는 구버전의 IE를 제외하고는 현재 모든 브라우저에서 제공된다고 보면 된다.준비물Three.js는 자바스크립트 라이브러리 이므로, 많은 준비물을 요구하지 않는다.  TEXT 에디터  웹 브라우저  HTML, JS, CSSNEXT다음 시간에는 웹서버를 구축하고, Three.js를 직접 구현해 보도록 해보자.  웹서버 : python - FastAPI  웹브라우저 : Chrome"
  },
  
  {
    "title": "[Web] CORS란 무엇이고, REST API에 어떻게 사용되는가?",
    "url": "/posts/web-cors/",
    "categories": "Web",
    "tags": "Web, CORS, API, HTTP, REST-API",
    "date": "2021-10-21 00:00:00 +0900",
    





    "snippet": "FastAPI로 REST API를 개발하던 도중 CORS라는 것을 접하게 되었다.회사에서 ‘프론트엔드’를 많이 다루다 보니 백엔드 관련 경험이 부족했다.이번 FastAPI를 개발하면서 여러가지 이슈와 개념들을 접하게 되었다.그중 하나가 CORS라는 개념이다.CORS란 무엇인가?교차 출처 리소스 공유(Cross-origin resource sharing, CORS), 교차 출처 자원 공유는 웹 페이지 상의 제한된 리소스를 최초 자원이 서비스된 도메인 밖의 다른 도메인으로부터 요청할 수 있게 허용하는 구조이다.사전정의 그대로 가져온 것이다. 교차 출처 리소스 공유?, 그리고 최초 자원이 서비스된 도메인 밖의 다른 도메인으로부터 요청할 수 있게 허용하는 구조?역시 정의대로 해석하려고하면 이해가 어렵다…잘 정리된 블로그를 보고 이해를 도왔다.참고 블로그 이동URL 구조CORS를 이해기 위해서는 출처(Origin) 라는 개념을 알아야한다.먼저 URL 구조를 살펴보자면,  https://localhost:8080/user?page=1#Origin이란?            Protocol      Host      Port(생략가능)      Path      Query String      Fragment                  https      localhost      8080      user      pase=1      Origin이란?        출처란 URL 구조에서 Protocol, Host, Port를 합친 것을 말한다.동일 출처 정책(Same-Origin Policy)의 개념과 장점과 단점보통 API를 테스트할 때 Postman, swagger를 사용합니다. 해당 툴들을 이용할 땐 잘되다가, 브라우저를 통해 api를 호출하게 되면 CORS policy라는 오류가 발생할 때가 있다. 이거는 브라우저가 동일 출처 정책을 지키기 때문에 다른 출처의 리소스 접근을 금지하기 때문에 발생하는 것이다.동일 출처 정책의 장점은 XSS나 XSRF등의 보안 취약점을 노린 공격을 방어할 수 있다.동일 출처 정책의 단점은 외부 리소스를 사용할 수 없다.동일 출처 정책의 단점을 보완하기 위한 SOP의 예외 조항이 CORS이다.CORS의 동작원리단순 요청 방법(Simple request)단순 요청은 API를 요청하고, 서버는 Access-Control-Allow-Origin 헤더를 포함한 응답을 브라우저에게 보낸다. 브라우저는 Access-Control-Allow-Origin 헤더를 확인해서 CORS 동작을 작동할 지 판단하는 원리단순 요청 방법(Simple request) 조건  요청 메서드는 GET, HEAD, POST 중 하나여야만 한다.  Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink,  Save-Data, Viewport-Width, Width를 제외한 header를 사용하면 안 됩니다.  Content-Type 헤더는 application/x-www-form-urlencoded, multipart/form-data, text/plain 중 하나를 사용해야 합니다.위의 2,3번 조건은 까다로운 편입니다. 2번 조건은 사용자 인증에 사용되는 Authorization 헤더를 사용하지 못하기 때문이고, 3번 조건은 대다수의 REST API들이 Content-Type으로 application/json를 사용하기 때문에 지키기 어렵다.예비 요청을 먼저 보내는 방법(Preflight request)GET, POST, PUT, DELETE 등의 메서드로 API를 요청하기 전에 OPTIONS라는 메서드를 통해 실제 요청을 전송할지 판단한다.OPTIONS 메서드로 서버에 예비 요청을 보낸뒤, 서버는 예비 요청에 대한 응답을 Access-Control-Allow-Origin 헤더를 포함하여 브라우저에게 보낸다. 브라우저는 단순 요청과 동일하게 Access-Control-Allow-Origin 헤더를 확인 후 CORS를 동작할 지 판단하는 원리이다.FastAPI로 개발된 REST API로 CORS 테스트!  현재 내가 위치한 브라우저는 ‘https://beomy.github.io’ 이다. 즉 ‘https://beomy.github.io’ 에서 API서버에 리소스를 요청한다고 생각해보자.  REST API(GET) localhost:8000/user 호출 시 아래의 리소스를 리턴    [  { &quot;username&quot;: &quot;Rick&quot;  },  { &quot;username&quot;: &quot;Morty&quot;  }]        현재 내가 위치한 브라우저의 출처에서 API의 리소스를 요청하면 아래와 같이 Access-Control-Allow-Origin 헤더가 요청리소스에 포함되어 있지 않다라는 오류가 뜬다.  FastAPI 서버에서 응답헤더에 Access-Control-Allow-Origin와 출처를 추가해준다.          allow_methods=[“*“]은 Access-Control-Allow-Methods POST, GET, PUT, DELETE 모두 허용이고      allow_headers=[“*“]은 Access-Control-Allow-Headers 응답 헤더를 모두 허용하겠다는 의미이다.        다시 요청을 보내면 서버에서 리소스가 리턴되는 것을 확인할 수 있다.  개발자 도구 &amp;gt; Network에서 응답 헤더를 확인해보면 서버에서 Access-Control-Allow-Origin 헤더를 브라우저에 보낸것을 확인할 수 있다!.끝으로프론트엔드 개발자 입장에서 서버로 리소스를 요청할 때 CORS 에러가 발생한다면, 서버에 Access-Control-Allow-Origin 등 CORS를 해결하기 위한 몇 가지 응답 헤더를 포함해 달라고 요청한다는 것을 배웠다.Node.js, FastAPI 등의 대부분의 프레임워크에서 CORS 응답 헤더를 추가해 주기는 기능이 있어 간편하게 사용할 수 있지만, CORS가 무엇이고 해당 프레임워크의 지원이 없더라도 CORS 에러 문제가 발생할 때 발생원인과 어떻게 해결해야 되는지 알아보는 시간이었다."
  },
  
  {
    "title": "[Web] API란 무엇이며, 좋은 API를 설계하기 위한 방법이 무엇일까?",
    "url": "/posts/restApi-api-define/",
    "categories": "Web",
    "tags": "Web, REST-API, HTTP",
    "date": "2021-10-14 00:00:00 +0900",
    





    "snippet": "회사에서 naver cloud server와 Docker로 서비스 환경을 구축하고, 구축된 환경에 REST API를 개발 및 배포하는 작업을 맡게되었다.개발하기 앞서, 다음과 같은 질문을 던져보았다.  REST란 무엇인가?  REST API란 무엇인가?  REST API 설계하는 방법1. REST란 무엇인가  ‘Representational State Transfer’의 약자로, 자원을 이름으로 구분하고 자원의 상태(정보)를 주고 받는 모든 것을 의미한다.  즉, 자원(resource)의 표현(representation) 에 의한 상태 전달(json, XML를 통해 데이터를 주고받는 것이 일반적)이다.정의대로 이해하려고하면 무슨말인지 이해가 어려울 수 있으니 더 쉽게 풀어보자면HTTP URI의 이름을 정하는것을 자원(resource)이라고 하고 HTTP Method(POST, GET, PUT, DELETE) 방식으로 CRUD 작업을 수행하는 것이다.  (POST) localhost:8080/user –&amp;gt; user 정보를 등록  (GET) localhost:8080/user –&amp;gt; user 정보 조회  (PUT) localhost:8080/user –&amp;gt; user 정보 수정  (DELTE) localhost:8080/user –&amp;gt; user 정보 삭제=&amp;gt; “/user” 라는 자원(resource)을 Client가  POST(등록), GET(조회), PUT(수정), DELETE(삭제) 행위에 따라 요청하게 되면server는 이제 적절한 정보를 json, xml 등의 형태로 응답해주는 것을 REST이다.2. REST API란 무엇인가?  API(Application Programming Interface)는 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환하는 것  REST API란 위에 REST기반의 서비스를 API로 구현한 것을 말한다.  간단히 말해 REST형식으로 서비스를 구현하고, Client(app)에서 필요한 정보를 요청하면 알맞은 정보를 json 등의 형태로 정보를 리턴해주는 것을 말한다.  카카오맵, 구글맵, 공공데이터, 등 OpenApi를 제공하는 업체들은 대부분 REST API로 제공한다.3. REST API 설계 방법  URI를 보고 직관적으로 이해하기 쉽게 만들어야 한다.  자원(resource)은 동사보다는 명사를 사용한다.  HTTPS Method의 POST, GET, PUT, DELETE의 행위를 리소스에 사용하지 않는다.  리소스간의 관계를 표현한다."
  },
  
  {
    "title": "sample02",
    "url": "/posts/getting-started/",
    "categories": "Blogging, Tutorial",
    "tags": "getting started",
    "date": "2019-08-09 00:00:00 +0900",
    





    "snippet": "PrerequisitesFollow the instructions in the Jekyll Docs to complete the installation of Ruby, RubyGems, Jekyll, and Bundler.InstallationCreating a New SiteThere are two ways to create a new repository for this theme:  Using the Chirpy Starter - Easy to upgrade, isolates irrelevant project files so you can focus on writing.  Forking on GitHub - Convenient for custom development, but difficult to upgrade. Unless you are familiar with Jekyll and are determined to tweak or contribute to this project, this approach is not recommended.Option 1. Using the Chirpy StarterCreate a new repository from the Chirpy Starter and name it &amp;lt;GH_USERNAME&amp;gt;.github.io, where GH_USERNAME represents your GitHub username.Option 2. Forking on GitHubFork Chirpy on GitHub and rename it to &amp;lt;GH_USERNAME&amp;gt;.github.io. Please note that the default branch code is in development.  If you want the site to be stable, please switch to the latest tag and start writing.And then execute:$ bash tools/init.sh  Note: If you don’t want to deploy your site on GitHub Pages, append option --no-gh at the end of the above command.The above command will:  Removes some files or directories from your repository:          .travis.yml      files under _posts      folder docs            If the option --no-gh is provided, the directory .github will be deleted. Otherwise, set up the GitHub Action workflow by removing the extension .hook of .github/workflows/pages-deploy.yml.hook, and then remove the other files and directories in the folder .github.        Removes item Gemfile.lock from .gitignore.    Creates a new commit to save the changes automatically.Installing DependenciesBefore running for the first time, go to the root directory of your site, and install dependencies as follows:$ bundleUsageConfigurationUpdate the variables of _config.yml as needed. Some of them are typical options:  url  avatar  timezone  langCustoming StylesheetIf you need to customize the stylesheet, copy the theme’s assets/css/style.scss to the same path on your Jekyll site, and then add the custom style at the end of the style file.Starting from v4.1.0, if you want to overwrite the SASS variables defined in _sass/addon/variables.scss, create a new file _sass/variables-hook.scss and assign new values to the target variable in it.Running Local ServerYou may want to preview the site contents before publishing, so just run it by:$ bundle exec jekyll sOr run the site on Docker with the following command:$ docker run -it --rm \\    --volume=&quot;$PWD:/srv/jekyll&quot; \\    -p 4000:4000 jekyll/jekyll \\    jekyll serveAfter a while, the local service will be published at http://127.0.0.1:4000.DeploymentBefore the deployment begins, check out the file _config.yml and make sure the url is configured correctly. Furthermore, if you prefer the project site and don’t use a custom domain, or you want to visit your website with a base URL on a web server other than GitHub Pages, remember to change the baseurl to your project name that starts with a slash, e.g, /project-name.Now you can choose ONE of the following methods to deploy your Jekyll site.Deploy by Using Github ActionsFor security reasons, GitHub Pages build runs on safe mode, which restricts us from using plugins to generate additional page files. Therefore, we can use GitHub Actions to build the site, store the built site files on a new branch, and use that branch as the source of the GitHub Pages service.Quickly check the files needed for GitHub Actions build:      Ensure your Jekyll site has the file .github/workflows/pages-deploy.yml. Otherwise, create a new one and fill in the contents of the sample file, and the value of the on.push.branches should be the same as your repo’s default branch name.        Ensure your Jekyll site has file tools/deploy.sh. Otherwise, copy it from here to your Jekyll site.        Furthermore, if you have committed Gemfile.lock to the repo, and your runtime system is not Linux, don’t forget to update the platform list in the lock file:    $ bundle lock --add-platform x86_64-linux      After the above steps, rename your repository to &amp;lt;GH_USERNAME&amp;gt;.github.io on GitHub.Now publish your Jekyll site by:      Push any commit to remote to trigger the GitHub Actions workflow. Once the build is complete and successful, a new remote branch named gh-pages will appear to store the built site files.        Browse to your repository on GitHub. Select the tab Settings, then click Pages in the left navigation bar, and then in the section Source of GitHub Pages, select the /(root) directory of branch gh-pages as the publishing source. Remember to click Save before leaving.            Visit your website at the address indicated by GitHub.  Manually Build and DeployOn self-hosted servers, you cannot enjoy the convenience of GitHub Actions. Therefore, you should build the site on your local machine and then upload the site files to the server.Go to the root of the source project, and build your site as follows:$ JEKYLL_ENV=production bundle exec jekyll bOr build the site on Docker:$ docker run -it --rm \\    --env JEKYLL_ENV=production \\    --volume=&quot;$PWD:/srv/jekyll&quot; \\    jekyll/jekyll \\    jekyll buildUnless you specified the output path, the generated site files will be placed in folder _site of the project’s root directory. Now you should upload those files to the target server.UpgradingIt depends on how you use the theme:      If you are using the theme gem (there will be gem &quot;jekyll-theme-chirpy&quot; in the Gemfile), editing the Gemfile and update the version number of the theme gem, for example:    - gem &quot;jekyll-theme-chirpy&quot;, &quot;~&amp;gt; 3.2&quot;, &quot;&amp;gt;= 3.2.1&quot;+ gem &quot;jekyll-theme-chirpy&quot;, &quot;~&amp;gt; 3.3&quot;, &quot;&amp;gt;= 3.3.0&quot;        And then execute the following command:    $ bundle update jekyll-theme-chirpy        As the version upgrades, the critical files (for details, see the Startup Template) and configuration options will change. Please refer to the Upgrade Guide to keep your repo’s files in sync with the latest version of the theme.        If you forked from the source project (there will be gemspec in the Gemfile of your site), then merge the latest upstream tags into your Jekyll site to complete the upgrade.The merge is likely to conflict with your local modifications. Please be patient and careful to resolve these conflicts.  The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons.Generate the faviconPrepare a square image (PNG, JPG, or SVG) with a size of 512x512 or more, and then go to the online tool Real Favicon Generator and click the button Select your Favicon image to upload your image file.In the next step, the webpage will show all usage scenarios. You can keep the default options, scroll to the bottom of the page, and click the button Generate your Favicons and HTML code to generate the favicon.Download &amp;amp; ReplaceDownload the generated package, unzip and delete the following two from the extracted files:  browserconfig.xml  site.webmanifestNow, copy the remaining image files (PNG and ICO) to cover the original files in the folder assets/img/favicons/ of your Jekyll site. If your Jekyll site doesn’t have this directory yet, just create one.The following table will help you understand the changes to the favicon files:            File(s)      From Online Tool      From Chirpy                  *.PNG      ✓      ✗              *.ICO      ✓      ✗              browserconfig.xml      ✗      ✓              site.webmanifest      ✗      ✓        Note: ✓ means keep, ✗ means delete.The next time you build the site, the favicon will be replaced with a customized edition.Setup Google Analytics superProxy      Clone the Google Analytics superProxy project on Github: https://github.com/googleanalytics/google-analytics-super-proxy to your local.        Remove the first 2 lines in the src/app.yaml file:    - application: your-project-id- version: 1            In src/config.py, add the OAUTH_CLIENT_ID and OAUTH_CLIENT_SECRET that you gathered from your App Engine Dashboard.    Enter any random key for XSRF_KEY, your config.py should look similar to this    #!/usr/bin/python2.7__author__ = &#39;pete.frisella@gmail.com (Pete Frisella)&#39;# OAuth 2.0 Client SettingsAUTH_CONFIG = {  &#39;OAUTH_CLIENT_ID&#39;: &#39;YOUR_CLIENT_ID&#39;,  &#39;OAUTH_CLIENT_SECRET&#39;: &#39;YOUR_CLIENT_SECRET&#39;,  &#39;OAUTH_REDIRECT_URI&#39;: &#39;%s%s&#39; % (    &#39;https://chirpy-test-XXXXXX.ue.r.appspot.com&#39;,    &#39;/admin/auth&#39;  )}# XSRF SettingsXSRF_KEY = &#39;OnceUponATimeThereLivedALegend&#39;        Tip: You can configure a custom domain instead of https://PROJECT_ID.REGION_ID.r.appspot.com. But, for the sake of keeping it simple, we will be using the Google provided default URL.        From inside the src/ directory, deploy the app    [root@bc96abf71ef8 src]# gcloud app deployServices to deploy:descriptor:      [/tmp/google-analytics-super-proxy/src/app.yaml]source:          [/tmp/google-analytics-super-proxy/src]target project:  [chirpy-test-XXXX]target service:  [default]target version:  [VESRION_NUM]target url:      [https://chirpy-test-XXXX.ue.r.appspot.com]Do you want to continue (Y/n)? YBeginning deployment of service [default]...╔════════════════════════════════════════════════════════════╗╠═ Uploading 1 file to Google Cloud Storage                 ═╣╚════════════════════════════════════════════════════════════╝File upload done.Updating service [default]...done.Setting traffic split for service [default]...done.Deployed service [default] to [https://chirpy-test-XXXX.ue.r.appspot.com]You can stream logs from the command line by running:$ gcloud app logs tail -s defaultTo view your application in the web browser run:$ gcloud app browse            Visit the deployed service. Add a /admin to the end of the URL.        Click on Authorize Users and make sure to add yourself as a managed user.    If you get any errors, please Google it. The errors are self-explanatory and should be easy to fix.If everything went good, you’ll get this screen:"
  },
  
  {
    "title": "sample01",
    "url": "/posts/text-and-typography/",
    "categories": "Blogging, Demo",
    "tags": "typography",
    "date": "2019-08-08 00:00:00 +0900",
    





    "snippet": "This post is to show Markdown syntax rendering on Chirpy, you can also use it as an example of writing. Now, let’s start looking at text and typography.TitlesH1 - headingH2 - headingH3 - headingH4 - headingParagraphI wandered lonely as a cloudThat floats on high o’er vales and hills,When all at once I saw a crowd,A host, of golden daffodils;Beside the lake, beneath the trees,Fluttering and dancing in the breeze.ListsOrdered list  Firstly  Secondly  ThirdlyUnordered list  Chapter          Section                  Paragraph                    Task list  TODO  Completed  Defeat COVID-19          Vaccine production      Economic recovery      People smile again      Description list  Sun  the star around which the earth orbits  Moon  the natural satellite of the earth, visible by reflected light from the sunBlock Quote  This line to shows the Block Quote.Tables            Company      Contact      Country                  Alfreds Futterkiste      Maria Anders      Germany              Island Trading      Helen Bennett      UK              Magazzini Alimentari Riuniti      Giovanni Rovelli      Italy      Linkshttp://127.0.0.1:4000FootnoteClick the hook will locate the footnote1, and here is another footnote2.Images  Default (with caption)Full screen width and center alignment  Shadowshadow effect (visible in light mode)  Left aligned      Float to left    “A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space.”        Float to right    “A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space.”  Mermaid SVG gantt  title  Adding GANTT diagram functionality to mermaid  apple :a, 2017-07-20, 1w  banana :crit, b, 2017-07-23, 1d  cherry :active, c, after b a, 1dMathematicsThe mathematics powered by MathJax:\\[\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\]When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]Inline codeThis is an example of Inline Code.Code blockCommonThis is a common code snippet, without syntax highlight and line number.Specific LanguagesConsole$ env |grep SHELLSHELL=/usr/local/bin/bashPYENV_SHELL=bashShellif [ $? -ne 0 ]; then    echo &quot;The command was not successful.&quot;;    #do the needful / exitfi;Specific filename@import  &quot;colors/light-typography&quot;,  &quot;colors/dark-typography&quot;Reverse Footnote            The footnote source &amp;#8617;              The 2nd footnote source &amp;#8617;      "
  }
  
]

